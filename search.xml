<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>zookeeper+kafka</title>
    <url>/2020/04/20/zookeeper+kafka/</url>
    <content><![CDATA[<h2 id="ELK日志收集分析"><a href="#ELK日志收集分析" class="headerlink" title="ELK日志收集分析"></a>ELK日志收集分析</h2><h3 id="下载安装并验证zookeeper"><a href="#下载安装并验证zookeeper" class="headerlink" title="下载安装并验证zookeeper"></a>下载安装并验证zookeeper</h3><p>kafka下载地址：<a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">http://kafka.apache.org/downloads.html</a><br>zookeeper下载地址：<a href="http://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">http://zookeeper.apache.org/releases.html</a></p>
<p><strong>安装zookeeper</strong><br>zookeeper集群特性：整个集群种只要有超过集群数量一半的zookeeper工作只正常的，那么整个集群对外就是可用的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum -y install jdk-8u192-linux-x64.rpm</span></span><br><span class="line">~]<span class="comment"># cd /usr/local/src/</span></span><br><span class="line">~]<span class="comment"># tar xf zookeeper-3.4.13.tar.gz -C /usr/local/src/</span></span><br><span class="line">~]<span class="comment"># cd /usr/local/</span></span><br><span class="line">~]<span class="comment"># ln -sv ./src/zookeeper-3.4.13/ zookeeper</span></span><br><span class="line">~]<span class="comment"># cp zookeeper/conf/zoo&#123;_sample,&#125;.cfg</span></span><br><span class="line">~]<span class="comment"># mkdir  /usr/local/zookeeper/data</span></span><br><span class="line">~]<span class="comment"># grep "^[a-Z]" /usr/local/zookeeper/conf/zoo.cfg </span></span><br><span class="line">tickTime=2000  <span class="comment">#服务器与服务器之间和客户端与服务器之间的单次心跳检测时间间隔，单位为毫秒</span></span><br><span class="line">initLimit=5  <span class="comment">#集群中leader服务器与follower服务器初始连接心跳次数，即多少个2000毫秒</span></span><br><span class="line">syncLimit=5  <span class="comment"># leader与follower之间连接完成之后，后期检测发送和应答的心跳次数，如果该follower 在设置的时间内(5*2000)不能与leader 进行通信，那么此 follower 将被视为不可用。</span></span><br><span class="line">clientPort=2181 <span class="comment">#客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper/data  <span class="comment">#自定义的zookeeper保存数据的目录</span></span><br><span class="line">server.1=192.168.15.211:2888:3888  <span class="comment">#服务器编号=服务器IP:LF数据同步端口:LF选举端口</span></span><br><span class="line">server.2=192.168.15.212:2888:3888</span><br><span class="line">server.3=192.168.15.213:2888:3888</span><br><span class="line">~]<span class="comment"># echo "1" &gt; /usr/local/zookeeper/data/myid</span></span><br></pre></td></tr></table></figure>
<p>本集群共使用三台服务器组建，每台服务器除myid不同其余配置保持一样。<br>启动zookeeper并验证状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 <span class="built_in">local</span>]<span class="comment"># zookeeper/bin/zkServer.sh start</span></span><br><span class="line">[root@node02 <span class="built_in">local</span>]<span class="comment"># zookeeper/bin/zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># zookeeper/bin/zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/<span class="built_in">local</span>/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure>

<p><strong>zookeeper简单操作</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#连接到任意节点生成数据：</span></span><br><span class="line">[root@linux-host3 data]<span class="comment"># /usr/local/zookeeper/bin/zkCli.sh -server 192.168.15.211:2181</span></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None path:null</span><br><span class="line"> create /<span class="built_in">test</span> <span class="string">"hello"</span></span><br><span class="line">Created /<span class="built_in">test</span></span><br><span class="line">[zk: 192.168.15.211:2181(CONNECTED) 1]</span><br><span class="line"></span><br><span class="line"><span class="comment">#在其他zookeeper节点验证数据：</span></span><br><span class="line">[root@linux-host2 src]<span class="comment"># /usr/local/zookeeper/bin/zkCli.sh  -server 192.168.15.212:2181</span></span><br><span class="line">[zk: 192.168.15.212:2181(CONNECTED) 0] get /<span class="built_in">test</span></span><br><span class="line">hello</span><br><span class="line">cZxid = 0x100000004</span><br><span class="line">ctime = Fri Dec 15 11:14:07 CST 2017</span><br><span class="line">mZxid = 0x100000004</span><br><span class="line">mtime = Fri Dec 15 11:14:07 CST 2017</span><br><span class="line">pZxid = 0x100000004</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>

<h3 id="安装测试kafka"><a href="#安装测试kafka" class="headerlink" title="安装测试kafka"></a>安装测试kafka</h3><p>Broker<br>Kafka集群包含一个或多个服务器，这种服务器被称为broker</p>
<p>Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic。（物理上不同topic的消息分开存储，逻辑上一个topic的消息虽然保存于一个或多个broker上但用户只需指定消息的topic即可生产或消费数据而不必关心数据存于何处）</p>
<p>Partition<br>parition是物理上的概念，每个topic包含一个或多个partition，创建topic时可指定parition数量。每个partition对应于一个文件夹，该文件夹下存储该partition的数据和索引文件</p>
<p>Producer<br>负责发布消息到Kafka broker</p>
<p>Consumer<br>消费消息。每个consumer属于一个特定的consuer group（可为每个consumer指定group name，若不指定group name则属于默认的group）。使用consumer high level API时，同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。</p>
<p>在三台服务器上分别安装启动kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host1 src]<span class="comment"># tar xvf kafka_2.11-1.0.0.tgz</span></span><br><span class="line">[root@linux-host1 src]<span class="comment"># ln -sv /usr/local/src/kafka_2.11-1.0.0 /usr/local/kafka</span></span><br><span class="line">[root@linux-host1 src]<span class="comment"># vim /usr/local/kafka/config/server.properties</span></span><br><span class="line">21 broker.id=1  <span class="comment">#设置每个代理全局唯一的整数ID</span></span><br><span class="line">31 listeners=PLAINTEXT://192.168.15.211:9092</span><br><span class="line">103 log.retention.hours=24  <span class="comment">#保留指定小时的日志内容</span></span><br><span class="line">123 zookeeper.connect=192.168.15.211:2181,192.168.15.212:2181,192.168.15.213:2181 <span class="comment">#所有的zookeeper地址</span></span><br></pre></td></tr></table></figure>
<p>启动kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># /usr/local/kafka/bin/kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties  #以守护进程的方式启动</span></span><br></pre></td></tr></table></figure>

<p>测试kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># jps</span></span><br><span class="line">4789 Kafka</span><br><span class="line">1383 QuorumPeerMain</span><br><span class="line">5147 Jps</span><br></pre></td></tr></table></figure>

<p><strong>测试创建topic</strong><br>创建名为logstashtest，partitions(分区)为3，replication(复制)为3的topic(主题)：<br>在任意kafaka服务器操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34102:2181 --partitions 3 --replication-factor 3 --topic logstashtest</span></span><br></pre></td></tr></table></figure>

<p><strong>测试获取topic</strong><br>可以在任意一台kafka服务器上进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --describe --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181 --topic logstashtest</span></span><br><span class="line">Topic:logstashtest	PartitionCount:3	ReplicationFactor:3	Configs:</span><br><span class="line">	Topic: logstashtest	Partition: 0	Leader: 3	Replicas: 3,2,1	Isr: 3,2,1</span><br><span class="line">	Topic: logstashtest	Partition: 1	Leader: 1	Replicas: 1,3,2	Isr: 1,3,2</span><br><span class="line">	Topic: logstashtest	Partition: 2	Leader: 2	Replicas: 2,1,3	Isr: 2,1,3</span><br></pre></td></tr></table></figure>
<p>状态说明：logstashtest有三个分区分别为0、1、2，分区0的leader是3（broker.id），分区0有三个副本，并且状态都为lsr（ln-sync，表示可以参加选举成为leader）。</p>
<p><strong>删除指定topic</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --delete --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34102:2181 --topic logstashtest</span></span><br><span class="line">Topic logstashtest is marked <span class="keyword">for</span> deletion.</span><br><span class="line">Note: This will have no impact <span class="keyword">if</span> delete.topic.enable is not <span class="built_in">set</span> to <span class="literal">true</span>.</span><br></pre></td></tr></table></figure>

<p><strong>获取所有topic</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --list --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181</span></span><br></pre></td></tr></table></figure>

<h3 id="kafka命令测试消息发送"><a href="#kafka命令测试消息发送" class="headerlink" title="kafka命令测试消息发送"></a>kafka命令测试消息发送</h3><p>创建topic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --create --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181 --partitions 3 --replication-factor 3 --topic messagetest</span></span><br><span class="line">Created topic <span class="string">"messagetest"</span>.</span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-console-producer.sh --broker-list 192.168.34.100:9092,192.168.34.101:9092,192.168.34.102:9092 --topic messagetest</span></span><br><span class="line">&gt;hello</span><br><span class="line">&gt;kafka</span><br><span class="line">&gt;logstash</span><br><span class="line">&gt;ss</span><br><span class="line">&gt;oo</span><br><span class="line">&gt;start</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>在其他kafka服务器测试数据获取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-console-consumer.sh  --bootstrap-server 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181 --topic messagetest --from-beginning</span></span><br></pre></td></tr></table></figure>

<h3 id="使用logstash配置文件"><a href="#使用logstash配置文件" class="headerlink" title="使用logstash配置文件"></a>使用logstash配置文件</h3><p>编辑logstash配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>解决xshell连接Linux服务器慢的问题</title>
    <url>/2020/04/20/newfile/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在日常使用xshell6连接centos时会发现链接速度很慢，有些时候就比较急人。这种情况主要是因为xshell在连接centos时使用了DNS解析，我们只需关掉DNS解析就可以了。</p>
<ul>
<li>打开ssh配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#vi /etc/ssh/sshd_config</span></span><br></pre></td></tr></table></figure></li>
<li>在文件内搜索UseDNS这一行，讲yes改为no。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">115 UseDNS no</span><br><span class="line">116 <span class="comment">#PidFile /var/run/sshd.pid</span></span><br><span class="line">/UseDNS</span><br><span class="line">```         </span><br><span class="line">* 重启sshd服务  </span><br><span class="line">```bash</span><br><span class="line">[root@centos7 ~]<span class="comment">#systemctl restart sshd.service</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>centos7.5安装openshift3.11</title>
    <url>/2020/01/13/openshift%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="centos7-5安装openshift3-11"><a href="#centos7-5安装openshift3-11" class="headerlink" title="centos7.5安装openshift3.11"></a>centos7.5安装openshift3.11</h1><p>操作系统采用centos7.5，注意不要更换阿里元，安装会失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@openshift1 ~]# cat &#x2F;etc&#x2F;redhat-release </span><br><span class="line">CentOS Linux release 7.5.1804 (Core)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>主机</th>
<th>ip</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>openshift1</td>
<td>10.0.0.60</td>
<td>compute,infra,master</td>
</tr>
<tr>
<td>openshift2</td>
<td>10.0.0.63</td>
<td>compute,infra,master</td>
</tr>
<tr>
<td>openshift3</td>
<td>10.0.5.17</td>
<td>compute,infra,master</td>
</tr>
<tr>
<td>openshift4</td>
<td>10.0.5.8</td>
<td>compute,infra,master</td>
</tr>
</tbody></table>
<h2 id="下载离线包"><a href="#下载离线包" class="headerlink" title="下载离线包"></a>下载离线包</h2><h3 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br><span class="line">systemctl start docker; systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line">docker pull docker.io/openshift/origin-node:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-control-plane:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-deployer:v3.11.0</span><br><span class="line">docker pull docker.io/openshift/origin-haproxy-router:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-pod:v3.11.0</span><br><span class="line">docker pull docker.io/openshift/origin-web-console:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-docker-registry:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-metrics-server:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-console:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-metrics-heapster:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-metrics-hawkular-metrics:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-metrics-schema-installer:v3.11</span><br><span class="line">docker pull docker.io/openshift/origin-metrics-cassandra:v3.11</span><br><span class="line">docker pull docker.io/cockpit/kubernetes:latest</span><br><span class="line">docker pull quay.io/coreos/cluster-monitoring-operator:v0.1.1</span><br><span class="line">docker pull quay.io/coreos/prometheus-config-reloader:v0.23.2</span><br><span class="line">docker pull quay.io/coreos/prometheus-operator:v0.23.2</span><br><span class="line">docker pull docker.io/openshift/prometheus-alertmanager:v0.15.2</span><br><span class="line">docker pull docker.io/openshift/prometheus-node-exporter:v0.16.0</span><br><span class="line">docker pull docker.io/openshift/prometheus:v2.3.2</span><br><span class="line">docker pull docker.io/grafana/grafana:5.2.1</span><br><span class="line">docker pull quay.io/coreos/kube-rbac-proxy:v0.3.1</span><br><span class="line">docker pull quay.io/coreos/etcd:v3.2.22</span><br><span class="line">docker pull quay.io/coreos/kube-state-metrics:v1.3.1</span><br><span class="line">docker pull docker.io/openshift/oauth-proxy:v1.1.0</span><br><span class="line">docker pull quay.io/coreos/configmap-reload:v0.0.1</span><br></pre></td></tr></table></figure>
<p>之后将下载的镜像导出到新节点上，可以借助批量导出工具：<br><a href="https://github.com/laoshanxi/saveloadimg" target="_blank" rel="noopener">镜像批量导出工具</a>  </p>
<h2 id="在所有节点执行如下任务，本文以playbook的方式执行。"><a href="#在所有节点执行如下任务，本文以playbook的方式执行。" class="headerlink" title="在所有节点执行如下任务，本文以playbook的方式执行。"></a>在所有节点执行如下任务，本文以playbook的方式执行。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- name: Pre Install</span><br><span class="line">  hosts: nodes</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">  - name: <span class="built_in">set</span> selinux</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"sed  -i 's/SELINUX=disabled/SELINUX=permissive/g'  /etc/selinux/config"</span></span><br><span class="line">  </span><br><span class="line">  - name: install tools</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"yum install -y wget git net-tools bind-utils yum-utils iptables-services bridge-utils bash-completion kexec-tools sos psacct vim python-setuptools unzip tree atomic NetworkManager"</span></span><br><span class="line">  </span><br><span class="line">  - name: install repo</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"yum install -y centos-release-openshift-origin311 ceph-common container-selinux epel extras python-docker"</span></span><br><span class="line">  </span><br><span class="line">  - name: install origin</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"yum install -y origin-node-3.11.0 origin-clients-3.11.0 conntrack-tools origin-3.11.0"</span></span><br><span class="line"></span><br><span class="line">  - name: <span class="built_in">set</span> docker <span class="built_in">enable</span></span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"systemctl enable NetworkManager"</span></span><br><span class="line"></span><br><span class="line">  - name: <span class="built_in">disable</span> firewalld</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"systemctl stop firewalld"</span></span><br><span class="line"></span><br><span class="line">  - name: <span class="built_in">disable</span> firewalld</span><br><span class="line">    <span class="built_in">command</span>: <span class="string">"systemctl disable firewalld"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所有节点配置iptables</span></span><br><span class="line">cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak.$(date <span class="string">"+%Y%m%d%H%M%S"</span>);</span><br><span class="line">sed -i <span class="string">'/.*--dport 22 -j ACCEPT.*/a\-A INPUT -p tcp -m state --state NEW -m tcp --dport 53 -j ACCEPT'</span> /etc/sysconfig/iptables;</span><br><span class="line">sed -i <span class="string">'/.*--dport 22 -j ACCEPT.*/a\-A INPUT -p udp -m state --state NEW -m udp --dport 53 -j ACCEPT'</span> /etc/sysconfig/iptables;</span><br><span class="line">sed -i <span class="string">'/.*--dport 22 -j ACCEPT.*/a\-A INPUT -p tcp -m state --state NEW -m tcp --dport 5000 -j ACCEPT'</span> /etc/sysconfig/iptables;</span><br><span class="line">sed -i <span class="string">'/.*--dport 22 -j ACCEPT.*/a\-A INPUT -p tcp -m state --state NEW -m tcp --dport 81 -j ACCEPT'</span> /etc/sysconfig/iptables;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在master节点允许 8443 for node join</span></span><br><span class="line">sed -i <span class="string">'/.*--dport 22 -j ACCEPT.*/a\-A INPUT -p tcp -m state --state NEW -m tcp --dport 8443 -j ACCEPT '</span> /etc/sysconfig/iptables;</span><br><span class="line">sed -i <span class="string">'/.*--dport 22 -j ACCEPT.*/a\-A INPUT -p tcp -m state --state NEW -m tcp --dport 8443 -j ACCEPT '</span> /etc/sysconfig/iptables;</span><br><span class="line"></span><br><span class="line">systemctl restart iptables;systemctl <span class="built_in">enable</span> iptables</span><br></pre></td></tr></table></figure>

<h2 id="在ansible主机执行如下操作"><a href="#在ansible主机执行如下操作" class="headerlink" title="在ansible主机执行如下操作"></a>在ansible主机执行如下操作</h2><p>本文以openshift1作为安装主机</p>
<h3 id="配置ansible免密登录"><a href="#配置ansible免密登录" class="headerlink" title="配置ansible免密登录"></a>配置ansible免密登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f ~/.ssh/id_rsa -N <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> openshift1 openshift2 openshift3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="variable">$host</span></span><br><span class="line">     ssh-copy-id -i ~/.ssh/id_rsa.pub <span class="variable">$host</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="安装openshift-ansible"><a href="#安装openshift-ansible" class="headerlink" title="安装openshift-ansible"></a>安装openshift-ansible</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y ansible-2.6.14-1.el7</span><br><span class="line">yum install -y openshift-ansible</span><br></pre></td></tr></table></figure>
<h3 id="如果使用Open-VSwitch虚拟网络，hosts文件如下"><a href="#如果使用Open-VSwitch虚拟网络，hosts文件如下" class="headerlink" title="如果使用Open VSwitch虚拟网络，hosts文件如下"></a>如果使用Open VSwitch虚拟网络，hosts文件如下</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@openshift1 ~]<span class="comment"># cat /etc/ansible/hosts</span></span><br><span class="line"><span class="comment"># Create an OSEv3 group that contains the masters, nodes, and etcd groups</span></span><br><span class="line">[OSEv3:children]</span><br><span class="line">masters</span><br><span class="line">nodes</span><br><span class="line">etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set variables common for all OSEv3 hosts</span></span><br><span class="line">[OSEv3:vars]</span><br><span class="line"><span class="comment"># SSH user, this user should allow ssh based auth without requiring a password</span></span><br><span class="line">ansible_ssh_user=root</span><br><span class="line"><span class="comment">#openshift_deployment_type=openshift-enterprise</span></span><br><span class="line">openshift_deployment_type=origin</span><br><span class="line">openshift_release=<span class="string">"3.11"</span></span><br><span class="line">openshift_image_tag=v3.11</span><br><span class="line">openshift_pkg_version=-3.11.0</span><br><span class="line">openshift_use_openshift_sdn=<span class="literal">true</span></span><br><span class="line"><span class="comment"># If ansible_ssh_user is not root, ansible_become must be set to true</span></span><br><span class="line"><span class="comment">#ansible_become=true</span></span><br><span class="line"><span class="comment">#containerized=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># default selectors for router and registry services</span></span><br><span class="line"><span class="comment"># openshift_router_selector='node-role.kubernetes.io/infra=true'</span></span><br><span class="line"><span class="comment"># openshift_registry_selector='node-role.kubernetes.io/infra=true'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uncomment the following to enable htpasswd authentication; defaults to DenyAllPasswordIdentityProvider</span></span><br><span class="line">openshift_master_identity_providers=[&#123;<span class="string">'name'</span>: <span class="string">'htpasswd_auth'</span>, <span class="string">'login'</span>: <span class="string">'true'</span>, <span class="string">'challenge'</span>: <span class="string">'true'</span>, <span class="string">'kind'</span>: <span class="string">'HTPasswdPasswordIdentityProvider'</span>&#125;]</span><br><span class="line"><span class="comment">#openshift_master_default_subdomain=ai.com</span></span><br><span class="line">openshift_disable_check=memory_availability,disk_availability,docker_image_availability</span><br><span class="line"></span><br><span class="line">os_sdn_network_plugin_name=<span class="string">'redhat/openshift-ovs-networkpolicy'</span></span><br><span class="line"></span><br><span class="line">openshift_master_cluster_method=native</span><br><span class="line">openshift_master_cluster_hostname=openshift1</span><br><span class="line">openshift_master_cluster_public_hostname=openshift1</span><br><span class="line"><span class="comment"># false</span></span><br><span class="line">ansible_service_broker_install=<span class="literal">false</span></span><br><span class="line">openshift_enable_service_catalog=<span class="literal">false</span></span><br><span class="line">template_service_broker_install=<span class="literal">false</span></span><br><span class="line">openshift_logging_install_logging=<span class="literal">false</span></span><br><span class="line">enable_excluders=<span class="literal">false</span></span><br><span class="line"><span class="comment"># registry passwd</span></span><br><span class="line"><span class="comment">#oreg_url=10.1.236.77:5000/openshift3/ose-$&#123;component&#125;:$&#123;version&#125;</span></span><br><span class="line"><span class="comment">#oreg_url=10.1.236.77:5000/openshift/origin-$&#123;component&#125;:$&#123;version&#125;</span></span><br><span class="line"><span class="comment">#openshift_examples_modify_imagestreams=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker config</span></span><br><span class="line"><span class="comment">#openshift_docker_additional_registries=10.1.236.77:5000</span></span><br><span class="line"><span class="comment">#openshift_docker_insecure_registries=10.1.236.77:5000</span></span><br><span class="line"><span class="comment">#openshift_docker_blocked_registries</span></span><br><span class="line">openshift_docker_options=<span class="string">"--log-driver json-file --log-opt max-size=1M --log-opt max-file=3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># openshift_cluster_monitoring_operator_install=false</span></span><br><span class="line"><span class="comment"># openshift_metrics_install_metrics=true</span></span><br><span class="line"><span class="comment"># openshift_enable_unsupported_configurations=True</span></span><br><span class="line"><span class="comment">#openshift_logging_es_nodeselector='node-role.kubernetes.io/infra: "true"'</span></span><br><span class="line"><span class="comment">#openshift_logging_kibana_nodeselector='node-role.kubernetes.io/infra: "true"'</span></span><br><span class="line"><span class="comment"># host group for masters</span></span><br><span class="line"></span><br><span class="line">[masters]</span><br><span class="line">openshift1</span><br><span class="line">openshift2</span><br><span class="line">openshift3</span><br><span class="line">openshift4</span><br><span class="line"></span><br><span class="line"><span class="comment"># host group for etcd</span></span><br><span class="line">[etcd]</span><br><span class="line">openshift1</span><br><span class="line">openshift2</span><br><span class="line">openshift3</span><br><span class="line">openshift4</span><br><span class="line"></span><br><span class="line"><span class="comment"># host group for nodes, includes region info</span></span><br><span class="line">[nodes]</span><br><span class="line">openshift1 openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br><span class="line">openshift2 openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br><span class="line">openshift3 openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br><span class="line">openshift4  openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br></pre></td></tr></table></figure>
<h3 id="如果使用calico虚拟网络，配置文件如下："><a href="#如果使用calico虚拟网络，配置文件如下：" class="headerlink" title="如果使用calico虚拟网络，配置文件如下："></a>如果使用calico虚拟网络，配置文件如下：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@openshift1 ~]<span class="comment"># cat /etc/ansible/hosts    </span></span><br><span class="line"><span class="comment"># Create an OSEv3 group that contains the masters, nodes, and etcd groups</span></span><br><span class="line">[OSEv3:children]</span><br><span class="line">masters</span><br><span class="line">nodes</span><br><span class="line">etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set variables common for all OSEv3 hosts</span></span><br><span class="line">[OSEv3:vars]</span><br><span class="line"><span class="comment"># bellow 3 parameter for Calico</span></span><br><span class="line">os_sdn_network_plugin_name=cni</span><br><span class="line">openshift_use_calico=<span class="literal">true</span></span><br><span class="line">openshift_use_openshift_sdn=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH user, this user should allow ssh based auth without requiring a password</span></span><br><span class="line">ansible_ssh_user=root</span><br><span class="line"><span class="comment">#openshift_deployment_type=openshift-enterprise</span></span><br><span class="line">openshift_deployment_type=origin</span><br><span class="line">openshift_release=<span class="string">"3.11"</span></span><br><span class="line">openshift_image_tag=v3.11</span><br><span class="line">openshift_pkg_version=-3.11.0</span><br><span class="line"><span class="comment">#openshift_use_openshift_sdn=true</span></span><br><span class="line"><span class="comment"># If ansible_ssh_user is not root, ansible_become must be set to true</span></span><br><span class="line"><span class="comment">#ansible_become=true</span></span><br><span class="line"><span class="comment">#containerized=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># default selectors for router and registry services</span></span><br><span class="line"><span class="comment"># openshift_router_selector='node-role.kubernetes.io/infra=true'</span></span><br><span class="line"><span class="comment"># openshift_registry_selector='node-role.kubernetes.io/infra=true'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uncomment the following to enable htpasswd authentication; defaults to DenyAllPasswordIdentityProvider</span></span><br><span class="line">openshift_master_identity_providers=[&#123;<span class="string">'name'</span>: <span class="string">'htpasswd_auth'</span>, <span class="string">'login'</span>: <span class="string">'true'</span>, <span class="string">'challenge'</span>: <span class="string">'true'</span>, <span class="string">'kind'</span>: <span class="string">'HTPasswdPasswordIdentityProvider'</span>&#125;]</span><br><span class="line"><span class="comment">#openshift_master_default_subdomain=ai.com</span></span><br><span class="line">openshift_disable_check=memory_availability,disk_availability,docker_image_availability,docker_storage</span><br><span class="line"></span><br><span class="line"><span class="comment">#os_sdn_network_plugin_name='redhat/openshift-ovs-networkpolicy'</span></span><br><span class="line"></span><br><span class="line">openshift_master_cluster_method=native</span><br><span class="line">openshift_master_cluster_hostname=openshift1</span><br><span class="line">openshift_master_cluster_public_hostname=openshift1</span><br><span class="line"><span class="comment"># false</span></span><br><span class="line">ansible_service_broker_install=<span class="literal">false</span></span><br><span class="line">openshift_enable_service_catalog=<span class="literal">false</span></span><br><span class="line">template_service_broker_install=<span class="literal">false</span></span><br><span class="line">openshift_logging_install_logging=<span class="literal">false</span></span><br><span class="line">enable_excluders=<span class="literal">false</span></span><br><span class="line"><span class="comment"># registry passwd</span></span><br><span class="line"><span class="comment">#oreg_url=10.1.236.77:5000/openshift3/ose-$&#123;component&#125;:$&#123;version&#125;</span></span><br><span class="line"><span class="comment">#oreg_url=10.1.236.77:5000/openshift/origin-$&#123;component&#125;:$&#123;version&#125;</span></span><br><span class="line"><span class="comment">#openshift_examples_modify_imagestreams=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker config</span></span><br><span class="line"><span class="comment">#openshift_docker_additional_registries=10.1.236.77:5000</span></span><br><span class="line"><span class="comment">#openshift_docker_insecure_registries=10.1.236.77:5000</span></span><br><span class="line"><span class="comment">#openshift_docker_blocked_registries</span></span><br><span class="line">openshift_docker_options=<span class="string">"--log-driver json-file --log-opt max-size=1M --log-opt max-file=3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># openshift_cluster_monitoring_operator_install=false</span></span><br><span class="line"><span class="comment"># openshift_metrics_install_metrics=true</span></span><br><span class="line"><span class="comment"># openshift_enable_unsupported_configurations=True</span></span><br><span class="line"><span class="comment">#openshift_logging_es_nodeselector='node-role.kubernetes.io/infra: "true"'</span></span><br><span class="line"><span class="comment">#openshift_logging_kibana_nodeselector='node-role.kubernetes.io/infra: "true"'</span></span><br><span class="line"><span class="comment"># host group for masters</span></span><br><span class="line"></span><br><span class="line">[masters]</span><br><span class="line">openshift1</span><br><span class="line">openshift2</span><br><span class="line">openshift3</span><br><span class="line">openshift4</span><br><span class="line"></span><br><span class="line"><span class="comment"># host group for etcd</span></span><br><span class="line">[etcd]</span><br><span class="line">openshift1</span><br><span class="line">openshift2</span><br><span class="line">openshift3</span><br><span class="line">openshift4</span><br><span class="line"></span><br><span class="line"><span class="comment"># host group for nodes, includes region info</span></span><br><span class="line">[nodes]</span><br><span class="line">openshift1 openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br><span class="line">openshift2 openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br><span class="line">openshift3 openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br><span class="line">openshift2  openshift_node_group_name=<span class="string">'node-config-all-in-one'</span></span><br></pre></td></tr></table></figure>
<h3 id="配置DNS解析"><a href="#配置DNS解析" class="headerlink" title="配置DNS解析"></a>配置DNS解析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">    127.0.0.1 VM_0_60_centos VM_0_60_centos</span><br><span class="line">    127.0.0.1 localhost.localdomain localhost</span><br><span class="line">    127.0.0.1 localhost4.localdomain4 localhost4</span><br><span class="line">    </span><br><span class="line">    ::1 VM_0_60_centos VM_0_60_centos</span><br><span class="line">    ::1 localhost.localdomain localhost</span><br><span class="line">    ::1 localhost6.localdomain6 localhost6</span><br><span class="line">    </span><br><span class="line">    10.0.0.60 openshift1</span><br><span class="line">    10.0.0.63 openshift2</span><br><span class="line">    10.0.5.17 openshift3</span><br><span class="line">    10.0.5.8 openshift4</span><br><span class="line"></span><br><span class="line">ansible all -m copy -a <span class="string">"src=/etc/hosts dest=/etc/hosts "</span></span><br></pre></td></tr></table></figure>
<h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible all -a <span class="string">'systemctl start docker;systemctl enable docker'</span></span><br></pre></td></tr></table></figure>

<h3 id="执行检查"><a href="#执行检查" class="headerlink" title="执行检查"></a>执行检查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook /usr/share/ansible/openshift-ansible/playbooks/prerequisites.yml</span><br></pre></td></tr></table></figure>

<h3 id="执行安装"><a href="#执行安装" class="headerlink" title="执行安装"></a>执行安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook /usr/share/ansible/openshift-ansible/playbooks/deploy_cluster.yml -vvv</span><br></pre></td></tr></table></figure>

<h3 id="如果安装过程出错或者想要重新安装，需要先卸载"><a href="#如果安装过程出错或者想要重新安装，需要先卸载" class="headerlink" title="如果安装过程出错或者想要重新安装，需要先卸载"></a>如果安装过程出错或者想要重新安装，需要先卸载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook  /usr/share/ansible/openshift-ansible/playbooks/adhoc/uninstall.yml</span><br></pre></td></tr></table></figure>
<h3 id="配置后台登录用户"><a href="#配置后台登录用户" class="headerlink" title="配置后台登录用户"></a>配置后台登录用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htpasswd -cb /etc/origin/master/htpasswd admin abc123</span><br><span class="line">oc adm policy add-cluster-role-to-user cluster-admin admin</span><br></pre></td></tr></table></figure>
<p>之后修改hosts文件，在浏览器输入 <a href="https://openshift1:8443" target="_blank" rel="noopener">https://openshift1:8443</a> 即可访问okd页面，并使用okd311.</p>
<p>安装过程中的问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">遇到下面问题需要在对应node上安装atomic包，再次执行安装步骤：</span><br><span class="line">Message: The following packages have pending transactions: atomic-x86_64</span><br><span class="line">ansible 2.8 版本不支持openshift3.11，用ansible2.6.14成功安装。</span><br><span class="line">rpm -e --nodeps ansible-2.8.2-1.el7.noarch</span><br><span class="line">yum install ansible-2.6.14-1.el7</span><br></pre></td></tr></table></figure>

<p>本文参考链接：<br><a href="https://www.jianshu.com/p/cc012c93ad8c" target="_blank" rel="noopener">https://www.jianshu.com/p/cc012c93ad8c</a><br><a href="https://www.jianshu.com/p/47711a21ba49" target="_blank" rel="noopener">https://www.jianshu.com/p/47711a21ba49</a><br><a href="https://www.jianshu.com/p/de0d5b89e231" target="_blank" rel="noopener">https://www.jianshu.com/p/de0d5b89e231</a>  </p>
<p>官方文档：<br><a href="https://docs.okd.io/3.11/install/host_preparation.html" target="_blank" rel="noopener">https://docs.okd.io/3.11/install/host_preparation.html</a></p>
]]></content>
      <categories>
        <category>云原生技术</category>
      </categories>
      <tags>
        <tag>openshift</tag>
        <tag>okd311</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>devops</title>
    <url>/2018/11/20/jenkins/</url>
    <content><![CDATA[<h3 id="DevOps简介"><a href="#DevOps简介" class="headerlink" title="DevOps简介"></a>DevOps简介</h3><p>  DevOps 是Development和Operations的组合，也就是开发和运维的简写。<br>DevOps 是针对企业中的研发人员、运维人员和测试人员的工作理念，是他们在应用开发、代码部署和质量测试等整条生命周期中协作和沟通的最佳实践，DevOps 强调整个组织的合作以及交付和基础设施变更的自动化、从而实现持续集成、持续部署和持续交付。<br>DevOps 四大平台：代码托管(gitlab/svn)、项目管理(jira)、运维平台(腾讯蓝鲸/开源平台)、持续交付(Jenkins/gitlab)</p>
<p>持续集成(CI-Continuous integration)：持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起并切相互不影响工作。</p>
<p>持续部署(CD-continuous deployment)：是基于某种工具或平台实现代码自动化的构建、测试和部署到线上环境以实现交付高质量的产品,持续部署在某种程度上代表了一个开发团队的更新迭代速率。</p>
<p>持续交付(Continuous Delivery)：持续交付是在持续部署的基础之上，将产品交付到线上环境，因此持续交付是产品价值的一种交付，是产品价值的一种盈利的实现。</p>
<h3 id="Gitlab部署与使用"><a href="#Gitlab部署与使用" class="headerlink" title="Gitlab部署与使用"></a>Gitlab部署与使用</h3><p>github：开源代码托管网站。<br>gitlab：应用软件。<br>git：命令行客户端。</p>
<p>如果是最小化安装的系统，需要做如下初始化配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum install vim gcc gcc-c++ wget net-tools lrzsz iotop lsof iotop bash-completion -y</span></span><br><span class="line">~]<span class="comment"># yum install curl policycoreutils openssh-server openssh-clients postfix -y</span></span><br><span class="line">~]<span class="comment"># wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span></span><br><span class="line">~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line">~]<span class="comment"># sed -i '/SELINUX/s/enforcing/disabled/' /etc/sysconfig/selinux</span></span><br><span class="line">~]<span class="comment"># hostnamectl set-hostname gitlab.example.com</span></span><br><span class="line">~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>

<p>安装包下载：<a href="https://packages.gitlab.com/gitlab/gitlab-ce" target="_blank" rel="noopener">https://packages.gitlab.com/gitlab/gitlab-ce</a><br>rpm包国内下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/</a></p>
<p>安装gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum -y install gitlab-ce-11.6.5-ce.0.el7.x86_64.rpm</span></span><br></pre></td></tr></table></figure>

<p>配置gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@gitlab tools]<span class="comment"># grep "^[a-Z]" /etc/gitlab/gitlab.rb </span></span><br><span class="line"><span class="comment">#暴露url</span></span><br><span class="line">external_url <span class="string">'http://192.168.34.101'</span></span><br><span class="line"><span class="comment">#开启邮件通知功能</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_enable'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_address'</span>] = <span class="string">"smtp.163.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_port'</span>] = 25</span><br><span class="line">gitlab_rails[<span class="string">'smtp_user_name'</span>] = <span class="string">"miaoshengqin_tec@163.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_password'</span>] = <span class="string">"msq137226"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_domain'</span>] = <span class="string">"163.com"</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_authentication'</span>] = :login</span><br><span class="line">gitlab_rails[<span class="string">'smtp_enable_starttls_auto'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'smtp_tls'</span>] = <span class="literal">false</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_email_from'</span>] = <span class="string">"miaoshengqin_tec@163.com"</span></span><br><span class="line">user[<span class="string">"git_user_email"</span>] = <span class="string">"miaoshengqin_tec@163.com"</span></span><br></pre></td></tr></table></figure>

<p>初始化gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># gitlab-ctl  reconfigure #修改完配置文件要执行此操作</span></span><br><span class="line">~]<span class="comment"># gitlab-ctl  start</span></span><br><span class="line">~]<span class="comment">#     gitlab-ctl  stop</span></span><br><span class="line">~]<span class="comment"># gitlab-ctl  restar</span></span><br></pre></td></tr></table></figure>

<p>gitlab重设密码的机制：服务器向客户端发送临时token，session里面会包含token。</p>
<p>关闭注册功能：admin area –&gt; settings –&gt; general –&gt; Sign-up restrictions</p>
<h4 id="git常用命令及web环境准备"><a href="#git常用命令及web环境准备" class="headerlink" title="git常用命令及web环境准备"></a>git常用命令及web环境准备</h4><p><strong>git常用命令</strong>：<br>下载项目：git clone URL<br>将项目放入本地仓库： git add name<br>将项目推送到远程仓库：git commit -m “TAG”</p>
<pre><code>git config --global user.name “name“ #设置全局用户名 
git config --global user.email xxx@xx.com #设置全局邮箱
git config --global –list #列出用户全局设置
git add index.html / . #添加指定文件、目录或当前目录下所有数据到暂存区
git commit -m “11“ #提交文件到工作区
git status #查看工作区的状态
git push #提交代码到服务器
git pull #获取代码到本地，更新。
git log #查看操作日志
vim .gitignore #定义忽略文件
git reset --hard HEAD^^ #git版本回滚， HEAD为当前版本，加一个^为上一个，^^为上上一个版本
git reflog # #获取每次提交的ID，可以使用--hard根据提交的ID进行版本回退
git reset --hard 5ae4b06 #回退到指定id的版本
# git branch #查看当前所处的分支
#git checkout  -b develop #创建并切换到一个新分支
#git checkout   develop #切换分支</code></pre><p><strong>准备web环境</strong></p>
<h2 id="Jenkins安装使用"><a href="#Jenkins安装使用" class="headerlink" title="Jenkins安装使用"></a>Jenkins安装使用</h2><p>安装Jenkins需要先准备jdk环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@jenkins:/usr/<span class="built_in">local</span>/src<span class="comment"># tar xvf jdk-8u181-linux-x64.tar.gz</span></span><br><span class="line">root@jenkins:/usr/<span class="built_in">local</span>/src<span class="comment"># ln -sv /usr/local/src/jdk1.8.0_181/ /usr/local/jdk</span></span><br><span class="line"></span><br><span class="line">root@jenkins:/usr/<span class="built_in">local</span>/src<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JAVA_HOME</span>/jre/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.<span class="variable">$CLASSPATH</span>:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JAVA_HOME</span>/jre/lib:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line">root@jenkins:/usr/<span class="built_in">local</span>/src<span class="comment"># source  /etc/profile</span></span><br><span class="line">root@jenkins:/usr/<span class="built_in">local</span>/src<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_181"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure>

<p>启动Jenkins：<br><strong>通过jar包直接启动Jenkins</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> java \</span><br><span class="line">-Dcom.sun.management.jmxremote \</span><br><span class="line">-Dcom.sun.management.jmxremote.port=12345 \</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> \</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> \</span><br><span class="line">-Djava.rmi.server.hostname=<span class="string">"172.20.101.136	"</span> \</span><br><span class="line">-jar jenkins-2.138.4-1.1.noarch.war &amp;</span><br></pre></td></tr></table></figure>

<p><strong>rpm包安装Jenkins</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@s1 ~]<span class="comment"># grep -v "#" /etc/sysconfig/jenkins  | grep -v "^$"</span></span><br><span class="line">JENKINS_HOME=<span class="string">"/var/lib/jenkins"</span></span><br><span class="line">JENKINS_JAVA_CMD=<span class="string">""</span></span><br><span class="line">JENKINS_USER=<span class="string">"jenkins"</span></span><br><span class="line">JENKINS_JAVA_OPTIONS=<span class="string">"-Djava.awt.headless=true \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.port=12345 \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.authenticate=false \</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.ssl=false \</span></span><br><span class="line"><span class="string">-Djava.rmi.server.hostname="</span>172.20.101.136<span class="string">" \</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">JENKINS_PORT=<span class="string">"8080"</span></span><br><span class="line">JENKINS_LISTEN_ADDRESS=<span class="string">""</span></span><br><span class="line">JENKINS_HTTPS_PORT=<span class="string">""</span></span><br><span class="line">JENKINS_HTTPS_KEYSTORE=<span class="string">""</span></span><br><span class="line">JENKINS_HTTPS_KEYSTORE_PASSWORD=<span class="string">""</span></span><br><span class="line">JENKINS_HTTPS_LISTEN_ADDRESS=<span class="string">""</span></span><br><span class="line">JENKINS_DEBUG_LEVEL=<span class="string">"5"</span></span><br><span class="line">JENKINS_ENABLE_ACCESS_LOG=<span class="string">"no"</span></span><br><span class="line">JENKINS_HANDLER_MAX=<span class="string">"100"</span></span><br><span class="line">JENKINS_HANDLER_IDLE=<span class="string">"20"</span></span><br><span class="line">JENKINS_ARGS=<span class="string">""</span></span><br></pre></td></tr></table></figure>
<p><strong>安装插件：</strong>jenkins–&gt;插件管理–&gt;可选插件，搜索gitlab和Blue Ocean</p>
<p><strong>配置Jenkins权限管理：</strong><br>基于角色的权限管理，先创建角色和用户，给角色授权，然后把用户关联到角色，需安装Role-based Authorization Strategy。<br>创建新的用户：jenkins–&gt;系统管理–&gt;管理用户–&gt;新建用户<br>更改认证方式：jenkins–&gt;系统管理–&gt;全局安全配置；默认创建的用户登陆后可以做任何操作，取决于默认的认证授权方式。</p>
<p><strong>Jenkins邮箱设置</strong></p>
<ul>
<li>生成邮箱登录授权码</li>
<li>配置Jenkins管理员邮箱<blockquote>
<p>jenkins–&gt;系统管理–&gt;系统设置</p>
</blockquote>
</li>
</ul>
<h3 id="基于ssh-key拉取代码"><a href="#基于ssh-key拉取代码" class="headerlink" title="基于ssh key拉取代码"></a>基于ssh key拉取代码</h3><p>在centos上使用ssh-keygen生成key，将公钥放在gitlab上：点登录用户下拉箭头–&gt;settings–&gt;ssh keys。在本机测试成功后即可。<br>然后配置Jenkins自动拉取代码：jekins–&gt;凭据–&gt;jenkins–&gt;全局凭据–&gt;添加凭据。将对应于gitlab上公钥的私钥防止在Jenkins上。</p>
<h3 id="pipline"><a href="#pipline" class="headerlink" title="pipline"></a>pipline</h3><p>pipline是帮助Jenkins实现CI到CD转变的重要角色，是运行在jenkins 2.X版本的核心插件，简单来说Pipline就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂发布流程，从而实现单个任务很难实现的复杂流程编排和任务可视化，Pipeline的实现方式是一套Groovy DSL，任何发布流程都可以表述为一段Groovy脚本。<br>pipline的优势</p>
<ul>
<li>可持续性：jenkins的重启或者中断后不影响已经执行的Pipline Job</li>
<li>支持暂停：pipline可以选择停止并等待人工输入或批准后再继续执行。</li>
<li>可扩展：通过groovy的编程更容易的扩展插件。</li>
<li>并行执行：通过groovy脚本可以实现step，stage间的并行执行，和更复杂的相互依赖关系。</li>
</ul>
<p>pipline语法：</p>
<ul>
<li>Stage：阶段，一个pipline可以划分为若干个stage，每个stage都是一个操作，比如clone代码、代码编译、代码测试和代码部署，阶段是一个逻辑分组，可以跨多个node执行。</li>
<li>Node：节点，每个node都是一个jenkins节点，可以是jenkins master也可以是jenkins  agent，node是执行step的具体服务器。</li>
<li>Step：步骤，step是jenkins pipline最基本的操作单元，从在服务器创建目录到构建容器镜像，由各类<br>Jenkins 插件提供实现，例如： sh “make”</li>
</ul>
<p><strong>pipline使用示例</strong><br>使用Jenkins的pipline一键更新代码脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node(<span class="string">"slave-node01"</span>)&#123;</span><br><span class="line">   stage(<span class="string">"code clone"</span>)&#123;</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"git clone"</span></span><br><span class="line">       sh <span class="string">"rm -rf /data/jenkins/slave/workspace/pipline-test/*"</span></span><br><span class="line">      git credentialsId: <span class="string">'5f3240fc-dd35-4e89-90e5-d1091577d671'</span>, url: <span class="string">'git@172.20.101.98:group1/project1.git'</span></span><br><span class="line">       sh <span class="string">"cd /data/jenkins/slave/workspace/pipline-test &amp;&amp; zip -r code.zip ./*"</span></span><br><span class="line">   &#125;</span><br><span class="line">  stage(<span class="string">"code build"</span>)&#123;</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"code copy"</span></span><br><span class="line">      sh <span class="string">"cd /data/jenkins/slave/workspace/pipline-test &amp;&amp; scp code.zip node01:/apps/tomcat/webapps/ROOT/code.zip &amp;&amp; ssh node01 'chown tomcat.tomcat /apps/tomcat/webapps/ROOT/code.zip'"</span></span><br><span class="line">      sh <span class="string">"cd /data/jenkins/slave/workspace/pipline-test &amp;&amp; scp code.zip node02:/apps/tomcat/webapps/ROOT/code.zip &amp;&amp; ssh node02 'chown tomcat.tomcat /apps/tomcat/webapps/ROOT/code.zip'"</span></span><br><span class="line">  &#125;</span><br><span class="line">  stage(<span class="string">"stop service"</span>)&#123;</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"stop service"</span></span><br><span class="line">      sh <span class="string">"ssh node01 'pkill java &amp;&amp; unzip /apps/tomcat/webapps/ROOT/code.zip -d /apps/tomcat/webapps/ROOT'"</span></span><br><span class="line">      sh <span class="string">"ssh node02 'pkill java &amp;&amp; unzip /apps/tomcat/webapps/ROOT/code.zip -d /apps/tomcat/webapps/ROOT'"</span></span><br><span class="line">  &#125;</span><br><span class="line">  stage(<span class="string">"start service"</span>)&#123;</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"satrt service"</span></span><br><span class="line">      sh <span class="string">"ssh node01 '/apps/tomcat/bin/catalina.sh start'"</span></span><br><span class="line">      sh <span class="string">"ssh node02 '/apps/tomcat/bin/catalina.sh start'"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>自动化部署tomcat脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># #########################################################</span></span><br><span class="line"><span class="comment"># Tomcat init script for     铁大电信####</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment"># chkconfig: 2345 96 14 ###################################</span></span><br><span class="line"><span class="comment"># description: 2016/11/1.  苗圣钦##########################</span></span><br><span class="line"><span class="comment"># #########################################################</span></span><br><span class="line"></span><br><span class="line">JDK_HOME=/apps/jdk1.7.0_79</span><br><span class="line">CATALINA_HOME=/apps/tomcat</span><br><span class="line"><span class="built_in">export</span> JDK_HOME CATALINA_HOME</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment">#PID=`ps -ef  | grep  -v grep  | grep java | awk  '&#123;print $2&#125;'`</span></span><br><span class="line"><span class="comment">#NUM=`ps -ef  | grep  -v grep  | grep java | awk  '&#123;print $2&#125;' | wc -l`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#case $1 in</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"正在判断服务状态，请稍等！"</span>  </span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"请稍等3秒钟"</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"3"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"2"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"1"</span>;sleep 1</span><br><span class="line">    <span class="keyword">if</span>  netstat -an | grep 8080 | grep LISTEN &gt;/dev/null</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"Tomcat已经正在运行了！"</span>  </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"Tomcat没有运行，1秒后启动！"</span></span><br><span class="line">    <span class="built_in">echo</span> 1;sleep 1  </span><br><span class="line">      <span class="variable">$CATALINA_HOME</span>/bin/catalina.sh start </span><br><span class="line">      <span class="built_in">echo</span>  <span class="string">"Tomcat 已经成功启动完成,5秒后判断是否启动成功"</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"5"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"4"</span>;sleep 1</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"3"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"2"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"1"</span>;sleep 1</span><br><span class="line">  <span class="keyword">if</span>  netstat -an | grep 8080 | grep LISTEN &gt;/dev/null</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">    PID=`ps -ef | grep  tomcat | grep jdk | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">    NUM=`ps -ef | grep  tomcat | grep jdk | awk <span class="string">'&#123;print $2&#125;'</span> | wc -l`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Tomcat 已经成功启动<span class="variable">$&#123;NUM&#125;</span> 个Tomcat进程!,PID为<span class="variable">$&#123;PID&#125;</span>"</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Tomcat启动失败，请重新启动！"</span></span><br><span class="line">          <span class="built_in">echo</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;</span><br><span class="line">    PID=`ps -ef  | grep  -v grep  | grep java | awk  <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">    NUM=`ps -ef | grep  -v <span class="string">"color"</span>  | grep tomcat | awk <span class="string">'&#123;print $2&#125;'</span> | wc -l`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"正在判断服务状态，请稍等3秒钟！"</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"3"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"2"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"1"</span>;sleep 1</span><br><span class="line">  <span class="keyword">if</span>  netstat -an | grep 8080 | grep LISTEN &gt;/dev/null </span><br><span class="line">     <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Tomcat运行中，1秒后关闭！"</span></span><br><span class="line">    <span class="built_in">echo</span>  1;sleep 1 </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"即将关闭Tomcat服务，请稍等！"</span> </span><br><span class="line">        <span class="variable">$CATALINA_HOME</span>/bin/catalina.sh stop ;<span class="built_in">echo</span> <span class="string">"已经执行关闭命令,正在检查关闭了多少Tomcat进程，请稍等30秒钟！"</span></span><br><span class="line">    sleep 27</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"3"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"2"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"1"</span>;sleep 1</span><br><span class="line">    pkill java &amp;&amp; pkill tomcat</span><br><span class="line">    <span class="keyword">if</span>  netstat -an | grep 8080 | grep LISTEN &gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">      PID=`ps -ef  | grep  -v grep  | grep java | awk  <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">      NUM=`ps -ef | grep  -v <span class="string">"color"</span>  | grep tomcat | awk <span class="string">'&#123;print $2&#125;'</span> | wc -l`</span><br><span class="line">      <span class="built_in">kill</span> -9 <span class="variable">$PID</span> ;<span class="built_in">echo</span> <span class="string">"已成功关闭<span class="variable">$&#123;NUM&#125;</span> 个tomcat进程"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span>  <span class="string">"Tomcat 已经关闭完成！"</span> </span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"3"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"2"</span>;sleep 1;<span class="built_in">echo</span> <span class="string">"1"</span>;sleep 1 </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Tomcat 没有运行"</span></span><br><span class="line">    <span class="built_in">echo</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span>  netstat -an | grep 8080 | grep LISTEN &gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">            PID=`ps -ef  | grep  -v grep  | grep java | awk  <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">            <span class="comment">#NUM=`ps -ef | grep  -v "color"  | grep tomcat | awk '&#123;print $2&#125;' | wc -l`</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"关闭失败，即将强制删除tomcat进程!"</span></span><br><span class="line">            sleep 2</span><br><span class="line">            pkill tomcat ;sleep 2 </span><br><span class="line">            <span class="keyword">if</span>  netstat -an | grep 8080 | grep LISTEN &gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"强制关闭失败，即将再次强制删除tomcat进程!"</span></span><br><span class="line">                pkill java; sleep 2</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="title">restart</span></span>() &#123;</span><br><span class="line">  stop </span><br><span class="line">  start </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span> </span><br><span class="line">start) </span><br><span class="line">start </span><br><span class="line">;; </span><br><span class="line"></span><br><span class="line">stop) </span><br><span class="line">stop </span><br><span class="line">;; </span><br><span class="line"></span><br><span class="line">restart) </span><br><span class="line">restart </span><br><span class="line">;; </span><br><span class="line"></span><br><span class="line">*) </span><br><span class="line"><span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|restart|status&#125;"</span> </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h3 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h3><p>SonarQube  是一个用于代码质量管理的开放平台，通过插件机制，SonarQube 可以集成不同的测试工具，代码分析工具，以及持续集成工具。与持续集成工具（例如Hudson/Jenkins 等）不同，SonarQube并不是简单地把不同的代码检查工具结果（例如FindBugs，PMD等）直接显示在Web页面上，而是通过不同的插件对这些结果进行再 加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。在对其他工具的支持方面，Sonar 不仅提供了对 IDE 的支持，可以在 Eclipse 和 IntelliJ IDEA 这些工具里联机查看结果；同时Sonar还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用SonarQube,此外，SonarQube的插件还可以对 Java 以外的其他编程语言提供支持，对国际化以及报告文档化也有良好的支持。</p>
<p><strong>安装数据库</strong><br>数据库要使用5.6版本，不支持5.5的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum install vim gcc gcc-c++ wget autoconf  net-tools lrzsz iotop lsof iotop bash-completion curl policycoreutils openssh-server openssh-clients postfix -y</span></span><br><span class="line">~]<span class="comment"># cd  mysql-5.6.42-linux-glibc2.12-x86_64</span></span><br><span class="line">~]<span class="comment"># ln -sv /usr/local/src/mysql-5.6.42-linux-glibc2.12-x86_64 /usr/local/mysql</span></span><br><span class="line">~]<span class="comment"># useradd  mysql -s /sbin/nologin </span></span><br><span class="line">~]<span class="comment"># chown  mysql.mysql /usr/local/mysql/ -R</span></span><br><span class="line">~]<span class="comment"># /usr/local/mysql/scripts/mysql_install_db  --user=mysql --datadir=/data/mysql --basedir=/usr/local/mysql/</span></span><br><span class="line">~]<span class="comment"># cp  /usr/local/src/mysql-5.6.42-linux-glibc2.12-x86_64/support-files/mysql.server /etc/init.d/mysqld</span></span><br><span class="line">~]<span class="comment"># cp my.cnf  /etc/my.cnf</span></span><br><span class="line">~]<span class="comment"># chmod  a+x  /etc/init.d/mysqld </span></span><br><span class="line">~]<span class="comment"># /etc/init.d/mysqld  start</span></span><br><span class="line">~]<span class="comment"># ln -sv /usr/local/mysql/bin/* /usr/bin/</span></span><br><span class="line">~]<span class="comment"># mkdir /var/lib/mysql</span></span><br><span class="line">~]<span class="comment"># ln -sv /data/mysql/mysql.sock  /var/lib/mysql/</span></span><br></pre></td></tr></table></figure>

<p>安装sonarqube<br>下载安装包，安装并修改配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-9 sonarqube]<span class="comment"># grep "^[a-Z]" /usr/local/src/sonarqube/conf/sonar.properties </span></span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=<span class="literal">true</span>&amp;useConfigs=maxPerformance&amp;useSSL=<span class="literal">false</span></span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line">sonar.web.host=0.0.0.0</span><br><span class="line">sonar.web.port=9000</span><br></pre></td></tr></table></figure>

<h4 id="部署扫描器-sonar-scanner"><a href="#部署扫描器-sonar-scanner" class="headerlink" title="部署扫描器 sonar-scanner"></a>部署扫描器 sonar-scanner</h4><p>sonarqube通过调用扫描器sonar-scanner进行代码质量分析，即扫描器的具体工作就是扫描代码：<br>下载地址：<a href="http://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner" target="_blank" rel="noopener">http://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unzip sonar-scanner-2.6.1.zip</span></span><br><span class="line"><span class="comment"># ln -sv /usr/local/src/sonar-scanner-2.6.1 /usr/local/sonar-scanner</span></span><br><span class="line"><span class="comment"># cd /usr/local/sonar-scanner/</span></span><br><span class="line"><span class="comment"># grep "^[a-Z]" conf/sonar-scanner.properties</span></span><br><span class="line">sonar.host.url=http://localhost:8800</span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br></pre></td></tr></table></figure>

<p>部署好之后，只需在代码所在目录下执行sonar-scanner命令即可进行扫描。</p>
<h4 id="将sonarqube关联到Jenkins"><a href="#将sonarqube关联到Jenkins" class="headerlink" title="将sonarqube关联到Jenkins"></a>将sonarqube关联到Jenkins</h4><p>首先安装插件，在Jenkins插件安装界面安装sonar插件SonarQubePlugin，其次配置Sonarqube server，系统管理–&gt;系统设置，里面配置sonarqube servers：</p>
<ul>
<li>name：给sonarqube起个名字</li>
<li>Server URL：sonarqube的地址</li>
</ul>
<h4 id="让Jenkins-关联到sonarqube-scanner"><a href="#让Jenkins-关联到sonarqube-scanner" class="headerlink" title="让Jenkins 关联到sonarqube scanner"></a>让Jenkins 关联到sonarqube scanner</h4><p>添加扫描器：系统管理–&gt;全局工具配置，里面有个sonarqube scanner</p>
<ul>
<li>Name：给scanner起个名字</li>
<li>然后点击自动安装或者协商sonarqube scanner命令的位置即可。</li>
</ul>
<h4 id="配置扫描"><a href="#配置扫描" class="headerlink" title="配置扫描"></a>配置扫描</h4><p>选择自己的项目(demo)–&gt;配置–&gt;execute sonarqube scanner，将配置文件的内容修改成如下格式填写完成后保存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sonar.projectKey=YOUR-KEY</span><br><span class="line">sonar.projectName=YOUR-NAME</span><br><span class="line">sonar.projectVersion=YOUR-VERSION</span><br><span class="line">sonar.sources=你的成文件所在的目录名</span><br><span class="line">sonae.sourceEncoding=你程序的编码(UTF-8)</span><br></pre></td></tr></table></figure>
<p>配置完成后点击构建。构建完成后再构建历史查看时，右上角会有个图标，点击即可前往sonarqube server上查看代码质量监测的结果。</p>
<p>构建的时候还可以执行自己设定的脚本，自定义进行扫描：</p>
<p>代码自动部署流程：<br>clone代码–&gt;代码扫描–&gt;tar/zip–&gt;从负载均衡摘除后端web服务器–&gt;停止web服务–&gt;同步代码–&gt;启动web服务–&gt;访问测试–&gt;从负载均衡上线服务器</p>
]]></content>
      <tags>
        <tag>devops</tag>
        <tag>jenkins</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>LNMP+WordPress</title>
    <url>/2018/10/20/lnmp/</url>
    <content><![CDATA[<h2 id="LNMP-WordPress架构实现"><a href="#LNMP-WordPress架构实现" class="headerlink" title="LNMP+WordPress架构实现"></a>LNMP+WordPress架构实现</h2><p>本实验创建lnmp架构，数据库采用一主两从的结构跑在docker容器内，实现主从复制，用proxysql实现读写分离；WordPress站点采用Nginx+php的结构实现高可用(10.10.10.25,10.10.10.6),wordeprss中用户上传的图片使用nfs共享存储并实现nfs高可用，两台nfs服务器之间采用inotify+rsync实现实时同步；整个集群的前端采用nginx做代理服务器接受用户请求。</p>
<h3 id="搭建数据库主从复制和读写分离"><a href="#搭建数据库主从复制和读写分离" class="headerlink" title="搭建数据库主从复制和读写分离"></a>搭建数据库主从复制和读写分离</h3><p>本次实验在10.10.10.8上采用docker容器的方式实现mysql主从,在宿主机上安装proxysql实现读写分离。</p>
<h4 id="在容器中运行三个mysql的容器，并实现主从复制"><a href="#在容器中运行三个mysql的容器，并实现主从复制" class="headerlink" title="在容器中运行三个mysql的容器，并实现主从复制"></a>在容器中运行三个mysql的容器，并实现主从复制</h4><p>下载镜像并运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker image pull mysql:5.7</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker run --name db1 -d --network bridge -h db1 -v /vols/db1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=centos mysql:5.7</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker run --name db2 -d --network bridge -h db2 -v /vols/db2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=centos mysql:5.7</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker run --name db3 -d --network bridge -h db3 -v /vols/db3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=centos mysql:5.7</span></span><br></pre></td></tr></table></figure>
<p>修改容器的配置文件，并实现db1做主库，db2,db3做从库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker exec -it db1 bash</span></span><br><span class="line">root@6b1fb7a017b4:/<span class="comment"># cat /etc/mysql/mysql.conf.d/mysqld.cnf </span></span><br><span class="line">[mysqld]</span><br><span class="line">server_id=1 <span class="comment">#指定server_id</span></span><br><span class="line">log_bin <span class="comment">#开启二进制日志</span></span><br><span class="line">pid-file	= /var/run/mysqld/mysqld.pid</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir		= /var/lib/mysql</span><br><span class="line"><span class="comment">#log-error	= /var/log/mysql/error.log</span></span><br><span class="line"><span class="comment"># By default we only accept connections from localhost</span></span><br><span class="line"><span class="built_in">bind</span>-address	= 172.17.0.2</span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line">root@6b1fb7a017b4:/<span class="comment"># mysql -puroot -pcentos</span></span><br><span class="line">mysql&gt; grant replication slave on *.* to <span class="string">'repluser'</span>@<span class="string">'10.10.10.%'</span> identified by <span class="string">'centos'</span>;</span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker exec -it db2 bash</span></span><br><span class="line">root@cc12db5e3e58:/<span class="comment"># cat /etc/mysql/mysql.conf.d/mysqld.cnf </span></span><br><span class="line">[mysqld]</span><br><span class="line">server_id=2 <span class="comment">#指定server_id</span></span><br><span class="line"><span class="built_in">read</span>-only <span class="comment">#只读，为实现读写分离必须在从服务器配置只读属性</span></span><br><span class="line">pid-file	= /var/run/mysqld/mysqld.pid</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir		= /var/lib/mysql</span><br><span class="line"><span class="comment">#log-error	= /var/log/mysql/error.log</span></span><br><span class="line"><span class="comment"># By default we only accept connections from localhost</span></span><br><span class="line"><span class="built_in">bind</span>-address	= 172.17.0.3</span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line">root@cc12db5e3e58:/<span class="comment">#mysql -uroot -pcentos</span></span><br><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">  MASTER_HOST=<span class="string">'172.17.0.2'</span>,</span><br><span class="line">  MASTER_USER=<span class="string">'repluser'</span>,</span><br><span class="line">  MASTER_PASSWORD=<span class="string">'centos'</span>,</span><br><span class="line">  MASTER_PORT=3306,</span><br><span class="line">  MASTER_LOG_FILE=<span class="string">'host-10-10-10-6-bin.000001'</span>, <span class="comment">#指定主库的日志</span></span><br><span class="line">  MASTER_LOG_POS=120, <span class="comment">#指定主库的节点</span></span><br><span class="line">  MASTER_CONNECT_RETRY=10;</span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker exec -it db3 bash</span></span><br><span class="line">root@cc12db5e3e58:/<span class="comment"># cat /etc/mysql/mysql.conf.d/mysqld.cnf </span></span><br><span class="line">[mysqld]</span><br><span class="line">server_id=3 <span class="comment">#指定server_id</span></span><br><span class="line"><span class="built_in">read</span>-only <span class="comment">#只读，为实现读写分离必须在从服务器配置只读属性</span></span><br><span class="line">pid-file	= /var/run/mysqld/mysqld.pid</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir		= /var/lib/mysql</span><br><span class="line"><span class="comment">#log-error	= /var/log/mysql/error.log</span></span><br><span class="line"><span class="comment"># By default we only accept connections from localhost</span></span><br><span class="line"><span class="built_in">bind</span>-address	= 172.17.0.3</span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line">root@cc12db5e3e58:/<span class="comment">#mysql -uroot -pcentos</span></span><br><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">  MASTER_HOST=<span class="string">'172.17.0.2'</span>,</span><br><span class="line">  MASTER_USER=<span class="string">'repluser'</span>,</span><br><span class="line">  MASTER_PASSWORD=<span class="string">'centos'</span>,</span><br><span class="line">  MASTER_PORT=3306,</span><br><span class="line">  MASTER_LOG_FILE=<span class="string">'host-10-10-10-6-bin.000001'</span>, <span class="comment">#指定主库的日志</span></span><br><span class="line">  MASTER_LOG_POS=120, <span class="comment">#指定主库的节点</span></span><br><span class="line">  MASTER_CONNECT_RETRY=10;</span><br><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure>

<h4 id="在宿主机上安装proxysql，并实现读写分离"><a href="#在宿主机上安装proxysql，并实现读写分离" class="headerlink" title="在宿主机上安装proxysql，并实现读写分离"></a>在宿主机上安装proxysql，并实现读写分离</h4><p>安装启动proxysql，并在proxysql上添加所有的数据库节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 ~]<span class="comment">#cat &lt;&lt;EOF | tee /etc/yum.repos.d/proxysql.repo</span></span><br><span class="line">[proxysql_repo]</span><br><span class="line">name= ProxySQL YUM repository</span><br><span class="line">baseurl=http://repo.proxysql.com/ProxySQL/proxysql-1.4.x/centos/\<span class="variable">$releasever</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://repo.proxysql.com/ProxySQL/repo_pub_key</span><br><span class="line">EOF</span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#systemctl start proxysql</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#mysql -uadmin -padmin -P6032 -h127.0.0.1</span></span><br><span class="line">MySQL &gt; insert into mysql_servers(hostgroup_id,hostname,port)</span><br><span class="line">values(10,<span class="string">'172.17.0.2'</span>,3306);</span><br><span class="line">MySQL &gt; insert into mysql_servers(hostgroup_id,hostname,port)</span><br><span class="line">values(10,<span class="string">'172.17.0.3'</span>,3306);</span><br><span class="line">MySQL &gt; insert into mysql_servers(hostgroup_id,hostname,port)</span><br><span class="line">values(10,<span class="string">'172.17.0.4'</span>,3306);</span><br><span class="line">MySQL &gt; load mysql servers to runtime;</span><br><span class="line">MySQL &gt; save mysql servers to disk;</span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#</span></span><br><span class="line">[root@10-10-10-8 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>在master上添加监控用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 ~]<span class="comment">#docker exec -it db1 bash</span></span><br><span class="line">root@6b1fb7a017b4:/<span class="comment"># mysql -puroot -pcentos</span></span><br><span class="line">MySQL &gt; grant replication client on *.* to monitor@<span class="string">'172.17.0.%'</span> identified by <span class="string">'centos'</span>;</span><br></pre></td></tr></table></figure>
<p>在proxysql上配置监控用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 ~]<span class="comment">#mysql -uadmin -padmin -P6032 -h127.0.0.1</span></span><br><span class="line">MySQL [(none)]&gt; <span class="built_in">set</span> mysql-monitor_username=<span class="string">'monitor'</span>;</span><br><span class="line">MySQL [(none)]&gt; <span class="built_in">set</span> mysql-monitor_password=<span class="string">'centos'</span>;</span><br><span class="line">MySQL [(none)]&gt; load mysql variables to runtime;</span><br><span class="line">MySQL [(none)]&gt; save mysql variables to disk;</span><br></pre></td></tr></table></figure>
<p>在proxysql上设置分组信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql &gt; insert into mysql_replication_hostgroups values(10,20,<span class="string">"test"</span>);</span><br><span class="line">mysql &gt; load mysql servers to runtime;</span><br><span class="line">mysql &gt; save mysql servers to disk;</span><br></pre></td></tr></table></figure>
<p>在master节点上创建WordPress用的数据库和管理员用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database wpdb;</span><br><span class="line">mysql&gt; grant all on wpdb.* to <span class="string">'wpuesr'</span>@<span class="string">'10.10.10.%'</span> identified by <span class="string">'centos'</span>;</span><br></pre></td></tr></table></figure>
<p>在proxysql上配置，将用户sqluser添加到mysql_users表中， default_hostgroup默认组设置为写组10，当读写分离的路由规则不符合时，会访问默认组的数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql &gt; insert into mysql_users(username,password,default_hostgroup) values(<span class="string">'wpuser'</span>,<span class="string">'centos'</span>,10);</span><br><span class="line">mysql &gt; load mysql users to runtime;</span><br><span class="line">mysql &gt; save mysql users to disk;</span><br></pre></td></tr></table></figure>
<p>在proxysql上配置路由规则，将select语句分离到20的读组，select语句中有一个特殊语句SELECT…FOR UPDATE它会申请写锁，应路由到10的写组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql &gt; insert into mysql_query_rules</span><br><span class="line">&gt; (rule_id,active,match_digest,destination_hostgroup,apply)VALUES</span><br><span class="line">&gt; (1,1,<span class="string">'^SELECT.*FOR UPDATE$'</span>,10,1),(2,1,<span class="string">'^SELECT'</span>,20,1);</span><br><span class="line">mysql &gt;load mysql query rules to runtime;</span><br><span class="line">mysql &gt;save mysql query rules to disk;</span><br></pre></td></tr></table></figure>

<h3 id="搭建web服务器"><a href="#搭建web服务器" class="headerlink" title="搭建web服务器"></a>搭建web服务器</h3><p>搭建两套Nginx+php服务器，并将用户上传的图片等静态资源通过nfs服务实现共享存储，nfs服务器也搭建两台，并通过inotify+rsync实现实时备份。</p>
<h4 id="搭建nginx-php"><a href="#搭建nginx-php" class="headerlink" title="搭建nginx+php"></a>搭建nginx+php</h4><p>本实验的web服务器有两台，以实现高可用，由于连哪个台服务器的配置并无差异，故只演示其中一台的安装配置步骤。</p>
<h5 id="编译安装php-7-2-14"><a href="#编译安装php-7-2-14" class="headerlink" title="编译安装php-7.2.14"></a>编译安装php-7.2.14</h5><p>安装php相关依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#yum -y install wget vim pcre pcre-devel openssl openssl-devel libicu-devel gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel ncurses ncurses-devel curl curl-devel krb5-devel libidn libidn-devel openldap openldap-devel nss_ldap jemalloc-devel cmake boost-devel bison automake libevent libevent-devel gd gd-devel libtool* libmcrypt libmcrypt-devel mcrypt mhash libxslt libxslt-devel readline readline-devel gmp gmp-devel libcurl libcurl-devel openjpeg-deve</span></span><br></pre></td></tr></table></figure>
<p>创建php运行用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#useradd -r -s /sbin/nologin</span></span><br></pre></td></tr></table></figure>
<p>到官网下载php-7.2.14源码包，并编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-25 src]<span class="comment">#pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/src</span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#ls </span></span><br><span class="line">php-7.2.14.tar.gz</span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#tar xf php-7.2.14.tar.gz</span></span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#cd php-7.2.14</span></span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#./configure  --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/conf.d --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-pear --with-curl  --with-png-dir --with-freetype-dir --with-iconv   --with-mhash   --with-zlib --with-xmlrpc --with-xsl --with-openssl  --with-mysqli --with-pdo-mysql --disable-debug --enable-zip --enable-sockets --enable-soap   --enable-inline-optimization  --enable-xml --enable-ftp --enable-exif --enable-wddx --enable-bcmath --enable-calendar   --enable-shmop --enable-dba --enable-sysvsem --enable-sysvshm --enable-sysvmsg</span></span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>php安装好之后无需做过多配置，只需生成相关配置文件即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/php/etc</span><br><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#cp php-fpm.conf.default php-fpm.conf</span></span><br><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#mv php-fpm.d/www.conf.default php-fpm.d/www.conf</span></span><br><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#vi php-fpm.d/www.conf</span></span><br><span class="line">pm.max_children = 8 <span class="comment">#最大子进程数量</span></span><br><span class="line">pm.start_servers = 4 <span class="comment">#初始子进程数量</span></span><br><span class="line">pm.min_spare_servers = 4 <span class="comment">#最小空闲数量</span></span><br><span class="line">pm.max_spare_servers = 6 <span class="comment">#最大空闲数量</span></span><br><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#/usr/local/php/sbin/php-fpm #开启php</span></span><br></pre></td></tr></table></figure>
<h5 id="yum安装Nginx并配置反向代理"><a href="#yum安装Nginx并配置反向代理" class="headerlink" title="yum安装Nginx并配置反向代理"></a>yum安装Nginx并配置反向代理</h5><p>有与yum提供的包已经到1.12.2，所以采用yum安装的方式。安装好之后配置反向代理，将动态请求通过fastcgi转发至php。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#yum -y install nginx</span></span><br><span class="line">[root@host-10-10-10-25 etc]<span class="comment">#vi /etc/nginx/nginx.conf </span></span><br><span class="line">http &#123;</span><br><span class="line">	server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name www.msq.com;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.php;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* \.php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行WordPress"><a href="#运行WordPress" class="headerlink" title="运行WordPress"></a>运行WordPress</h3><p>到官网下载WordPress，并放入php的工作目录中，做相应配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-25 src]<span class="comment">#pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/src</span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#wget https://cn.wordpress.org/wordpress-5.0.2-zh_CN.tar.gz</span></span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#tar xf wordpress-5.0.2-zh_CN.tar.gz</span></span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#cp -r wordpress/* /usr/share/nginx/html/</span></span><br><span class="line">[root@host-10-10-10-25 src]<span class="comment">#cd /usr/share/nginx/html/</span></span><br><span class="line">[root@host-10-10-10-25 html]<span class="comment">#cp wp-config-sample.php wp-config.php</span></span><br><span class="line">[root@host-10-10-10-25 html]<span class="comment">#vi wp-config.php</span></span><br><span class="line">/** WordPress数据库的名称 */</span><br><span class="line">define(<span class="string">'DB_NAME'</span>, <span class="string">'wpdb'</span>);</span><br><span class="line"></span><br><span class="line">/** MySQL数据库用户名 */</span><br><span class="line">define(<span class="string">'DB_USER'</span>, <span class="string">'wpuser'</span>);</span><br><span class="line"></span><br><span class="line">/** MySQL数据库密码 */</span><br><span class="line">define(<span class="string">'DB_PASSWORD'</span>, <span class="string">'centos'</span>);</span><br><span class="line"></span><br><span class="line">/** MySQL主机 */</span><br><span class="line">define(<span class="string">'DB_HOST'</span>, <span class="string">'10.10.10.8'</span>);</span><br><span class="line"></span><br><span class="line">[root@host-10-10-10-25 html]<span class="comment">#chown -R www.www .</span></span><br></pre></td></tr></table></figure>
<p>此时，lnmp+php+WordPress敬意初步搭建完成，在浏览器访问web站点即可完成WordPress的安装，下面继续剩余工作。</p>
<h3 id="搭建nfs共享存储服务器"><a href="#搭建nfs共享存储服务器" class="headerlink" title="搭建nfs共享存储服务器"></a>搭建nfs共享存储服务器</h3><p>安装启动配置nfs服务器,centos7可移植接启动nfs，而centos6则需要先启动rpcbind再启动nfs。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 ~]<span class="comment">#yum -y install nfs</span></span><br><span class="line">[root@10-10-10-11 ~]<span class="comment">#vi /etx/exports.d/data.exports</span></span><br><span class="line">/nfsdata/images 10.10.10.0/24(rw,no_root_squash)</span><br></pre></td></tr></table></figure>
<p>在两个web上都将该共享目录挂载，挂载的服务器上也需要安装nfs-utils包，否则有可能导致写入性能非常差！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-25 uploads]<span class="comment">#mount 10.10.10.11:/nfsdata/images /usr/share/nginx/html/wp-content/uploads</span></span><br></pre></td></tr></table></figure>

<h4 id="通过inotify-rsync实现nfs的实时备份容灾"><a href="#通过inotify-rsync实现nfs的实时备份容灾" class="headerlink" title="通过inotify+rsync实现nfs的实时备份容灾"></a>通过inotify+rsync实现nfs的实时备份容灾</h4>]]></content>
      <tags>
        <tag>lnmp</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶</title>
    <url>/2018/10/10/mysql%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="管理索引"><a href="#管理索引" class="headerlink" title="管理索引"></a>管理索引</h2><p><strong>创建索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX [UNIQUE] index_name ON tbl_name (index_col_name[(length)],...);</span><br><span class="line">help CREATE INDEX;</span><br></pre></td></tr></table></figure>

<p><strong>删除索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON tbl_name;</span><br></pre></td></tr></table></figure>

<p><strong>查看索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEXES FROM [db_name.]tbl_name;</span><br></pre></td></tr></table></figure>

<p><strong>优化表空间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIMIZE TABLE tb_name;</span><br></pre></td></tr></table></figure>

<p><strong>查看索引的使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL userstat&#x3D;1; #可写入配置文件，记录索引的使用情况，过一段你时间查看哪些索引从未被使用过，就可以考虑删除之。</span><br><span class="line">SHOW INDEX_STATISTICS;</span><br></pre></td></tr></table></figure>

<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p><strong>通过EXPLAIN来分析索引的有效性</strong><br>查看执行select查询时是否使用索引</p>
<p>explain select clause</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取查询执行计划信息，用来查看查询优化器如何执行查询</span><br></pre></td></tr></table></figure>

<p>输出信息说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考 https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;explain-output.html</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; explain select * from students where name='xiao qiao';</span><br><span class="line">+<span class="comment">------+-------------+----------+-------+---------------+----------+---------+-------+------+-------+</span></span><br><span class="line">| id   | select_type | table    | type  | possible_keys | key      | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">------+-------------+----------+-------+---------------+----------+---------+-------+------+-------+</span></span><br><span class="line">|    1 | SIMPLE      | students | const | idx_name      | idx_name | 152     | const |    1 |       |</span><br><span class="line">+<span class="comment">------+-------------+----------+-------+---------------+----------+---------+-------+------+-------+</span></span><br></pre></td></tr></table></figure>

<p><strong>id</strong>:当前查询语句中，每个select语句的编号<br>复杂类型的查询有三种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单子查询</span><br><span class="line">用于from中的子查询</span><br><span class="line">联合查询：UNION</span><br></pre></td></tr></table></figure>

<p>注意：UNION查询的分析结果会出现一个额外匿名临时表</p>
<p><strong>select_type</strong><br>简单查询为SIMPLE<br>复杂查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SUBQUERY 简单子查询</span><br><span class="line">PRIMARY 最外面的SELECT</span><br><span class="line">DERIVED 用于FROM中的子查询</span><br><span class="line">UNION UNION语句的第一个之后的SELECT语句</span><br><span class="line">UNION RESULT 匿名临时表</span><br></pre></td></tr></table></figure>

<p><strong>table</strong>：select语句关联到的表</p>
<p>type：关联类型或访问类型，即MySQL决定的如何去查询表中的行的方式，以<br>下顺序，性能从低到高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALL: 全表扫描</span><br><span class="line">index：根据索引的次序进行全表扫描；如果在Extra列出现“Using index”表示了使用覆盖索引，而非全表扫描</span><br><span class="line">range：有范围限制的根据索引实现范围扫描；扫描位置始于索引中的某一点，结束于另一点</span><br><span class="line">ref: 根据索引返回表中匹配某单个值的所有行</span><br><span class="line">eq_ref：仅返回一个行，但与需要额外与某个参考值做比较</span><br><span class="line">const, system: 直接返回单个行</span><br></pre></td></tr></table></figure>

<p><strong>possible_keys</strong>：查询可能会用到的索引<br><strong>key</strong>: 查询中使用到的索引<br><strong>key_len</strong>: 在索引使用的字节数<br><strong>ref</strong>: 在利用key字段所表示的索引完成查询时所用的列或某常量值<br><strong>rows</strong>：MySQL估计为找所有的目标行而需要读取的行数<br><strong>Extra</strong>：额外信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Using index：MySQL将会使用覆盖索引，以避免访问表</span><br><span class="line">Using where：MySQL服务器将在存储引擎检索后，再进行一次过滤</span><br><span class="line">Using temporary：MySQL对结果排序时会使用临时表</span><br><span class="line">Using filesort：对结果使用一个外部索引排序</span><br></pre></td></tr></table></figure>

<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p><strong>锁粒度</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表级锁</span><br><span class="line">行级锁</span><br></pre></td></tr></table></figure>

<p><strong>锁</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读锁：共享锁，只读不可写，多个读互不阻塞，所有人可读且不可写</span><br><span class="line">写锁：独占锁,排它锁，一个写锁会阻塞其它读和写锁，自己可读可写，其他人不可读不可写</span><br></pre></td></tr></table></figure>

<p><strong>实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储引擎：自行实现其锁策略和锁粒度</span><br><span class="line">服务器级：实现了锁，表级锁；用户可显式请求</span><br></pre></td></tr></table></figure>

<p><strong>分类</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">隐式锁：由存储引擎自动施加锁</span><br><span class="line">显式锁：用户手动请求</span><br></pre></td></tr></table></figure>

<p><strong>锁策略</strong>：在锁粒度及数据安全性寻求的平衡机制</p>
<p><strong>显示使用锁</strong><br>LOCK TABLES 加锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tbl_name [[AS] alias] lock_type [, tbl_name [[AS] alias] lock_type] ... </span><br><span class="line">lock_type: READ ， WRITE</span><br></pre></td></tr></table></figure>

<p>UNLOCK TABLES 解锁 或者退出当前登录会自动解锁</p>
<p>FLUSH TABLES [tb_name[,…]] [WITH READ LOCK]<br>如果不加with read lock表示关闭正在打开的表（清除查询缓存），加上的话通常在备份前加全局读锁，对整个数据库实例加读锁，所有人对本实例的所有库都无法更改。</p>
<p>SELECT clause [FOR UPDATE | LOCK IN SHARE MODE]<br>查询时加写或读锁</p>
<p>如果数据库被加了全局锁，导致无法正常使用，可以使用show processlist\G;查看哪个线程加的锁，然后kill process_id；杀掉该线程即可。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务Transactions</strong>：一组原子性的SQL语句，或一个独立工作单元<br><strong>事务日志</strong>：记录事务信息，实现undo,redo等故障恢复功能<br>ACID特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A：atomicity原子性；整个事务中的所有操作要么全部成功执行，要么全部失败后回滚</span><br><span class="line">C：consistency一致性；数据库总是从一个一致性状态转换为另一个一致性状态</span><br><span class="line">I：Isolation隔离性；一个事务所做出的操作在提交之前，是不能为其它事务所见；隔离有多种隔离级别，实现并发</span><br><span class="line">D：durability持久性；一旦事务提交，其所做的修改会永久保存于数据库中</span><br></pre></td></tr></table></figure>

<p><strong>启动事务：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">BEGIN WORK</span><br><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure>

<p><strong>结束事务：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMIT：提交</span><br><span class="line">ROLLBACK: 回滚，回滚只能针对DML语言有效，对DDL语言无效</span><br></pre></td></tr></table></figure>
<p>注意：只有事务型存储引擎中的DML语句方能支持此类操作</p>
<p><strong>自动提交</strong>：set autocommit={1|0}    默认为1，为0时设为非自动提交<br>    建议：显示请求和提交事务，而不要使用”自动提交”功能</p>
<p>事务支持保存点：savepoint<br>SAVEPOINT identifier<br>ROLLBACK [WORK] TO [SAVEPOINT] identifier<br>RELEASE SAVEPOINT identifier</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务的隔离级别：从上至下更加严格</p>
<ol>
<li>read uncommitted 可读取到未提交数据，产生脏读</li>
<li>read committed 可读到提交数据，但未提交数据不可读，产生不可重复读，即可读取到多个提交数据，导致每次读取数据不一致</li>
<li>repeatable read 可重复读，多次读取数据都一致，产生幻读，即读取过程中，即使由其他提交的事务修改数据，仍只能读取到未修改前的旧数据。此为mysql默认设置</li>
<li>serializabile 可串行化，未提交的读事务阻塞修改事务，或者未提交的修改事务阻塞读事务，导致并发性能差。</li>
</ol>
<p><strong>查看mysql默认的隔离级别</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like 'tx_isolation';</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+<span class="comment">---------------+-----------------+</span></span><br><span class="line">MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>指定事务的隔离级别</strong><br>方法一：通过服务器变量tx_isolation指定,默认为REPEATABLE-READ，可在global和SESSION级进行设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> tx_isolation=<span class="string">''</span></span><br><span class="line"><span class="keyword">READ</span>-UNCOMMITTED</span><br><span class="line"><span class="keyword">READ</span>-COMMITTED</span><br><span class="line">REPEATABLE-<span class="keyword">READ</span></span><br><span class="line"><span class="keyword">SERIALIZABLE</span></span><br></pre></td></tr></table></figure>

<p>方法二：在服务器选项中指定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#vim /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">transaction-isolation=SERIALIZABLE</span><br></pre></td></tr></table></figure>

<h4 id="事务中的并发控制"><a href="#事务中的并发控制" class="headerlink" title="事务中的并发控制"></a>事务中的并发控制</h4><p>死锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个或多个事务在同一资源相互占用，并请求锁定对方占用的资源的状态</span><br></pre></td></tr></table></figure>
<p>mysql发现死锁后，会自动牺牲掉持续时间较小的事务，从而解锁。<br>避免发生死锁的方法：按同序修改表，不要在两个事务中交叉修改表。</p>
<p>事务日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务日志的写入类型为&quot;追加&quot;，因此其操作为&quot;顺序IO&quot;；通常也被称为：预写式日志 write ahead logging</span><br><span class="line">事务日志文件：ib_logfile0,ib_logfile1</span><br></pre></td></tr></table></figure>

<h2 id="mysql中的日志管理"><a href="#mysql中的日志管理" class="headerlink" title="mysql中的日志管理"></a>mysql中的日志管理</h2><p><strong>日志类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务日志 transaction log</span><br><span class="line">错误日志 error log</span><br><span class="line">通用日志 general log</span><br><span class="line">慢查询日志 slow query log</span><br><span class="line">二进制日志 binary log</span><br><span class="line">中继日志 reley log</span><br></pre></td></tr></table></figure>

<h3 id="事务日志-transaction-log"><a href="#事务日志-transaction-log" class="headerlink" title="事务日志 transaction log"></a>事务日志 transaction log</h3><p>事务型存储引擎自行管理和使用，建议和数据文件分开放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redo log</span><br><span class="line">undo log</span><br></pre></td></tr></table></figure>
<p>innodb事务日志相关配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%innodb_log%&#39;;</span><br><span class="line">innodb_log_file_size 5242880 每个日志文件大小</span><br><span class="line">innodb_log_files_in_group 2 日志组成员个数</span><br><span class="line">innodb_log_group_home_dir .&#x2F; 事务文件路径</span><br><span class="line">innodb_flush_log_at_trx_commit 默认为1</span><br></pre></td></tr></table></figure>
<p>上述各项均可根据实际需求定制大小，写入配置文件永久生效</p>
<p><strong>innodb_flush_log_at_trx_commit选项说明</strong><br>说明：设置为1，同时sync_binlog=1表示最高级别的容错<br>innodb_use_global_flush_log_at_trx_commit的值确定是否可以使用SET语句重置此变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1默认情况下，日志缓冲区将写入日志文件，并在每次事务后执行刷新到磁盘。</span><br><span class="line">	这是完全遵守ACID特性</span><br><span class="line">0提交时没有任何操作; 而是每秒执行一次日志缓冲区写入和刷新。 这样可以提</span><br><span class="line">	供更好的性能，但服务器崩溃可以清除最后一秒的事务</span><br><span class="line">2每次提交后都会写入日志缓冲区，但每秒都会进行一次刷新。 性能比0略好一</span><br><span class="line">	些，但操作系统或停电可能导致最后一秒的交易丢失,一般设置为2比较合理，</span><br><span class="line">	但是涉及金融等数据比较重要的场合慎用</span><br><span class="line">3模拟MariaDB 5.5组提交（每组提交3个同步），此项MariaDB 10.0支持</span><br></pre></td></tr></table></figure>

<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p><strong>错误日志的记录内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld启动和关闭过程中输出的事件信息</span><br><span class="line">mysqld运行中产生的错误信息</span><br><span class="line">event scheduler运行一个event时产生的日志信息</span><br><span class="line">在主从复制架构中的从服务器上启动从服务器线程时产生的信息</span><br></pre></td></tr></table></figure>

<p><strong>错误日志的相关配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;log_error&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>错误日志的文件路径</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_error&#x3D;&#x2F;path&#x2F;to&#x2F;log_error_file</span><br></pre></td></tr></table></figure>

<p><strong>是否记录警告信息至错误日志</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_warnings&#x3D;1|0 默认值1</span><br></pre></td></tr></table></figure>

<h3 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h3><p>记录对数据库的通用操作，包括错误的SQL语句<br>文件：file，默认值<br>表：table</p>
<p><strong>通用日志的相关设置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general_log&#x3D;ON|OFF</span><br><span class="line">general_log_file&#x3D;hostname.log</span><br><span class="line">log_output&#x3D;table|file|none</span><br></pre></td></tr></table></figure>

<p>查看是否开启通用日志</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like 'general_log%';</span><br><span class="line">+<span class="comment">------------------+-------------+</span></span><br><span class="line">| Variable_name    | Value       |</span><br><span class="line">+<span class="comment">------------------+-------------+</span></span><br><span class="line">| general_log      | OFF         |</span><br><span class="line">| general_log_file | mariadb.log |</span><br><span class="line">+<span class="comment">------------------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>查看通用日志的存储格式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select @@log_output;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| @@log_output |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| FILE         |</span><br><span class="line">+<span class="comment">--------------+</span></span><br></pre></td></tr></table></figure>

<p>查看通用日志表格的信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [mysql]&gt; show table status like 'general_log'\G;</span><br></pre></td></tr></table></figure>

<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>记录执行查询时长超出指定时长的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow_query_log&#x3D;ON|OFF 开启或关闭慢查询（建议开启）</span><br><span class="line">long_query_time&#x3D;N 慢查询的阀值，单位秒（建议设置为2）</span><br><span class="line">slow_query_log_file&#x3D;HOSTNAME-slow.log 慢查询日志文件</span><br><span class="line">log_slow_filter &#x3D; admin,filesort,filesort_on_disk,full_join,full_scan,</span><br><span class="line">	query_cache,query_cache_miss,tmp_table,tmp_table_on_disk</span><br><span class="line">	上述查询类型且查询时长超过long_query_time，则记录日志</span><br><span class="line">log_queries_not_using_indexes&#x3D;ON 不使用索引或使用全索引扫描，不论</span><br><span class="line">	是否达到慢查询阀值的语句是否记录日志，默认OFF，即不记录（建议开启）</span><br><span class="line">log_slow_rate_limit &#x3D; 1 多少次查询才记录，mariadb特有</span><br><span class="line">log_slow_verbosity&#x3D; Query_plan,explain 记录内容</span><br><span class="line">log_slow_queries &#x3D; OFF 同slow_query_log 新版已废弃</span><br></pre></td></tr></table></figure>

<p><strong>profiling工具</strong><br>profiling可一分析一条查询语句各个环节所用的时间，从而我们可以借助profiling分析一条语句查询慢的原因。用法如下；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; set profiling=1; #开启profiling功能</span><br><span class="line">MariaDB [hellodb]&gt; show profiles; #查看记录下来的查询速度慢的语句</span><br><span class="line">MariaDB [(none)]&gt; show profile for query num; #查看各个环节用时</span><br></pre></td></tr></table></figure>


<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记录导致数据改变或潜在导致数据改变的SQL语句</span><br><span class="line">记录已提交的日志</span><br><span class="line">不依赖于存储引擎类型</span><br><span class="line">功能：通过“重放”日志文件中的事件来生成数据副本</span><br><span class="line">	注意：建议二进制日志和数据文件分开存放</span><br></pre></td></tr></table></figure>

<p>中继日志：relay log<br>主从复制架构中，从服务器用于保存从主服务器的二进制日志中读取的事件</p>
<p><strong>二进制日志记录的三种格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于“语句”记录：statement，记录语句，默认模式</span><br><span class="line">基于“行”记录：row，记录数据，日志量较大</span><br><span class="line">混合模式：mixed, 让系统自行判定该基于哪种方式进行</span><br></pre></td></tr></table></figure>

<p><strong>二进制日志文件的构成</strong><br>有两类文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日志文件：mysql|mariadb-bin.文件名后缀，二进制格式</span><br><span class="line">	如：mariadb-bin.000001</span><br><span class="line">索引文件：mysql|mariadb-bin.index，文本格式</span><br></pre></td></tr></table></figure>

<p><strong>二进制日志相关的服务器变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql_log_bin&#x3D;ON|OFF：是否记录二进制日志，默认ON;支持session级设定，可用于临时禁用二进制日志。</span><br><span class="line">log_bin&#x3D;&#x2F;PATH&#x2F;BIN_LOG_FILE：指定文件位置；默认OFF，表示不启用二</span><br><span class="line">	进制日志功能，上述两项都开启才可</span><br><span class="line">binlog_format&#x3D;STATEMENT|ROW|MIXED：二进制日志记录的格式，默认STATEMENT</span><br><span class="line">max_binlog_size&#x3D;1073741824：单个二进制日志文件的最大体积，到达最</span><br><span class="line">	大值会自动滚动，默认为1G</span><br><span class="line">		说明：文件达到上限时的大小未必为指定的精确值</span><br><span class="line">sync_binlog&#x3D;1|0：设定是否启动二进制日志即时同步磁盘功能，默认0，由</span><br><span class="line">	操作系统负责同步日志到磁盘</span><br><span class="line">expire_logs_days&#x3D;N：二进制日志可以自动删除的天数。 默认为0，即不自动删除</span><br></pre></td></tr></table></figure>

<p><strong>二进制日志相关配置</strong><br>查看mariadb自行管理使用中的二进制日志文件列表，及大小</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> &#123;<span class="built_in">binary</span>|<span class="keyword">master</span>&#125; <span class="keyword">logs</span></span><br></pre></td></tr></table></figure>

<p>查看使用中的二进制日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure>

<p>查看二进制文件中的指定内容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> [<span class="keyword">in</span> <span class="string">'log_name'</span>] [<span class="keyword">from</span> pos] [<span class="keyword">limit</span> [<span class="keyword">offset</span>,] <span class="keyword">row_count</span>]</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">binlog</span> <span class="keyword">events</span> <span class="keyword">in</span> <span class="string">'mysql-bin.000001'</span> <span class="keyword">from</span> <span class="number">6516</span> <span class="keyword">limit</span> <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="mysqlbinlog：二进制日志查看工具"><a href="#mysqlbinlog：二进制日志查看工具" class="headerlink" title="mysqlbinlog：二进制日志查看工具"></a>mysqlbinlog：二进制日志查看工具</h4><p>命令格式：mysqlbinlog [options] log_file…<br>options</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--start-position&#x3D;# 指定开始位置</span><br><span class="line">--stop-position&#x3D;#</span><br><span class="line">--start-datetime&#x3D;</span><br><span class="line">--stop-datetime&#x3D;</span><br><span class="line">时间格式：YYYY-MM-DD hh:mm:ss</span><br><span class="line">--base64-output[&#x3D;name]</span><br><span class="line">-v -vvv</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s</title>
    <url>/2018/09/28/k8s/</url>
    <content><![CDATA[<h2 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h2><p>Kubernetes技术已经成为了原生云技术的事实标准，它是目前基础软件领域最为热门的分布式调度和管理平台。于是，Kubernetes也几乎成了时下开发工程师和运维工程师必备的技能之一。</p>
<p>容器编排系统：</p>
<ul>
<li>Docker Swarm</li>
<li>Apache Mesos and Marathon</li>
<li>kubernetes</li>
</ul>
<p>k8s物理结构<br><strong>master</strong></p>
<ul>
<li><p>API Server(数据库，实现对容器的增删改查)</p>
<blockquote>
<p>API<br>UI<br>CLI</p>
</blockquote>
</li>
<li><p>Scheduler(watch API Server上的变动，一旦发现变动就同步变动。)</p>
</li>
<li><p>Controller(对比用户期望的和现有的资源状态)</p>
</li>
<li><p>etcd</p>
</li>
</ul>
<p>service:</p>
<ul>
<li><p>proxy mode: userspace/iptables/ipvs</p>
<blockquote>
<p>kube-proxy</p>
</blockquote>
</li>
<li><p>service type: ClusterIP, NodePort(30000-32767之间的端口), LoadBalancer,ExternalName,  </p>
</li>
<li><p>label selector:Pod资源，自动为每个Pod对象创建Endpoint</p>
</li>
</ul>
<p>PV的回收策略：</p>
<ul>
<li>return</li>
<li>resycle</li>
<li>delete</li>
</ul>
<h2 id="部署k8s测试集群"><a href="#部署k8s测试集群" class="headerlink" title="部署k8s测试集群"></a>部署k8s测试集群</h2><h3 id="主机环境预设"><a href="#主机环境预设" class="headerlink" title="主机环境预设"></a>主机环境预设</h3><h3 id="安装程序包"><a href="#安装程序包" class="headerlink" title="安装程序包"></a>安装程序包</h3><p>在各节点配置docker-ce仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>
<p>安装docker-ce</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># yum -y install docker-ce</span></span><br></pre></td></tr></table></figure>
<p>配置启动docker<br>修改docker的启动文件，在service配置段增加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># vi /usr/lib/systemd/system/docker.service</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://www.ik8s.io:10070"</span> <span class="comment">#设定访问k8s时的代理</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=127.0.0.0/8,192.168.34.0/32,172.18.0.0/24"</span> <span class="comment">#对哪些网段不使用代理</span></span><br><span class="line">ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT <span class="comment">#由于docker会在启动时将FORWARD链修改为DROP，所以在启动docker后要将默认策略改为ACCEPT，以确保不影响k8s的使用。</span></span><br></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment">#systemctl start docker &amp;&amp; systemctl enable docker</span></span><br></pre></td></tr></table></figure>
<p>修改内核参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># cat /etc/sysctl.d/k8s.conf</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br></pre></td></tr></table></figure>
<p>重载内核参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># sysctl -p /etc/sysctl.d/k8s.conf </span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br></pre></td></tr></table></figure>

<p>配置kubernetes的yum仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># cat k8s.repo </span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=k8s</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">	https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br></pre></td></tr></table></figure>

<p>安装kubernetes</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># yum install kubeadm kubelet</span></span><br></pre></td></tr></table></figure>
<p>如果未关闭swap，则再启动kubernetes时必须加一个参数，禁止检查swap分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master yum.repos.d]<span class="comment"># cat /etc/sysconfig/kubelet </span></span><br><span class="line">KUBELET_EXTRA_ARGS=<span class="string">"--fail-swap-on=false"</span></span><br></pre></td></tr></table></figure>
<p>而后，在运行初始化命令之前先运行如下命令单独获取相关的镜像文件，然后在执行初始化命令，以便观察到镜像文件的下载过程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubeadm config images pull</span></span><br></pre></td></tr></table></figure>

<p>初始化master节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubeadm init --kubernetes-version=v1.13.3 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap</span></span><br></pre></td></tr></table></figure>

<p>命令中的各选项简单说明如下：</p>
<pre><code>(1) --kubernetes-version选项的版本号用于指定要部署的Kubenretes程序版本，它需要与当前的kubeadm支持的版本保持一致；
(2) --pod-network-cidr选项用于指定分Pod分配使用的网络地址，它通常应该与要部署使用的网络插件（例如flannel、calico等）的默认设定保持一致，10.244.0.0/16是flannel默认使用的网络；
(3) --service-cidr用于指定为Service分配使用的网络地址，它由kubernetes管理，默认即为10.96.0.0/12；
(4) 最后一个选项“--ignore-preflight-errors=Swap”仅应该在未禁用Swap设备的状态下使用。</code></pre><p>如果是一个普通用户使用k8s集群，则需要执行如下步骤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#  mkdir -p $HOME/.kube</span></span><br><span class="line">~]<span class="comment">#  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line">~]<span class="comment">#  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>
<p>如果是root用户，则直接再加目录下执行如下操作即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#mkdir -p root/.kube</span></span><br><span class="line">~]<span class="comment"># cp -i /etc/kubernetes/admin.conf root/.kube/config</span></span><br></pre></td></tr></table></figure>

<p>添加flannel网络附件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br></pre></td></tr></table></figure>

<p>使用如下命令确认其输出结果中Pod的状态为”Running”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubectl get pods -n kube-system -l app=flannel</span></span><br><span class="line">   NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">   kube-flannel-ds-amd64-wscnz   1/1     Running   0          14m</span><br></pre></td></tr></table></figure>

<p>验证master节点已经就绪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line"> NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">master   Ready    master   53m   v1.13.3</span><br></pre></td></tr></table></figure>

<p>至此，kubernetes就能已经搭建完成。接下来，向该集群中加入节点：</p>
<p>在需要加入的节点上安装kubeadm kubectl kubelet,然后使用如下命令将节点加入到该集群中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubeadm join 172.18.139.207:6443 --token 5w02cc.eivi4xb8885qnb8h --discovery-token-ca-cert-hash sha256:569ce592569c88a322c701458d70130d66ae92bbe24cf97900754beb0ff4ac1a --ignore-preflight-errors=Swap</span></span><br></pre></td></tr></table></figure>

<p>node加入集群报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[discovery] Failed to request cluster info, will try again: [Get https://192</span><br></pre></td></tr></table></figure>
<p>解决方案：<br>次报错是由于node和master的时间不一致导致的，需要使用ntp做时间同步。</p>
<p>获取集群状态信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl cluster-info</span></span><br></pre></td></tr></table></figure>

<p>其中一个节点在执行过程中报如下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node03 ~]<span class="comment"># sysctl -p /etc/sysctl.d/k8s.conf </span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">sysctl: cannot <span class="built_in">stat</span> /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory</span><br><span class="line">sysctl: cannot <span class="built_in">stat</span> /proc/sys/net/bridge/bridge-nf-call-iptables: No such file or directory</span><br></pre></td></tr></table></figure>

<p>解决办法为,加载相应的内核模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node03 ~]<span class="comment"># modprobe br_netfilter</span></span><br></pre></td></tr></table></figure>
<p>之后就可以正常修改内核参数。</p>
<h4 id="从集群中移除节点"><a href="#从集群中移除节点" class="headerlink" title="从集群中移除节点"></a>从集群中移除节点</h4><p>如果运行过程中需要从正常运行的集群中移除节点，则执行以下步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubectl drain NODE_ID --delete-local-data --force --ignore-daemonsets</span></span><br><span class="line">~]<span class="comment"># kubectl delete node NODE_ID</span></span><br></pre></td></tr></table></figure>
<p>然后再需要删除的节点上执行如下命令重置系统状态便可完成移除操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubeadm reset</span></span><br></pre></td></tr></table></figure>

<h4 id="重新生成用于节点加入几群的认证命令"><a href="#重新生成用于节点加入几群的认证命令" class="headerlink" title="重新生成用于节点加入几群的认证命令"></a>重新生成用于节点加入几群的认证命令</h4><p>获取集群上存在的认证令牌</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubeadm token list</span></span><br></pre></td></tr></table></figure>

<p>生成用于验证CA的哈希值(discovery-token-ca-cert-hash)的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'</span></span><br></pre></td></tr></table></figure>

<p>然后，将上述两个命令生成的结果合称为如下格式的kubeadm join命令即可用于让node加入急群众，其中TOKEN为上面第一个命令看到的token，HASH为第二条命令生成的HASH</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubeadm join master-ip:port --token TOKEN --discovery-token-ca-cert-hash HASH</span></span><br></pre></td></tr></table></figure>

<h2 id="管理kubernetes集群"><a href="#管理kubernetes集群" class="headerlink" title="管理kubernetes集群"></a>管理kubernetes集群</h2><h3 id="kubectl命令常用操作示例"><a href="#kubectl命令常用操作示例" class="headerlink" title="kubectl命令常用操作示例"></a>kubectl命令常用操作示例</h3><h4 id="创建资源对象"><a href="#创建资源对象" class="headerlink" title="创建资源对象"></a>创建资源对象</h4><p>创建名为nginx-deploy的Deployment控制器资源对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl run nginx-deploy --image=nginx:1.12 --replicas=2</span></span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed <span class="keyword">in</span> a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/nginx-deploy created</span><br></pre></td></tr></table></figure>

<p>创建名为nginx-svc的Service资源对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl expose deployment/nginx-deploy --name=nginx-svc --port=80</span></span><br></pre></td></tr></table></figure>

<p>pod地址：<br>service：nodeport<br>hostport<br>hostnetwork</p>
<h4 id="查看资源对象"><a href="#查看资源对象" class="headerlink" title="查看资源对象"></a>查看资源对象</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># kubectl get namespace #列出系统上所有的namespace资源对象</span></span><br><span class="line">~]<span class="comment"># [root@master ~]# kubectl get pods -l k8s-app -o wide -n kube-system #列出kube-system名称空间下拥有k8s-app标签名称的所有pod对象</span></span><br></pre></td></tr></table></figure>

<h4 id="打印资源对象的详细信息"><a href="#打印资源对象的详细信息" class="headerlink" title="打印资源对象的详细信息"></a>打印资源对象的详细信息</h4><p>每个资源对象都包含着用户期望的状态(spec)和现有的实际状态(status)两种状态信息，”kubectl get -o {yaml|json}” 或 “kubectl describe”命令都能打印出指定资源的详细信息.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get pods -l component=kube-apiserver -o yaml -n kube-system</span></span><br></pre></td></tr></table></figure>

<h4 id="打印容器中的日志信息"><a href="#打印容器中的日志信息" class="headerlink" title="打印容器中的日志信息"></a>打印容器中的日志信息</h4><p>命令格式:</p>
<pre><code>kubectl logs [-f] [-p] (POD|TYPE/NAME) [-c CONTAINER] [options] </code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl logs kube-apiserver-master.ilinux.io -n kube-system</span></span><br></pre></td></tr></table></figure>

<h4 id="在容器中执行命令"><a href="#在容器中执行命令" class="headerlink" title="在容器中执行命令"></a>在容器中执行命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl exec kube-apiserver-master.ilinux.io -n kube-system -- ps</span></span><br></pre></td></tr></table></figure>
<p>如果pod对象中存在多个容器，则需要以-c选项指定容器后再运行。</p>
<h4 id="删除资源对象"><a href="#删除资源对象" class="headerlink" title="删除资源对象"></a>删除资源对象</h4><p>删除单个对像，如果对象受控于控制器，则删除之后其控制器可能会重建出类似的对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl delete svc nginx-svc</span></span><br></pre></td></tr></table></figure>

<p>删除拥有某一标签的所有对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pods -l app=monitor -n kube-system</span><br></pre></td></tr></table></figure>

<p>删除指定名称空间的所有某类对象，可以使用kbectl delete TYPE –all -n NS,例如，删除kube-public名称空间中的所有pod对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pods --all -n kube-public</span><br></pre></td></tr></table></figure>
<p>另外，有些资源类型(如pod)，支持优雅删除的机制，它们有着默认的删除宽限期，不过，用户可以在命令中使用–grace-period或–now选项来覆盖默认的宽限期。</p>
<h3 id="命令式容器应用编排"><a href="#命令式容器应用编排" class="headerlink" title="命令式容器应用编排"></a>命令式容器应用编排</h3><p>k8s集群网络：</p>
<ul>
<li>node network：与外部网络接口</li>
<li>service network：</li>
<li>pod network：内部网络</li>
</ul>
<h3 id="pod相关操作"><a href="#pod相关操作" class="headerlink" title="pod相关操作"></a>pod相关操作</h3><h4 id="pod标签相关的操作"><a href="#pod标签相关的操作" class="headerlink" title="pod标签相关的操作"></a>pod标签相关的操作</h4><p>基于配置文件生成pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># cat pod-demo-2.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata: </span><br><span class="line">  name: pod-demo</span><br><span class="line">  namespace: prod</span><br><span class="line">  labels:</span><br><span class="line">    app: pod-demo</span><br><span class="line">    rel: stable</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes/myapp:v1</span><br><span class="line">  - name: bbox</span><br><span class="line">    image: busybox:latest</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"sleep 86400"</span>]</span><br><span class="line">[root@master basic]<span class="comment"># kubectl apply -f pod-demo-2.yaml</span></span><br></pre></td></tr></table></figure>

<p>通过命令为为pod打标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># kubectl label pods pod-demo -n prod tier=backend --overwrite</span></span><br></pre></td></tr></table></figure>

<p>修改pod已有标签的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># kubectl label pods pod-demo -n prod tier=backend --overwrite</span></span><br></pre></td></tr></table></figure>

<p>删除pod的某个标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># kubectl get pods -n prod --show-labels</span></span><br><span class="line">NAME       READY   STATUS        RESTARTS   AGE    LABELS</span><br><span class="line">pod-demo   0/2     Terminating   0          130m   app=pod-demo,rel=stable,tier=backend</span><br><span class="line">[root@master basic]<span class="comment"># kubectl label pods pod-demo -n prod rel-</span></span><br><span class="line">pod/pod-demo labeled</span><br><span class="line">[root@master basic]<span class="comment"># kubectl get pods -n prod --show-labels</span></span><br><span class="line">NAME       READY   STATUS        RESTARTS   AGE    LABELS</span><br><span class="line">pod-demo   0/2     Terminating   0          130m   app=pod-demo,tier=backend</span><br></pre></td></tr></table></figure>

<p>筛选具有某个特定标签的pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># kubectl get pods -l run(!)=myapp</span></span><br></pre></td></tr></table></figure>

<p>筛选具有一组标签的某一个标签的pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># kubectl get pods --show-labels -l "run in (myapp,ngx-dep)"</span></span><br></pre></td></tr></table></figure>

<h4 id="pod资源注解"><a href="#pod资源注解" class="headerlink" title="pod资源注解"></a>pod资源注解</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master basic]<span class="comment"># cat pod-demo-2.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata: </span><br><span class="line">  name: pod-demo</span><br><span class="line">  namespace: prod</span><br><span class="line">  labels:</span><br><span class="line">    app: pod-demo</span><br><span class="line">    rel: stable</span><br><span class="line">  annotations: </span><br><span class="line">    ik8s.io/project: hello</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp</span><br><span class="line">    image: ikubernetes/myapp:v1</span><br><span class="line">  - name: bbox</span><br><span class="line">    image: busybox:latest</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"sleep 86400"</span>]</span><br></pre></td></tr></table></figure>

<h4 id="livenessProbe"><a href="#livenessProbe" class="headerlink" title="livenessProbe"></a>livenessProbe</h4><p>容器健康状态检查，一旦检查到不健康，会自动重启容器。配置spec上下文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthz</span><br><span class="line">        port: http</span><br><span class="line">        scheme: HTTP</span><br><span class="line">      periodSeconds: 2</span><br><span class="line">      failureThreshold: 2</span><br><span class="line">      initialDelaySeconds: 3</span><br></pre></td></tr></table></figure>

<h4 id="readinessProbe"><a href="#readinessProbe" class="headerlink" title="readinessProbe"></a>readinessProbe</h4><p>容器就绪状态检测，没有重启容器的权利。</p>
<h4 id="pod对象的相位"><a href="#pod对象的相位" class="headerlink" title="pod对象的相位"></a>pod对象的相位</h4><p>pod对象纵使应该处于其生命进程中以下几个相位(phase)之一</p>
<ul>
<li>pending：API server创建了pod资源对象并已存入etcd中，但它尚未被调度完成，或仍处于从仓库中下载镜像的过程中。</li>
<li>running：pod已经被调度至某节点，并且所有的容器都已经被kubelet创建完成</li>
<li>succeeded：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>failed：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态或已经被系统终止。</li>
<li>unknown：API server无法正常获取到pod对象的状态信息，通常是由于其无法与所在工作节点的kubelet通信所致。</li>
</ul>
<h4 id="容器的重启策略"><a href="#容器的重启策略" class="headerlink" title="容器的重启策略"></a>容器的重启策略</h4><p>pod对象因容器程序崩溃或容器申请超出限制的资源等原因都可能导致其被终止，此时是否应该重建此容器取决于其重启策略。</p>
<ul>
<li>Always：但凡pod对象终止就将其重启，此为默认设定。</li>
<li>OnFailure：仅在pod对象出现错误时方才将其重启。</li>
<li>Never：从不重启。</li>
</ul>
<h4 id="资源需求及资源限制"><a href="#资源需求及资源限制" class="headerlink" title="资源需求及资源限制"></a>资源需求及资源限制</h4><p>容器的计算资源配额</p>
<ul>
<li><p>CPU属于可压缩(compressible)型资源，即资源额度可按需收缩，而内存(当前)则是不可压缩型资源，对其执行收缩操作可能会导致某种程度的问题</p>
</li>
<li><p>CPU资源的计量方式</p>
<blockquote>
<p>一个核心相当于1000个微核心，即1=1000m，0.5=500m</p>
</blockquote>
</li>
<li><p>内存资源的计量方式</p>
<blockquote>
<p>默认单位为字节，也可以使用E,P,T,G,M和K后缀单位。</p>
</blockquote>
</li>
</ul>
<h4 id="pod服务质量类别"><a href="#pod服务质量类别" class="headerlink" title="pod服务质量类别"></a>pod服务质量类别</h4><p>根据pod对象的requests和limits属性，kubernetes把pod对象归类到besteffort、burstable和guaranteed三个服务质量类别(Quality of Service,QoS)下</p>
<ul>
<li>guaranteed，每个容器都为CPU资源设置了具有相同值的requests和limits属性，以及每个容器都为CPU资源设置了具有想通知的requests和limits属性的pod资源会自动归属此类别，这类pod资源具有最高优先级</li>
<li>burstable：至少有一个容器设置了CPU或内存资源的requests属性，但不满足guaranteed类别要求的pod资源自动归属此类别。</li>
<li>besteffort：未为任何一个容器设置requests或limits属性的pod资源自动归属此类别。</li>
</ul>
<h2 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master chapter5]<span class="comment"># cat rs-example.yaml </span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-rs</span><br><span class="line">  namespace: prod</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">     matchLabels:</span><br><span class="line">       app: myapp-pod</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myapp-pod</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myapp</span><br><span class="line">        image: ikubernetes/myapp:v1</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 80</span><br></pre></td></tr></table></figure>

<p>修改pod数量的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master chapter5]<span class="comment"># kubectl scale --replicas=2 rs myapp-rs -n prod</span></span><br></pre></td></tr></table></figure>

<p><strong>升级pod中容器使用的镜像的方法：</strong><br>修改rs配置文件指定image版本</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2018/08/18/ELK/</url>
    <content><![CDATA[<h2 id="ELK日志收集分析"><a href="#ELK日志收集分析" class="headerlink" title="ELK日志收集分析"></a>ELK日志收集分析</h2><p><strong>什么是ELK</strong><br>通俗来讲，ELK是由Elasticsearch、Logstash、Kibana 、filebeat三个开源软件的组成的一个组合体，这三个软件当中，每个软件用于完成不同的功能，ELK 又称为ELK stack，官方域名为stactic.co，ELK stack的主要优点有如下几个：<br>处理方式灵活： elasticsearch是实时全文索引，具有强大的搜索功能<br>配置相对简单：elasticsearch全部使用JSON 接口，logstash使用模块配置，kibana的配置文件部分更简单。<br>检索性能高效：基于优秀的设计，虽然每次查询都是实时，但是也可以达到百亿级数据的查询秒级响应。<br>集群线性扩展：elasticsearch和logstash都可以灵活线性扩展<br>前端操作绚丽：kibana的前端设计比较绚丽，而且操作简单</p>
<p><strong>什么是elasticsearch</strong><br>是一个高度可扩展的开源全文搜索和分析引擎，它可实现数据的实时全文搜索搜索、支持分布式可实现高可用、提供API接口，可以处理大规模日志数据，比如Nginx、Tomcat、系统日志等功能。</p>
<p><strong>什么是Logstash</strong><br>可以通过插件实现日志收集和转发，支持日志过滤，支持普通log、自定义json格式的日志解析。</p>
<p><strong>什么是kibana</strong><br>主要是通过接口调用elasticsearch的数据，并进行前端数据可视化的展现。</p>
<p><strong>为什么使用 ELK</strong><br>ELK组件在海量日志系统的运维中，可用于解决以下主要问题：</p>
<ul>
<li>分布式日志数据统一收集，实现集中式查询和管理</li>
<li>故障排查</li>
<li>安全信息和事件管理</li>
<li>报表功能</li>
</ul>
<p>ELK组件在大数据运维系统中，主要可解决的问题如下：</p>
<ul>
<li>日志查询，问题排查，故障恢复，故障自愈</li>
<li>应用日志分析，错误报警</li>
<li>性能分析，用户行为分析</li>
</ul>
<p>架构图：</p>
<p>kibana –&gt; ES –&gt; Logstash –&gt; Redis –&gt; Logstash –&gt; webserver + filebeat</p>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>elasticsearch是java程序，需要预先准备jdk环境。<br>下载rpm包<br>编辑各elasticsearch服务器的服务配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># yum -y install elasticsearch-5.6.13.rpm</span></span><br><span class="line">[root@node01 ~]<span class="comment"># grep "^[a-Z]" /etc/elasticsearch/elasticsearch.yml </span></span><br><span class="line">cluster.name: myelk <span class="comment">#ELK的集群名称，名称相同即属于是同一个集群</span></span><br><span class="line">path.data: /data/esdata/  <span class="comment">#数据保存目录</span></span><br><span class="line">path.logs: /data/esdata/eslogs/   <span class="comment">#日志保存目</span></span><br><span class="line">network.host: 192.168.34.101 <span class="comment">#监听IP</span></span><br><span class="line">bootstrap.memory_lock: <span class="literal">true</span> <span class="comment">#服务启动的时候锁定足够的内存，防止数据写入swap</span></span><br><span class="line">http.port: 9200  <span class="comment">#监听端口</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"node01"</span>, <span class="string">"master"</span>]</span><br></pre></td></tr></table></figure>

<p>修改内存限制，并同步配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host1 ~]<span class="comment"># vim /usr/lib/systemd/system/elasticsearch.service #修改内存限制</span></span><br><span class="line">LimitMEMLOCK=infinity  <span class="comment">#最大化使用内存</span></span><br><span class="line">[root@linux-host1 ~]<span class="comment"># vim /etc/elasticsearch/jvm.options </span></span><br><span class="line">22 \-Xms2g</span><br><span class="line">23 \-Xmx2g <span class="comment">#最小和最大内存限制，为什么最小和最大设置一样大？</span></span><br></pre></td></tr></table></figure>

<p>目录权限更改<br>各服务器创建数据和日志目录并修改目录权限为elasticsearch</p>
<p>启动elasticsearch，如果启动过程中出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost.localdomain elasticsearch[21616]: Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=<span class="string">'Cannot allocate memory'</span> (errno=12)</span><br></pre></td></tr></table></figure>
<p>说明内存不够，可以通过调小启动内存解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># vi /etc/elasticsearch/jvm.options</span></span><br><span class="line"><span class="comment">#-Xms2g</span></span><br><span class="line"><span class="comment">#-Xmx2g</span></span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># systemctl start elasticsearch</span></span><br></pre></td></tr></table></figure>
<p>elasticsearch会监听9200(用户访问端口)，9300(集群内通信端口，比如master选举)端口。</p>
<h3 id="elasticsearch的插件"><a href="#elasticsearch的插件" class="headerlink" title="elasticsearch的插件"></a>elasticsearch的插件</h3><h4 id="head插件"><a href="#head插件" class="headerlink" title="head插件"></a>head插件</h4><p>‘<br>插件是为了完成不同的功能，官方提供了一些插件但大部分是收费的，另外也有一些开发爱好者提供的插件，可以实现对elasticsearch集群的状态监控与管理配置等功能。</p>
<p>在elasticsearch 5.x版本以后不再支持直接安装head插件，而是需要通过启动一个服务方式，git地址：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p>
<p><strong>使用docker启动head插件</strong><br>安装docker，并下载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># docker image pull mobz/elasticsearch-head:5</span></span><br></pre></td></tr></table></figure>

<p>修改elasticsearch服务配置文件：<br>开启跨域访问支持，然后重启elasticsearch服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># vi /etc/elasticsearch/elasticsearch.yml</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span></span><br><span class="line">http.cors.allow-origin: <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<p>docker版本启动head插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># docker run --name head -d -p 9100:9100 mobz/elasticsearch-head:5</span></span><br></pre></td></tr></table></figure>

<p>之后在客户端浏览器访问宿主机的9100端口就可以使用mobz/ealasticsearch-head插件管理集群。</p>
<p>Master与Slave的区别：<br>Master的职责：</p>
<ul>
<li>统计各node节点状态信息、集群状态信息统计、索引的创建和删除、索引分配的管理、关闭node节点等</li>
</ul>
<p>Slave的职责：</p>
<ul>
<li>从master同步数据、等待机会成为Master</li>
</ul>
<h4 id="kopf插件"><a href="#kopf插件" class="headerlink" title="kopf插件"></a>kopf插件</h4><p>Git地址为<a href="https://github.com/lmenezes/elasticsearch-kopf，但是目前还不支持5.x版本的elasticsearch，但是可以安装在elasticsearc" target="_blank" rel="noopener">https://github.com/lmenezes/elasticsearch-kopf，但是目前还不支持5.x版本的elasticsearch，但是可以安装在elasticsearc</a> 1.x或2.x的版本安装。</p>
<p>监控elasticsearch集群状态</p>
<p>通过shell命令获取集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment">#  curl -sXGET  http://192.168.34.101:9200/_cluster/health?pretty=true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"myelk"</span>,</span><br><span class="line">  <span class="string">"status"</span> : <span class="string">"green"</span>,</span><br><span class="line">  <span class="string">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"number_of_nodes"</span> : 2,</span><br><span class="line">  <span class="string">"number_of_data_nodes"</span> : 2,</span><br><span class="line">  <span class="string">"active_primary_shards"</span> : 0,</span><br><span class="line">  <span class="string">"active_shards"</span> : 0,</span><br><span class="line">  <span class="string">"relocating_shards"</span> : 0,</span><br><span class="line">  <span class="string">"initializing_shards"</span> : 0,</span><br><span class="line">  <span class="string">"unassigned_shards"</span> : 0,</span><br><span class="line">  <span class="string">"delayed_unassigned_shards"</span> : 0,</span><br><span class="line">  <span class="string">"number_of_pending_tasks"</span> : 0,</span><br><span class="line">  <span class="string">"number_of_in_flight_fetch"</span> : 0,</span><br><span class="line">  <span class="string">"task_max_waiting_in_queue_millis"</span> : 0,</span><br><span class="line">  <span class="string">"active_shards_percent_as_number"</span> : 100.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到的是一个json格式的返回值，那就可以通过python对其中的信息进行分析，例如对status进行分析，如果等于green(绿色)就是运行在正常，等于yellow(黄色)表示副本分片丢失，red(红色)表示主分片丢失</p>
<p>python脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#Author Msq</span></span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import formataddr</span><br><span class="line">import subprocess</span><br><span class="line">body = <span class="string">""</span></span><br><span class="line"><span class="literal">false</span>=<span class="string">"false"</span></span><br><span class="line">obj = subprocess.Popen((<span class="string">"curl -sXGET http://192.168.15.211:9200/_cluster/health?pretty=true"</span>),shell=True, stdout=subprocess.PIPE)</span><br><span class="line">data =  obj.stdout.read()</span><br><span class="line">data1 = <span class="built_in">eval</span>(data)</span><br><span class="line">status = data1.get(<span class="string">"status"</span>)</span><br><span class="line"><span class="keyword">if</span> status == <span class="string">"green"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"50"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"100"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><p>监听9600-9700<br>环境准备，关闭selinux和firewalld，并且安装java环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host3 ~]<span class="comment"># systemctl  stop firewalld</span></span><br><span class="line">[root@linux-host3 ~]<span class="comment"># systemctl  disable  firewalld</span></span><br><span class="line">[root@linux-host3 ~]<span class="comment"># sed -i '/SELINUX/s/enforcing/disabled/' /etc/selinux/config</span></span><br><span class="line">[root@linux-host3 ~]<span class="comment"># yum install  jdk-8u121-linux-x64.rpm</span></span><br><span class="line">[root@linux-host3 ~]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_121"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</span><br><span class="line">[root@linux-host3 ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>

<p>安装logstash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># yum -y install logstash-5.6.13.rpm</span></span><br><span class="line">[root@localhost tools]<span class="comment"># chown  logstash.logstash /usr/share/logstash/data/queue –R #权限更改为logstash用户和组，否则启动的时候日志报错</span></span><br></pre></td></tr></table></figure>

<p><strong>测试logstash</strong><br>测试标准输入和输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># /usr/share/logstash/bin/logstash   -e 'input &#123;  stdin&#123;&#125; &#125; output &#123; stdout&#123;  codec =&gt; rubydebug &#125;&#125;'</span></span><br><span class="line">WARNING: Could not find logstash.yml <span class="built_in">which</span> is typically located <span class="keyword">in</span> <span class="variable">$LS_HOME</span>/config or /etc/logstash. You can specify the path using --path.settings. Continuing using the defaults</span><br><span class="line">Could not find log4j2 configuration at path /usr/share/logstash/config/log4j2.properties. Using default config <span class="built_in">which</span> logs errors to the console</span><br><span class="line">The stdin plugin is now waiting <span class="keyword">for</span> input:</span><br><span class="line">hello world!</span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">          <span class="string">"host"</span> =&gt; <span class="string">"localhost.localdomain"</span>,</span><br><span class="line">    <span class="string">"@timestamp"</span> =&gt; 2019-03-06T14:57:58.006Z,</span><br><span class="line">       <span class="string">"message"</span> =&gt; <span class="string">"hello world!"</span></span><br><span class="line">&#125;</span><br><span class="line">中国强     </span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">          <span class="string">"host"</span> =&gt; <span class="string">"localhost.localdomain"</span>,</span><br><span class="line">    <span class="string">"@timestamp"</span> =&gt; 2019-03-06T14:58:11.958Z,</span><br><span class="line">       <span class="string">"message"</span> =&gt; <span class="string">"中国强"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出到文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># /usr/share/logstash/bin/logstash   -e 'put &#123;  stdin&#123;&#125; &#125; output &#123; file &#123; path =&gt; "/tmp/log-%&#123;+YYYY.MM.dd&#125;messages.gz"&#125;&#125;'</span></span><br><span class="line">WARNING: Could not find logstash.yml <span class="built_in">which</span> is typically located <span class="keyword">in</span> <span class="variable">$LS_HOME</span>/config or /etc/logstash. You can specify the path using --path.settings. Continuing using the defaults</span><br><span class="line">Could not find log4j2 configuration at path /usr/share/logstash/config/log4j2.properties. Using default config <span class="built_in">which</span> logs errors to the console</span><br><span class="line">The stdin plugin is now waiting <span class="keyword">for</span> input:</span><br><span class="line">这是一个测试</span><br><span class="line">^C[root@localhost tools]<span class="comment"># cat /tmp/log-2019.03.06messages.gz </span></span><br><span class="line">&#123;<span class="string">"@version"</span>:<span class="string">"1"</span>,<span class="string">"host"</span>:<span class="string">"localhost.localdomain"</span>,<span class="string">"@timestamp"</span>:<span class="string">"2019-03-06T15:00:28.838Z"</span>,<span class="string">"message"</span>:<span class="string">"这是一个测试"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出到elasticsearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># /usr/share/logstash/bin/logstash   -e 'input &#123;  stdin&#123;&#125; &#125; output &#123; elasticsearch &#123;hosts =&gt; ["192.168.34.100:9200"] index =&gt; "mytest-%&#123;+YYYY.MM.dd&#125;" &#125;&#125;'</span></span><br><span class="line">WARNING: Could not find logstash.yml <span class="built_in">which</span> is typically located <span class="keyword">in</span> <span class="variable">$LS_HOME</span>/config or /etc/logstash. You can specify the path using --path.settings. Continuing using the defaults</span><br><span class="line">Could not find log4j2 configuration at path /usr/share/logstash/config/log4j2.properties. Using default config <span class="built_in">which</span> logs errors to the console</span><br><span class="line">zThe stdin plugin is now waiting <span class="keyword">for</span> input:                      这是一个测试</span><br></pre></td></tr></table></figure>

<p>elasticsearch服务器验证收到数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># ll /data/esdata/nodes/0/indices/</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 8 elasticsearch elasticsearch 65 Mar  6 23:03 kr-hxCstTfCk_v2wI9QsAw</span><br></pre></td></tr></table></figure>

<h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><p>监听5601端口<br>安装配置kibana</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># yum -y install kibana-5.3.0-x86_64.rpm</span></span><br><span class="line">[root@localhost tools]<span class="comment"># grep "^[a-Z]" /etc/kibana/kibana.yml </span></span><br><span class="line">server.port: 5601 <span class="comment">#监听端口</span></span><br><span class="line">server.host: <span class="string">"0.0.0.0"</span> <span class="comment">#监听地址</span></span><br><span class="line">server.name: <span class="string">"mykibana"</span> <span class="comment">#名称</span></span><br><span class="line">elasticsearch.url: <span class="string">"http://192.168.34.100:9200"</span> <span class="comment">#elasticsearch服务器地址</span></span><br></pre></td></tr></table></figure>

<p>启动kibana服务并验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost tools]<span class="comment"># systemctl  start kibana</span></span><br><span class="line">[root@localhost tools]<span class="comment"># systemctl  enable  kibana</span></span><br><span class="line">[root@localhost tools]<span class="comment"># ss -tnl | grep 5601</span></span><br></pre></td></tr></table></figure>

<p>在客户端浏览器访问该页面就可以使用kibana。<br>如果默认没有显示柱状的图，可能是最近没有写入新的数据，可以查看较长日期当中的数据或者通过logstash新写入数据即可。</p>
<h3 id="通过logstash收集日志"><a href="#通过logstash收集日志" class="headerlink" title="通过logstash收集日志"></a>通过logstash收集日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost conf.d]<span class="comment"># cat system-log.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"messagelog"</span></span><br><span class="line">    path =&gt; <span class="string">"/var/log/messages"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    stat_interval =&gt; <span class="string">"3"</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"securelog"</span></span><br><span class="line">    path =&gt; <span class="string">"/var/log/secure"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    stat_interval =&gt; <span class="string">"3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"messagelog"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; <span class="string">"192.168.34.100:9200"</span></span><br><span class="line">      index =&gt; <span class="string">"messagelog-100-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"securelog"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; <span class="string">"192.168.34.101:9200"</span></span><br><span class="line">      index =&gt; <span class="string">"securelog-101-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过logtsash收集tomcat和java日志"><a href="#通过logtsash收集tomcat和java日志" class="headerlink" title="通过logtsash收集tomcat和java日志"></a>通过logtsash收集tomcat和java日志</h3><p>配置安装java环境，并自定义一个web界面进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host6 ~]<span class="comment"># yum install jdk-8u121-linux-x64.rpm</span></span><br><span class="line">[root@linux-host6 ~]<span class="comment"># cd  /usr/local/src/</span></span><br><span class="line">[root@linux-host6 src]<span class="comment"># tar xvf apache-tomcat-8.0.38.tar.gz </span></span><br><span class="line">[root@linux-host6 src]<span class="comment"># ln -sv /usr/local/src/apache-tomcat-8.0.38 /usr/local/tomcat </span></span><br><span class="line">‘/usr/<span class="built_in">local</span>/tomcat’ -&gt; ‘/usr/<span class="built_in">local</span>/src/apache-tomcat-8.0.38’</span><br><span class="line">[root@linux-host6 tomcat]<span class="comment"># cd /usr/local/tomcat/webapps/ </span></span><br><span class="line">[root@linux-host6 webapps]<span class="comment">#mkdir /usr/local/tomcat/webapps/webdir </span></span><br><span class="line">[root@linux-host6 webapps]<span class="comment"># echo "Tomcat Page" &gt; /usr/local/tomcat/webapps/webdir/index.html </span></span><br><span class="line">[root@linux-host6 webapps]<span class="comment"># ../bin/catalina.sh  start</span></span><br><span class="line">[root@linux-host6 webapps]<span class="comment"># ss -tnl | grep 8080</span></span><br><span class="line">LISTEN     0      100         :::8080                    :::*</span><br></pre></td></tr></table></figure>
<p>确认tomcat可以正常访问。</p>
<p>将tomcat日志转json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 tomcat]<span class="comment"># vi conf/server.xml</span></span><br><span class="line">...</span><br><span class="line">&lt;Host name=<span class="string">"localhost"</span>  appBase=<span class="string">"webapps"</span></span><br><span class="line">            unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">	 &lt;Valve className=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> directory=<span class="string">"logs"</span></span><br><span class="line">	               prefix=<span class="string">"tomcat_access_log"</span> suffix=<span class="string">".log"</span></span><br><span class="line">	               pattern=<span class="string">"&#123;&amp;quot;clientip&amp;quot;:&amp;quot;%h&amp;quot;,&amp;quot;ClientUser&amp;quot;:&amp;quot;%l&amp;quot;,&amp;quot;authenticated&amp;quot;:&amp;quot;%u&amp;quot;,&amp;quot;AccessTime&amp;quot;:&amp;quot;%t&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;%r&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;%s&amp;quot;,&amp;quot;SendBytes&amp;quot;:&amp;quot;%b&amp;quot;,&amp;quot;Query?string&amp;quot;:&amp;quot;%q&amp;quot;,&amp;quot;partner&amp;quot;:&amp;quot;%&#123;Referer&#125;i&amp;quot;,&amp;quot;AgentVersion&amp;quot;:&amp;quot;%&#123;User-Agent&#125;i&amp;quot;&#125;"</span>/&gt; </span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>
<p>重启tomcat。</p>
<p>在tomcat主机安装logstash并编辑配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 logs]<span class="comment"># cat /etc/logstash/conf.d/tomcat.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/usr/local/tomcat/logs/catalina.out"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    stat_interval =&gt; 3</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"tomcatlog"</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/usr/local/tomcat/logs/tomcat_access_log.*.log"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    stat_interval =&gt; 3</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"accesslog"</span></span><br><span class="line">    codec =&gt; <span class="string">"json"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tomcatlog"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; <span class="string">"192.168.34.100:9200"</span></span><br><span class="line">      index =&gt; <span class="string">"tomcat-102-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"accesslog"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; <span class="string">"192.168.34.101:9200"</span></span><br><span class="line">      index =&gt; <span class="string">"logstash-tomcat-accesslog-102-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动logstash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># systemctl start logstash</span></span><br></pre></td></tr></table></figure>
<p>然后在kibana加入响应索引即可收集tomcat的访问日志。</p>
<p>关于sincedb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># cat /var/lib/logstash/plugins/inputs/file/.sincedb_19224e5b5b842ee829563544811600e0 </span></span><br><span class="line">0 0 0 0</span><br><span class="line">34905429 0 64768 11370</span><br></pre></td></tr></table></figure>
<p>记录了手机文件的inode信息。</p>
<h3 id="通过logstash收集java日志"><a href="#通过logstash收集java日志" class="headerlink" title="通过logstash收集java日志"></a>通过logstash收集java日志</h3><p>使用codec的multiline插件实现多行匹配，这是一个可以将多行进行合并的插件，而且可以使用what指定将匹配到的行与前面的行合并还是和后面的行合并，<a href="https://www.elastic.co/guide/en/logstash/current/plugins-codecs-multiline.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-codecs-multiline.html</a></p>
<p>在服务器部署logstash并生成测试文件进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        stdin &#123;</span><br><span class="line">        codec =&gt; multiline &#123;</span><br><span class="line">        pattern =&gt; <span class="string">"^\["</span> <span class="comment">#当遇到[开头的行时候将多行进行合并</span></span><br><span class="line">        negate =&gt; <span class="literal">true</span>  <span class="comment">#true为匹配成功进行操作，false为不成功进行操作</span></span><br><span class="line">        what =&gt; <span class="string">"previous"</span>  <span class="comment">#与上面的行合并，如果是下面的行合并就是next</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123; <span class="comment">#日志过滤，如果所有的日志都过滤就写这里，如果只针对某一个过滤就写在input里面的日志输入里面</span></span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">        stdout &#123;</span><br><span class="line">        codec =&gt; rubydebug</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>配置读取日志文件并将输出改为elasticsearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># cat java.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/elk/logs/ELK-Cluster.log"</span></span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"javalog"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    codec =&gt; multiline &#123;</span><br><span class="line">      pattern =&gt; <span class="string">"^\["</span></span><br><span class="line">      negate =&gt; <span class="literal">true</span></span><br><span class="line">      what =&gt; <span class="string">"previous"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"javalog"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [<span class="string">"192.168.34.100:9200"</span>]</span><br><span class="line">      index =&gt; <span class="string">"javalog-javalog-102-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重启一下elasticsearch服务，以生成新的日志，验证logstash能否自动收集新生成的日志。<br>然后配置kibana，创建新的索引，就可以浏览收集的日志。</p>
<h3 id="通过logstash收集nginx的访问日志"><a href="#通过logstash收集nginx的访问日志" class="headerlink" title="通过logstash收集nginx的访问日志"></a>通过logstash收集nginx的访问日志</h3><p>部署nginx服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host6 ~]<span class="comment"># yum install gcc gcc-c++ automake pcre pcre-devel zlip zlib-devel openssl openssl-devel</span></span><br><span class="line">[root@linux-host6 ~]<span class="comment"># cd /usr/local/src/</span></span><br><span class="line">[root@linux-host6 src]<span class="comment"># wget http://nginx.org/download/nginx-1.10.3.tar.gz</span></span><br><span class="line">[root@linux-host6 src]<span class="comment"># tar xvf  nginx-1.10.3.tar.gz</span></span><br><span class="line">[root@linux-host6 src]<span class="comment"># cd nginx-1.10.3</span></span><br><span class="line">[root@linux-host6 nginx-1.10.3]<span class="comment"># ./configure  --prefix=/usr/local/nginx-1.10.3</span></span><br><span class="line">[root@linux-host6 nginx-1.10.3]<span class="comment"># make &amp;&amp; make install</span></span><br><span class="line">[root@linux-host6 nginx-1.10.3]<span class="comment"># ln -sv /usr/local/nginx-1.10.3 /usr/local/nginx</span></span><br><span class="line">‘/usr/<span class="built_in">local</span>/nginx’ -&gt; ‘/usr/<span class="built_in">local</span>/nginx-1.10.3’</span><br></pre></td></tr></table></figure>
<p>编辑配置文件并准备web页面</p>
<p>将nginx的访问日志转为json格式</p>
<p>将nginx的访问日志转为json格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># vi /etc/nginx/nginx.conf</span></span><br><span class="line">http&#123;</span><br><span class="line">	...</span><br><span class="line">	log_format access_json <span class="string">'&#123;"@timestamp":"$time_iso8601",'</span></span><br><span class="line">	        <span class="string">'"host":"$server_addr",'</span></span><br><span class="line">	        <span class="string">'"clientip":"$remote_addr",'</span></span><br><span class="line">	        <span class="string">'"size":$body_bytes_sent,'</span></span><br><span class="line">	        <span class="string">'"responsetime":$request_time,'</span></span><br><span class="line">	        <span class="string">'"upstreamtime":"$upstream_response_time",'</span></span><br><span class="line">	        <span class="string">'"upstreamhost":"$upstream_addr",'</span></span><br><span class="line">	        <span class="string">'"http_host":"$host",'</span></span><br><span class="line">	        <span class="string">'"url":"$uri",'</span></span><br><span class="line">	        <span class="string">'"domain":"$host",'</span></span><br><span class="line">	        <span class="string">'"xff":"$http_x_forwarded_for",'</span></span><br><span class="line">	        <span class="string">'"referer":"$http_referer",'</span></span><br><span class="line">	        <span class="string">'"status":"$status"&#125;'</span>;</span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  access_json;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置logstash收集nginx日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># pwd</span></span><br><span class="line">/etc/logstash/conf.d</span><br><span class="line">[root@node02 conf.d]<span class="comment"># cat nginx.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/var/log/nginx/access.log"</span></span><br><span class="line">    start_position =&gt; <span class="string">"end"</span></span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"end"</span></span><br><span class="line">    codec =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; <span class="string">"192.168.34.100:9200"</span></span><br><span class="line">    index =&gt; <span class="string">"logstash-nginx-accesslog-102-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过logstash收集TCP-UDP日志"><a href="#通过logstash收集TCP-UDP日志" class="headerlink" title="通过logstash收集TCP/UDP日志"></a>通过logstash收集TCP/UDP日志</h3><p>通过logstash的tcp/udp插件收集日志，通常用于在向elasticsearch日志补录丢失的部分日志，可以将丢失的日志写到一个文件，然后通过TCP日志收集方式直接发送给logstash然后再写入到elasticsearch服务器。<br><a href="https://www.elastic.co/guide/en/logstash/5.6/input-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/5.6/input-plugins.html</a></p>
<p>编辑logstash配置文件，进行日志收集测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># cat tcp.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 9889</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"tcplog"</span></span><br><span class="line">    mode =&gt; <span class="string">"server"</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时端口9889处于监听状态，在其他服务器安装nc命令用于测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># yum -y install nc</span></span><br><span class="line">[root@node01 ~]<span class="comment"># echo "nc test" | nc 192.168.34.102 9889</span></span><br><span class="line">[root@node01 ~]<span class="comment">#  nc 192.168.15.16 9889 &lt; /etc/passwd</span></span><br></pre></td></tr></table></figure>

<p>通过nc发送一个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 192.168.15.16 9889 &lt; /etc/passwd</span><br></pre></td></tr></table></figure>

<p><strong>通过伪设备的方式发送消息</strong><br>在类Unix操作系统中，块设备有硬盘、内存的硬件，但是还有设备节点并不一定要对应物理设备，我们把没有这种对应关系的设备是伪设备，比如/dev/null，/dev/zero，/dev/random以及/dev/tcp和/dev/upd等，Linux操作系统使用这些伪设备提供了多种不通的功能，tcp通信只是dev下面众多伪设备当中的一种设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host1 ~]<span class="comment"># echo "伪设备"  &gt; /dev/tcp/192.168.15.16/9889</span></span><br></pre></td></tr></table></figure>

<p>将输出改为elasticsearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># cat tcp.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 9889</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"tcplog"</span></span><br><span class="line">    mode =&gt; <span class="string">"server"</span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; <span class="string">"192.168.34.100:9200"</span></span><br><span class="line">    index =&gt; <span class="string">"logstash-tcplog-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在kibana添加索引就可以查看收集的tcp日志</p>
<h3 id="通过rsyslog收集haproxy日志"><a href="#通过rsyslog收集haproxy日志" class="headerlink" title="通过rsyslog收集haproxy日志"></a>通过rsyslog收集haproxy日志</h3><p>在centos 6及之前的版本叫做syslog，centos 7开始叫做rsyslog，根据官方的介绍，rsyslog(2013年版本)可以达到每秒转发百万条日志的级别，官方网址：<a href="http://www.rsyslog.com/，确认系统安装的版本命令如下：" target="_blank" rel="noopener">http://www.rsyslog.com/，确认系统安装的版本命令如下：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># rpm -q rsyslog</span></span><br><span class="line">rsyslog-8.24.0-16.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>编辑haproxy和rsyslog的配置文件生成haproxy日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># vi /etc/haproxy/haproxy.cfg </span></span><br><span class="line">global</span><br><span class="line">	<span class="built_in">log</span> 127.0.0.1 local2 info</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 rsyslog.d]<span class="comment"># vi haproxy.conf</span></span><br><span class="line"><span class="variable">$ModLoad</span> imudp</span><br><span class="line"><span class="variable">$UDPServerRun</span> 514</span><br><span class="line"></span><br><span class="line"><span class="variable">$ModLoad</span> imtcp</span><br><span class="line"><span class="variable">$InputTCPServerRun</span> 514</span><br><span class="line"></span><br><span class="line">local2.* /var/<span class="built_in">log</span>/haproxy.log</span><br><span class="line">local2.* @@192.168.34.102:516</span><br></pre></td></tr></table></figure>
<p>之后重启haproxy和rsyslog，确保正常启动。</p>
<p>编辑logstash配置文件<br>将收集收集并传输至elasticsearch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># pwd</span></span><br><span class="line">/etc/logstash/conf.d</span><br><span class="line">[root@node02 conf.d]<span class="comment"># cat haproxy.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  syslog &#123;</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"system-rsyslog"</span></span><br><span class="line">    port =&gt; <span class="string">"516"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"192.168.34.100:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"logstash-rsyslog-haproxy-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在kibana计收入索引即可将haproxy的日志加入ELK。</p>
<h3 id="logstash收集日志并写入redis"><a href="#logstash收集日志并写入redis" class="headerlink" title="logstash收集日志并写入redis"></a>logstash收集日志并写入redis</h3><p>用一台服务器安装部署redis服务，专门用于写入日志缓存使用，用于web服务器产生大量日志的场景。<br>部署如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host2 ~]<span class="comment"># cd /usr/local/src/</span></span><br><span class="line">[root@linux-host2 src]<span class="comment"># wget http://download.redis.io/releases/redis-3.2.8.tar.gz</span></span><br><span class="line">[root@linux-host2 src]<span class="comment"># tar  xvf redis-3.2.8.tar.gz</span></span><br><span class="line">[root@linux-host2 src]<span class="comment"># ln -sv /usr/local/src/redis-3.2.8 /usr/local/redis</span></span><br><span class="line">‘/usr/<span class="built_in">local</span>/redis’ -&gt; ‘/usr/<span class="built_in">local</span>/src/redis-3.2.8’</span><br><span class="line">[root@linux-host2 src]<span class="comment">#cd  /usr/local/redis/deps</span></span><br><span class="line">[root@linux-host2 redis]<span class="comment"># yum install gcc</span></span><br><span class="line">[root@linux-host2 deps]<span class="comment"># make geohash-int hiredis jemalloc linenoise lua</span></span><br><span class="line">[root@linux-host2 deps]<span class="comment"># cd ..</span></span><br><span class="line">[root@linux-host2 redis]<span class="comment"># make</span></span><br><span class="line">[root@linux-host2 redis]<span class="comment"># vim  redis.conf</span></span><br><span class="line">[root@linux-host2 redis]<span class="comment"># grep "^[a-Z]" redis.conf  #主要改动的地方</span></span><br><span class="line">[root@node01 ~]<span class="comment"># grep "^[a-Z]" /etc/redis.conf </span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">protected-mode yes</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">loglevel notice</span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/redis.log</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression no</span><br><span class="line">rdbchecksum no</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir /var/lib/redis</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly no</span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-entries 512</span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line"><span class="built_in">set</span>-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>

<p>启动redis并设置访问密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># redis-cli -h 127.0.0.1</span></span><br><span class="line">127.0.0.1:6379&gt;  CONFIG SET requirepass 123456 <span class="comment">#安全起见，生产环境中redis必须设置密码，或者在配置文件中设置：requirepass  123456 #redis.conf配置文件</span></span><br></pre></td></tr></table></figure>

<p><strong>将logstash收集的日志写入redis</strong><br>将tomcat服务器的logstash收集之后的tomcat 访问日志写入到redis服务器，然后通过另外的logstash将redis服务器的数据取出在写入到elasticsearch服务器。<br>官方文档：<a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-redis.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-outputs-redis.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 conf.d]<span class="comment"># cat tomcat_tcp.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/usr/local/tomcat/logs/tomcat_access_log.*.log"</span></span><br><span class="line">    start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    stat_interval =&gt; 3</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"accesslog"</span></span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 516</span><br><span class="line">    mode =&gt; <span class="string">"server"</span></span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">"tcplog-102"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"accesslog"</span> &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">      data_type =&gt; <span class="string">"list"</span></span><br><span class="line">      key =&gt; <span class="string">"tomcat-accesslog-102"</span></span><br><span class="line">      host =&gt; <span class="string">"192.168.34.101"</span></span><br><span class="line">      port =&gt; <span class="string">"6379"</span></span><br><span class="line">      db =&gt; <span class="string">"0"</span></span><br><span class="line">      password =&gt; <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tcplog-102"</span> &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">      data_type =&gt; <span class="string">"list"</span></span><br><span class="line">      key =&gt; <span class="string">"tcplog-102"</span></span><br><span class="line">      host =&gt; <span class="string">"192.168.34.101"</span></span><br><span class="line">      port =&gt; <span class="string">"6379"</span></span><br><span class="line">      db =&gt; <span class="string">"1"</span></span><br><span class="line">      password =&gt; <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置其他logstash服务器从redis读取数据</strong><br>配置专门logstash服务器从redis读取指定的key的数据，并写入到elasticsearch。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 conf.d]<span class="comment"># cat redis-es.conf </span></span><br><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    data_type =&gt; <span class="string">"list"</span></span><br><span class="line">    key =&gt; <span class="string">"tomcat-accesslog-102"</span></span><br><span class="line">    host =&gt; <span class="string">"192.168.34.101"</span></span><br><span class="line">    port =&gt; <span class="string">"6379"</span></span><br><span class="line">    db =&gt; <span class="string">"0"</span></span><br><span class="line">    password =&gt; <span class="string">"123456"</span></span><br><span class="line">    codec =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redis &#123;</span><br><span class="line">    data_type =&gt; <span class="string">"list"</span></span><br><span class="line">    key =&gt; <span class="string">"tcplog-102"</span></span><br><span class="line">    host =&gt; <span class="string">"192.168.34.101"</span></span><br><span class="line">    port =&gt; <span class="string">"6379"</span></span><br><span class="line">    db =&gt; <span class="string">"1"</span></span><br><span class="line">    password =&gt; <span class="string">"123456"</span></span><br><span class="line">    codec =&gt; <span class="string">"json"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tomcat-accesslog-102"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; <span class="string">"192.168.34.100:9200"</span></span><br><span class="line">      index =&gt; <span class="string">"redis-tomcat-102-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">"tcplog-102"</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; <span class="string">"192.168.34.100:9200"</span></span><br><span class="line">      index =&gt; <span class="string">"redis-tcplog-102-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，在kibana上添加指定的索引即可看到该数据。</p>
<h3 id="logstash收集日志并写入kafka"><a href="#logstash收集日志并写入kafka" class="headerlink" title="logstash收集日志并写入kafka"></a>logstash收集日志并写入kafka</h3><p>kafka可以结合zookeeper更方便的实现扩容。<br>kafka将数据存放在分布式的存储系统zookeeper内，<br>安装kafka<br>Broker<br>Kafka集群包含一个或多个服务器，这种服务器被称为broker</p>
<p>Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic。（物理上不同topic的消息分开存储，逻辑上一个topic的消息虽然保存于一个或多个broker上但用户只需指定消息的topic即可生产或消费数据而不必关心数据存于何处）</p>
<p>Partition<br>parition是物理上的概念，每个topic包含一个或多个partition，创建topic时可指定parition数量。每个partition对应于一个文件夹，该文件夹下存储该partition的数据和索引文件</p>
<p>Producer<br>负责发布消息到Kafka broker</p>
<p>Consumer<br>消费消息。每个consumer属于一个特定的consuer group（可为每个consumer指定group name，若不指定group name则属于默认的group）。使用consumer high level API时，同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。</p>
<p>在三台服务器上分别安装启动kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@linux-host1 src]<span class="comment"># tar xvf kafka_2.11-1.0.0.tgz</span></span><br><span class="line">[root@linux-host1 src]<span class="comment"># ln -sv /usr/local/src/kafka_2.11-1.0.0 /usr/local/kafka</span></span><br><span class="line">[root@linux-host1 src]<span class="comment"># vim /usr/local/kafka/config/server.properties</span></span><br><span class="line">21 broker.id=1  <span class="comment">#设置每个代理全局唯一的整数ID</span></span><br><span class="line">31 listeners=PLAINTEXT://192.168.15.211:9092</span><br><span class="line">103 log.retention.hours=24  <span class="comment">#保留指定小时的日志内容</span></span><br><span class="line">123 zookeeper.connect=192.168.15.211:2181,192.168.15.212:2181,192.168.15.213:2181 <span class="comment">#所有的zookeeper地址</span></span><br></pre></td></tr></table></figure>
<p>启动kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># /usr/local/kafka/bin/kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties  #以守护进程的方式启动</span></span><br></pre></td></tr></table></figure>

<p>测试kafka</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># jps</span></span><br><span class="line">4789 Kafka</span><br><span class="line">1383 QuorumPeerMain</span><br><span class="line">5147 Jps</span><br></pre></td></tr></table></figure>

<p><strong>测试创建topic</strong><br>创建名为logstashtest，partitions(分区)为3，replication(复制)为3的topic(主题)：<br>在任意kafaka服务器操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34102:2181 --partitions 3 --replication-factor 3 --topic logstashtest</span></span><br></pre></td></tr></table></figure>

<p><strong>测试获取topic</strong><br>可以在任意一台kafka服务器上进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --describe --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181 --topic logstashtest</span></span><br><span class="line">Topic:logstashtest	PartitionCount:3	ReplicationFactor:3	Configs:</span><br><span class="line">	Topic: logstashtest	Partition: 0	Leader: 3	Replicas: 3,2,1	Isr: 3,2,1</span><br><span class="line">	Topic: logstashtest	Partition: 1	Leader: 1	Replicas: 1,3,2	Isr: 1,3,2</span><br><span class="line">	Topic: logstashtest	Partition: 2	Leader: 2	Replicas: 2,1,3	Isr: 2,1,3</span><br></pre></td></tr></table></figure>
<p>状态说明：logstashtest有三个分区分别为0、1、2，分区0的leader是3（broker.id），分区0有三个副本，并且状态都为lsr（ln-sync，表示可以参加选举成为leader）。</p>
<p><strong>删除指定topic</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --delete --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34102:2181 --topic logstashtest</span></span><br><span class="line">Topic logstashtest is marked <span class="keyword">for</span> deletion.</span><br><span class="line">Note: This will have no impact <span class="keyword">if</span> delete.topic.enable is not <span class="built_in">set</span> to <span class="literal">true</span>.</span><br></pre></td></tr></table></figure>

<p><strong>获取所有topic</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --list --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181</span></span><br></pre></td></tr></table></figure>

<h3 id="kafka命令测试消息发送"><a href="#kafka命令测试消息发送" class="headerlink" title="kafka命令测试消息发送"></a>kafka命令测试消息发送</h3><p>创建topic</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-topics.sh --create --zookeeper 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181 --partitions 3 --replication-factor 3 --topic messagetest</span></span><br><span class="line">Created topic <span class="string">"messagetest"</span>.</span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-console-producer.sh --broker-list 192.168.34.100:9092,192.168.34.101:9092,192.168.34.102:9092 --topic messagetest</span></span><br><span class="line">&gt;hello</span><br><span class="line">&gt;kafka</span><br><span class="line">&gt;logstash</span><br><span class="line">&gt;ss</span><br><span class="line">&gt;oo</span><br><span class="line">&gt;start</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>在其他kafka服务器测试数据获取</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># kafka/bin/kafka-console-consumer.sh  --bootstrap-server 192.168.34.100:2181,192.168.34.101:2181,192.168.34.102:2181 --topic messagetest --from-beginning</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ELK</tag>
        <tag>日志收集分析</tag>
        <tag>kafka</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM使用心得</title>
    <url>/2018/07/20/kvm/</url>
    <content><![CDATA[<h2 id="虚拟化技术基础"><a href="#虚拟化技术基础" class="headerlink" title="虚拟化技术基础"></a>虚拟化技术基础</h2><p>内存地址</p>
<ul>
<li>虚拟地址</li>
<li>物理地址</li>
</ul>
<p>时序复用，将时间进行切片，如果每5毫秒为一份，则再某一程序执行5毫秒后，不管程序是否执行完，cpu都会切换到处理下一个程序，如果该程序没处理完，则等到下一次轮询到该程序时，再接着处理。</p>
<p>空间复用，将物理内存切片，拿出处理当前进程所需要的N片分配。</p>
<h3 id="tcp-ip协议栈"><a href="#tcp-ip协议栈" class="headerlink" title="tcp/ip协议栈"></a>tcp/ip协议栈</h3><h4 id="使用ip-netns创建新的名称空间充当路由器"><a href="#使用ip-netns创建新的名称空间充当路由器" class="headerlink" title="使用ip netns创建新的名称空间充当路由器"></a>使用ip netns创建新的名称空间充当路由器</h4><p>ip netns 命令详解 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns help</span></span><br><span class="line">Usage: ip netns list <span class="comment">#列出当前网络名称空间</span></span><br><span class="line">       ip netns add NAME <span class="comment">#创建网络名称空间</span></span><br><span class="line">       ip netns <span class="built_in">set</span> NAME NETNSID </span><br><span class="line">       ip [-all] netns delete [NAME]</span><br><span class="line">       ip netns identify [PID]</span><br><span class="line">       ip netns pids NAME</span><br><span class="line">       ip [-all] netns <span class="built_in">exec</span> [NAME] cmd ... <span class="comment">#在名称空间上执行shell命令</span></span><br><span class="line">       ip netns monitor</span><br><span class="line">       ip netns list-id</span><br></pre></td></tr></table></figure>

<p><strong>用网络名称空间模拟路由器使用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns list</span></span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns add router1 </span></span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns list</span></span><br><span class="line">router1</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ifconfig -a</span></span><br><span class="line">lo: flags=8&lt;LOOPBACK&gt;  mtu 65536</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ifconfig lo 127.0.0.1/8 up</span></span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ifconfig</span></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">[root@node01 ~]<span class="comment">#cat /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">0</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 cat /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">0</span><br><span class="line">[root@node01 ~]<span class="comment">#echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cat /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">1</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 cat /proc/sys/net/ipv4/ip_forward</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>由以上操作可知，router1是与宿主机名称空间完全隔离的一个路由器，即使用ip netns命令，可以实现主机上的虚拟机之间通信的功能。</p>
<h4 id="使用brctl管理软交换机"><a href="#使用brctl管理软交换机" class="headerlink" title="使用brctl管理软交换机"></a>使用brctl管理软交换机</h4><p>brctl命令详解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#brctl -h</span></span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line">	addbr     	&lt;bridge&gt;		add bridge <span class="comment">#创建软交换机</span></span><br><span class="line">	delbr     	&lt;bridge&gt;		delete bridge <span class="comment">#删除软交换机</span></span><br><span class="line">	addif     	&lt;bridge&gt; &lt;device&gt;	add interface to bridge</span><br><span class="line">	delif     	&lt;bridge&gt; &lt;device&gt;	delete interface from bridge</span><br><span class="line">	hairpin   	&lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;	turn hairpin on/off</span><br><span class="line">	setageing 	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> ageing time</span><br><span class="line">	setbridgeprio	&lt;bridge&gt; &lt;prio&gt;		<span class="built_in">set</span> bridge priority</span><br><span class="line">	setfd     	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> bridge forward delay</span><br><span class="line">	sethello  	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> hello time</span><br><span class="line">	setmaxage 	&lt;bridge&gt; &lt;time&gt;		<span class="built_in">set</span> max message age</span><br><span class="line">	setpathcost	&lt;bridge&gt; &lt;port&gt; &lt;cost&gt;	<span class="built_in">set</span> path cost</span><br><span class="line">	setportprio	&lt;bridge&gt; &lt;port&gt; &lt;prio&gt;	<span class="built_in">set</span> port priority</span><br><span class="line">	show      	[ &lt;bridge&gt; ]		show a list of bridges <span class="comment">#列出软交换机，即桥</span></span><br><span class="line">	showmacs  	&lt;bridge&gt;		show a list of mac addrs</span><br><span class="line">	showstp   	&lt;bridge&gt;		show bridge stp info</span><br><span class="line">	stp       	&lt;bridge&gt; &#123;on|off&#125;	turn stp on/off</span><br></pre></td></tr></table></figure>
<p>brctl命令使用演示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#brctl show</span></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">[root@node01 ~]<span class="comment">#brctl addbr br0</span></span><br><span class="line">[root@node01 ~]<span class="comment">#brctl show</span></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">br0		8000.000000000000	no</span><br></pre></td></tr></table></figure>

<p><strong>使用ip link创建虚拟网卡</strong><br>ip link命令详解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip link help</span></span><br><span class="line">Usage: ip link add [link DEV] [ name ] NAME</span><br><span class="line">                   [ txqueuelen PACKETS ]</span><br><span class="line">                   [ address LLADDR ]</span><br><span class="line">                   [ broadcast LLADDR ]</span><br><span class="line">                   [ mtu MTU ] [index IDX ]</span><br><span class="line">                   [ numtxqueues QUEUE_COUNT ]</span><br><span class="line">                   [ numrxqueues QUEUE_COUNT ]</span><br><span class="line">                   <span class="built_in">type</span> TYPE [ ARGS ]</span><br><span class="line"></span><br><span class="line">       ip link delete &#123; DEVICE | dev DEVICE | group DEVGROUP &#125; <span class="built_in">type</span> TYPE [ ARGS ]</span><br><span class="line"></span><br><span class="line">       ip link <span class="built_in">set</span> &#123; DEVICE | dev DEVICE | group DEVGROUP &#125;</span><br><span class="line">	                  [ &#123; up | down &#125; ]</span><br><span class="line">	                  [ <span class="built_in">type</span> TYPE ARGS ]</span><br><span class="line">	                  [ arp &#123; on | off &#125; ]</span><br><span class="line">	                  [ dynamic &#123; on | off &#125; ]</span><br><span class="line">	                  [ multicast &#123; on | off &#125; ]</span><br><span class="line">	                  [ allmulticast &#123; on | off &#125; ]</span><br><span class="line">	                  [ promisc &#123; on | off &#125; ]</span><br><span class="line">	                  [ trailers &#123; on | off &#125; ]</span><br><span class="line">	                  [ carrier &#123; on | off &#125; ]</span><br><span class="line">	                  [ txqueuelen PACKETS ]</span><br><span class="line">	                  [ name NEWNAME ]</span><br><span class="line">	                  [ address LLADDR ]</span><br><span class="line">	                  [ broadcast LLADDR ]</span><br><span class="line">	                  [ mtu MTU ]</span><br><span class="line">	                  [ netns &#123; PID | NAME &#125; ]</span><br><span class="line">	                  [ link-netnsid ID ]</span><br><span class="line">			  [ <span class="built_in">alias</span> NAME ]</span><br><span class="line">	                  [ vf NUM [ mac LLADDR ]</span><br><span class="line">				   [ vlan VLANID [ qos VLAN-QOS ] [ proto VLAN-PROTO ] ]</span><br><span class="line">				   [ rate TXRATE ]</span><br><span class="line">				   [ max_tx_rate TXRATE ]</span><br><span class="line">				   [ min_tx_rate TXRATE ]</span><br><span class="line">				   [ spoofchk &#123; on | off&#125; ]</span><br><span class="line">				   [ query_rss &#123; on | off&#125; ]</span><br><span class="line">				   [ state &#123; auto | <span class="built_in">enable</span> | <span class="built_in">disable</span>&#125; ] ]</span><br><span class="line">				   [ trust &#123; on | off&#125; ] ]</span><br><span class="line">				   [ node_guid &#123; eui64 &#125; ]</span><br><span class="line">				   [ port_guid &#123; eui64 &#125; ]</span><br><span class="line">			  [ xdp &#123; off |</span><br><span class="line">				  object FILE [ section NAME ] [ verbose ] |</span><br><span class="line">				  pinned FILE &#125; ]</span><br><span class="line">			  [ master DEVICE ][ vrf NAME ]</span><br><span class="line">			  [ nomaster ]</span><br><span class="line">			  [ addrgenmode &#123; eui64 | none | stable_secret | random &#125; ]</span><br><span class="line">	                  [ protodown &#123; on | off &#125; ]</span><br><span class="line"></span><br><span class="line">       ip link show [ DEVICE | group GROUP ] [up] [master DEV] [vrf NAME] [<span class="built_in">type</span> TYPE]</span><br><span class="line"></span><br><span class="line">       ip link xstats <span class="built_in">type</span> TYPE [ ARGS ]</span><br><span class="line"></span><br><span class="line">       ip link afstats [ dev DEVICE ]</span><br><span class="line"></span><br><span class="line">       ip link <span class="built_in">help</span> [ TYPE ]</span><br><span class="line"></span><br><span class="line">TYPE := &#123; vlan | veth | vcan | dummy | ifb | macvlan | macvtap |</span><br><span class="line">          bridge | bond | team | ipoib | ip6tnl | ipip | sit | vxlan |</span><br><span class="line">          gre | gretap | ip6gre | ip6gretap | vti | nlmon | team_slave |</span><br><span class="line">          bond_slave | ipvlan | geneve | bridge_slave | vrf | macsec &#125;</span><br></pre></td></tr></table></figure>

<p>使用ip link创建一对网卡演示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip link add veth1.1 type veth peer name veth1.2</span></span><br><span class="line">[root@node01 ~]<span class="comment">#ip link l</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:03:24:1c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:03:24:26 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 22:17:fd:32:b4:81 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth1.2@veth1.1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 3e:87:a2:0e:40:eb brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: veth1.1@veth1.2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 9e:f2:a6:29:6a:c9 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>将刚创建的一对网卡的一头接到虚拟交换机br0上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#brctl addif br0 veth1.1</span></span><br><span class="line">[root@node01 ~]<span class="comment">#brctl show</span></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">br0		8000.9ef2a6296ac9	no		veth1.1</span><br></pre></td></tr></table></figure>

<p>将刚创建的一对网卡的另一头接到router1上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip link set veth1.2 netns router1</span></span><br></pre></td></tr></table></figure>

<p>此时在用ip link l命令只能查看到veth1.1，而不能看到veth1.2，因为ip link l命令只能看到宿主机的名称空间的网卡，而veth1.2已经被接到router1上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip link l</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:03:24:1c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:03:24:26 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: br0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 9e:f2:a6:29:6a:c9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: veth1.1@if5: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop master br0 state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 9e:f2:a6:29:6a:c9 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ifconfig -a</span></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth1.2: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 3e:87:a2:0e:40:eb  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>将veth1.2改名为eth0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ip link set veth1.2 name eth0</span></span><br></pre></td></tr></table></figure>

<p>给router1上的eth0网卡配置ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ifconfig eth0 10.0.0.1/24 up</span></span><br></pre></td></tr></table></figure>

<p>给veth1.1网卡配置ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ifconfig veth1.1 10.0.0.2/24 up</span></span><br></pre></td></tr></table></figure>

<p>将veth1.1从软交换机br0上卸下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#brctl delif br0 veth1.1</span></span><br></pre></td></tr></table></figure>

<p>此时，刚才创建的一对网卡一个在宿主机的名称空间内，一个在刚创建的router1名称空间内，测试测试的网络是否能联通</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ping 10.0.0.2</span></span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.053 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.2 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.053/0.053/0.053/0.000 ms</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ping 10.0.0.1</span></span><br><span class="line">PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.022 ms</span><br><span class="line">64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.048 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.022/0.035/0.048/0.013 ms</span><br></pre></td></tr></table></figure>

<p>将网卡veth1.1再次加到虚拟交换机br0上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#brctl addif br0 veth1.1</span></span><br></pre></td></tr></table></figure>

<p>激活软交换机br0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ifconfig br0 up</span></span><br></pre></td></tr></table></figure>
<p>此时发现两个网卡之间不能通信了，原因是交换机br0是个二层设备，而二层设备是不允许有地址的。</p>
<p>为了测试不同名称空间之间的网卡是可以通信的，再加一个路由器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns add router2</span></span><br></pre></td></tr></table></figure>

<p>将虚拟网卡veth1.1加到路由器router2上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip link set veth1.1 netns router2</span></span><br></pre></td></tr></table></figure>

<p>此时，相当于在主机上创建了两个虚拟路由器，然后又创建了一对虚拟网卡，分别作为两个路由器的端口。</p>
<p>由于将veth1.1重新加载到了router2上，所以需要重新配置地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router2 ifconfig veth1.1 10.0.0.2/24 up</span></span><br></pre></td></tr></table></figure>

<p>此时测试者一对网卡之间是否能通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router2 ping 10.0.0.1</span></span><br><span class="line">PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.039 ms</span><br><span class="line">64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.028 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.028/0.033/0.039/0.008 ms</span><br><span class="line">[root@node01 ~]<span class="comment">#ip netns exec router1 ping 10.0.0.2</span></span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.032 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.055 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.2 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.032/0.043/0.055/0.013 ms</span><br></pre></td></tr></table></figure>

<h4 id="浅谈仅主机模式和nat模式"><a href="#浅谈仅主机模式和nat模式" class="headerlink" title="浅谈仅主机模式和nat模式"></a>浅谈仅主机模式和nat模式</h4><p>仅主机模式就是在宿主机上建立一个软交换机，然后将一个或多个虚拟机接到该软交换机上，这样一来，接到该交换机的各个虚拟机之间可以正常通信，但是他们就像一个孤岛似的，只能相互之间通信，与宿主机都不能通信，如果把该软交换机当成宿主机的一个网卡，配上ip，此时宿主机和各个虚拟机之间就可以实现通信，但各个虚拟机与数组及之外的主机均不能通信，此种模式就是仅主机模式。<br>在此基础上，如果在宿主机加一个网卡，此网卡可以连接互联网，再打开宿主机的核心转发功能，并做一条SNAT规则，将宿主机上的各个虚拟机所在的网段发来的不到该网段的报文全部将源地址改为可以连接互联网的哪个网卡的ip地址，此时就成了nat模式。</p>
<h3 id="虚拟化技术分类"><a href="#虚拟化技术分类" class="headerlink" title="虚拟化技术分类"></a>虚拟化技术分类</h3><p>主机级虚拟化<br>容器级虚拟化</p>
<p>CloudOS(Iaas)</p>
<ul>
<li>OpenStack</li>
<li>CloudStack</li>
</ul>
<p>CloudOS(PaaS)</p>
<ul>
<li>kubernetes</li>
<li>docker compose,swarm,machine</li>
<li>Mesos,Marathon</li>
</ul>
<h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>KVM全称kernel virtualization machine，基于内核的虚拟机<br>kvm特点</p>
<ul>
<li>仅支持x86_64架构</li>
<li>要求cpu必须支持硬件虚拟化</li>
</ul>
<p><strong>使用图形化工具virt-manager安装使用kvm</strong><br>判断CPU是否支持硬件虚拟化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i -E <span class="string">'(vmx|svm|lm)'</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>加载kvm模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe kvm</span><br></pre></td></tr></table></figure>

<p>安装qemu-kvm软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install qemu-kvm</span><br></pre></td></tr></table></figure>

<p>使用virt-manager管理kvm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install qemu-kvm libvirt-daemon-kvm libvirt virt-manager</span><br><span class="line">modprobe kvm</span><br><span class="line">systemctl start libvirtd.service</span><br><span class="line">virt-manager &amp;</span><br></pre></td></tr></table></figure>

<p>此外，还需要系统拥有桌面环境。</p>
<p>此时，在虚拟机运行virt-manager命令即可创建虚拟机，创建的虚拟机的相关配置会以文件的形式保存在/etc/libvirt/qemu/中。</p>
<p><strong>使用命令行工具virsh做kvm的全生命周期管理</strong><br>virsh命令介绍：</p>
<pre><code>virsh create file  从一个xml文件创建一个域并开启
virsh define file 从一个xml文件定义一个域，但是不开启
virsh list --all 显示当前创建爱你的所有虚拟机
virsh  dumpxml domain 查看域详情
virsh console domain 连接虚拟机真实串行控制台
virsh suspend domain 挂起一个域，相当于暂停。
virsh resume domain 将一个域从挂起的状态中恢复
virsh save domain file 把域的状态保存到一个文件中，可能会导致数据不一致，先挂起再保存比较保险。
virsh restore file 从域状态保存到的文件中恢复一个域。--running将域恢复为运行状态，--paused将域恢复为暂停状态
virsh reboot domain 重新启动一个域，热重启
virsh reset doamin 如同使用电源按钮重新设定目标域
virsh shutdown domain 在目标域中执行关闭行为，即关闭虚拟机
virsh destroy domain 销毁虚拟机，不会删除虚拟机文件，而是把虚拟机这个进程销毁
virsh undefine domain 删除虚拟机定义，即删除虚拟机文件
virsh autostart domain 将虚拟机设定为自动启动
virsh domrename domain 重命名一个虚拟机</code></pre><p>kvm支持硬件设备的热插拔</p>
]]></content>
      <tags>
        <tag>虚拟化</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile</title>
    <url>/2018/07/11/dockerfile/</url>
    <content><![CDATA[<h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><p>dockerfile:用来构建docker images的源码，docker通过读取dockerfile的指令来完成镜像文件的构建。</p>
<p>构建dockerfile必须要有一个专门的工作目录，此目录只存放dockerfile和dockerfile制定需要复制的文件。</p>
<p>使用build构建images的时候，只需指定dockerfile所在的目录即可，而dockerfile的名字也只能是dockerfile。</p>
<p>dockerfile的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Comment</span></span><br><span class="line">INSTRUCTION arguments</span><br><span class="line">第一条指令必须是FROM，</span><br></pre></td></tr></table></figure>

<p>dockerfile的每一条指令都会生成一个专有的单一的镜像层。镜像层越多越精细，就越容易容器之间的共享，但是性能也会相应的变低。原则：把做同一件事的多个语句放在一条指令中。</p>
<p>build阶段，基于基础镜像做目标镜像的过程，此过程会隐式启动容器。</p>
<p>dockerfile也可以定义环境变量：使用ENV定义环境变量，使用$variable_name或${variable_name}来引用环境变量。</p>
<p>.dockerignorefile：docker build会忽略此文件以及此文件中包含的文件。</p>
<p>Dockerfile Instructions：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM </span><br><span class="line">MAINTAINER &lt;author<span class="string">'s detail&gt;</span></span><br><span class="line"><span class="string">COPY &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="string">ADD </span></span><br><span class="line"><span class="string">VOLUME</span></span><br><span class="line"><span class="string">EXPOSE</span></span><br><span class="line"><span class="string">RUN</span></span><br><span class="line"><span class="string">CMD</span></span><br><span class="line"><span class="string">ENTRYPOINT</span></span><br></pre></td></tr></table></figure>

<h4 id="docker镜像的分发"><a href="#docker镜像的分发" class="headerlink" title="docker镜像的分发"></a>docker镜像的分发</h4><p>在本机打包docker镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 secimg]<span class="comment"># docker image save setimg:v0.1 testimg:v0.1 -o myimgs.tar</span></span><br></pre></td></tr></table></figure>
<p>将打包的镜像传到目标服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 secimg]<span class="comment"># scp myimgs.tar master:</span></span><br></pre></td></tr></table></figure>
<p>在目标服务器上加载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@slave-node01 ~]<span class="comment"># docker image load -i myimgs.tar</span></span><br></pre></td></tr></table></figure>

<h3 id="docker-registry"><a href="#docker-registry" class="headerlink" title="docker registry"></a>docker registry</h3><p>Registry用于保存docker镜像，包括镜像的层次结构和元数据。<br>用户可以自建registry，也可以使用官方的docker hub</p>
<h4 id="使用docker-distribution创建私有仓库"><a href="#使用docker-distribution创建私有仓库" class="headerlink" title="使用docker-distribution创建私有仓库"></a>使用docker-distribution创建私有仓库</h4><p><strong>创建私有仓库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 build_workshop]<span class="comment"># yum -y install docker-distribution</span></span><br><span class="line">[root@node01 build_workshop]<span class="comment"># rpm -ql docker-distribution</span></span><br><span class="line">/etc/docker-distribution/registry/config.yml</span><br><span class="line">/usr/bin/registry</span><br><span class="line">/usr/lib/systemd/system/docker-distribution.service</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/AUTHORS</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/CONTRIBUTING.md</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/LICENSE</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/MAINTAINERS</span><br><span class="line">/usr/share/doc/docker-distribution-2.6.2/README.md</span><br><span class="line">/var/lib/registry</span><br></pre></td></tr></table></figure>

<p>docker-distribution的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line"><span class="built_in">log</span>:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">    cache:</span><br><span class="line">        layerinfo: inmemory</span><br><span class="line">    filesystem:</span><br><span class="line">        rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">    addr: :5000</span><br></pre></td></tr></table></figure>

<p>启动docker-distribution</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 build_workshop]<span class="comment"># systemctl start docker-distribution</span></span><br></pre></td></tr></table></figure>

<p><strong>向私有仓库放置镜像</strong><br>先给镜像打标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@slave-node01 ~]<span class="comment"># docker tag testimg:v0.1 node01:5000/myimg:v0.1</span></span><br></pre></td></tr></table></figure>
<p>docker默认只允许https协议想registry推送镜像，如果要使用http协议推送镜像，需要在配置文件中加入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@slave-node01 docker]<span class="comment"># vi daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"insecure-registries"</span>:[<span class="string">"node02.magedu.com:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推送镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@slave-node01 docker]<span class="comment"># docker push node01:5000/myimg</span></span><br></pre></td></tr></table></figure>

<h4 id="使用docker-harbor创建私有仓库"><a href="#使用docker-harbor创建私有仓库" class="headerlink" title="使用docker harbor创建私有仓库"></a>使用docker harbor创建私有仓库</h4><p>安装docker-compose</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># yum -y install docker-compose</span></span><br></pre></td></tr></table></figure>
<p>下载docker harbor的离线安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>HAProxy</title>
    <url>/2018/07/08/HAProxy/</url>
    <content><![CDATA[<h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy: 是法国开发者Willy Tarreau开发的一个开源软件，是一款具备高并发、高性能的TCP和HTTP负载均衡器，支持基于cookie的持久性，自动故障切换，支持正则表达式及web状态统计。</p>
<p>LB Cluster:</p>
<ul>
<li>四层：lvs, nginx(stream模式且nginx1.9.0或更新版本)，haproxy(mode tcp)</li>
<li>七层：http: nginx(http), haproxy(mode http), httpd…</li>
</ul>
<h3 id="HAProxy功能"><a href="#HAProxy功能" class="headerlink" title="HAProxy功能"></a>HAProxy功能</h3><p>HAProxy是TCP / HTTP反向代理服务器，尤其适合于高可用性高并发环境</p>
<ul>
<li>可以针对HTTP请求添加cookie，进行路由后端服务器</li>
<li>可平衡负载至后端服务器，并支持持久连接</li>
<li>支持基于cookie进行调度</li>
<li>支持所有主服务器故障切换至备用服务器</li>
<li>支持专用端口实现监控服务</li>
<li>支持不影响现有连接情况下停止接受新连接请求</li>
<li>可以在双向添加，修改或删除HTTP报文首部</li>
<li>支持基于pattern实现连接请求的访问控制</li>
<li>通过特定的URI为授权用户提供详细的状态信息</li>
</ul>
<h3 id="使用HAProxy"><a href="#使用HAProxy" class="headerlink" title="使用HAProxy"></a>使用HAProxy</h3><h4 id="安装启动haproxy"><a href="#安装启动haproxy" class="headerlink" title="安装启动haproxy"></a>安装启动haproxy</h4><p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master haproxy-1.8.17]<span class="comment"># yum install gcc gcc-c++ glibc glibc-devel pcre pcre-devel openssl  openssl-devel systemd-devel net-tools vim iotop bc  zip unzip zlib-devel lrzsz tree screen lsof tcpdump wget ntpdate #解决依赖关系</span></span><br><span class="line">[root@master haproxy-1.8.17]<span class="comment"># make  ARCH=x86_64 TARGET=linux2628 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 USE_SYSTEMD=1  USE_CPU_AFFINITY=1  PREFIX=/usr/local/haproxy</span></span><br><span class="line">[root@master haproxy-1.8.17]<span class="comment"># make install PREFIX=/usr/local/haproxy</span></span><br></pre></td></tr></table></figure>
<p>在编译的过程中会在当前目录生成一个haproxy可执行程序，将其拷贝到/usr/sbin/目录下。</p>
<p>创建启动文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master haproxy-1.8.17]<span class="comment"># vi /usr/lib/systemd/system/haproxy.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=HAProxy Load Balancer</span><br><span class="line">After=syslog.target network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/usr/sbin/haproxy -f /etc/haproxy/haproxy.cfg  -c -q</span><br><span class="line">ExecStart=/usr/sbin/haproxy -Ws -f /etc/haproxy/haproxy.cfg  -p /run/haproxy.pid</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -USR2 <span class="variable">$MAINPID</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master haproxy]<span class="comment"># cat /etc/haproxy/haproxy.cfg </span></span><br><span class="line">global</span><br><span class="line">maxconn 100000</span><br><span class="line">chroot /usr/<span class="built_in">local</span>/haproxy</span><br><span class="line"><span class="comment">#stats socket /var/lib/haproxy/haproxy.sock mode 600 level admin</span></span><br><span class="line">uid 188</span><br><span class="line">gid 188</span><br><span class="line">daemon</span><br><span class="line">nbproc 4</span><br><span class="line">cpu-map 1 0</span><br><span class="line">cpu-map 2 1</span><br><span class="line">cpu-map 3 2</span><br><span class="line">cpu-map 4 3</span><br><span class="line">pidfile /usr/<span class="built_in">local</span>/haproxy/run/haproxy.pid</span><br><span class="line"><span class="built_in">log</span> 127.0.0.1 local3 info</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">option http-keep-alive</span><br><span class="line">option  forwardfor</span><br><span class="line">maxconn 100000</span><br><span class="line">mode http</span><br><span class="line">timeout connect 300000ms</span><br><span class="line">timeout client  300000ms</span><br><span class="line">timeout server  300000ms</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line"> mode http</span><br><span class="line"> <span class="built_in">bind</span> 0.0.0.0:9999</span><br><span class="line"> stats <span class="built_in">enable</span></span><br><span class="line"> <span class="built_in">log</span> global</span><br><span class="line"> stats uri     /haproxy-status</span><br><span class="line"> stats auth    haadmin:q1w2e3r4ys</span><br><span class="line"></span><br><span class="line">listen  web_port</span><br><span class="line"> <span class="built_in">bind</span> 0.0.0.0:80</span><br><span class="line"> mode http</span><br><span class="line"> <span class="built_in">log</span> global</span><br><span class="line"> server web1  127.0.0.1:8080  check inter 3000 fall 2 rise 5</span><br></pre></td></tr></table></figure>
<p>创建目录和用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master haproxy-1.8.17]<span class="comment"># mkdir  /etc/haproxy</span></span><br><span class="line">[root@master haproxy-1.8.17]<span class="comment"># useradd  haproxy -s /sbin/nologin</span></span><br><span class="line">[root@master haproxy-1.8.17]<span class="comment"># mkdir  /var/lib/haproxy</span></span><br><span class="line">[root@master haproxy-1.8.17]<span class="comment"># chown  haproxy.haproxy /var/lib/haproxy/ -R</span></span><br></pre></td></tr></table></figure>
<p>haproxy.cfg文件中定义了chroot、pidfile、user、group等参数，如果系统没有相应的资源会导致haproxy无法启动，具体参考日志文件/var/log/messages</p>
<p>启动haproxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">~]<span class="comment"># systemctl start haproxy</span></span><br></pre></td></tr></table></figure>

<h4 id="haproxy基本配置"><a href="#haproxy基本配置" class="headerlink" title="haproxy基本配置"></a>haproxy基本配置</h4><p>HAProxy组成<br>程序环境</p>
<ul>
<li>主程序：/usr/sbin/haproxy</li>
<li>配置文件：/etc/haproxy/haproxy.cfg</li>
<li>unit file:/usr/lib/systemd/system/haproxy.service</li>
</ul>
<p>配置段：</p>
<ul>
<li>global：全局配置段<blockquote>
<p>进程及安全配置相关的参数<br>性能调整相关的参数<br>debug参数</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chroot <span class="comment">#锁定运行目录，当haproxy被侵入，则只能在锁定目录活动，能保护系统上的其他目录不受侵害。</span></span><br><span class="line">deamon <span class="comment">#以守护进程运行</span></span><br><span class="line"><span class="comment">#stats socket /var/lib/haproxy/haproxy.sock mode 600 level admin #socket文件</span></span><br><span class="line">user, group, uid, gid  <span class="comment">#运行haproxy的用户身份</span></span><br><span class="line">nbproc  <span class="comment">#开启的haproxy进程数，与CPU保持一致</span></span><br><span class="line">nbthread  <span class="comment">#指定每个haproxy进程开启的线程数，默认为每个进程一个线程</span></span><br><span class="line">cpu-map 1 0 <span class="comment">#绑定haproxy 进程至指定CPU</span></span><br><span class="line">maxconn  <span class="comment">#每个haproxy进程的最大并发连接数</span></span><br><span class="line">maxsslconn     <span class="comment">#SSL每个haproxy进程ssl最大连接数</span></span><br><span class="line">maxconnrate  <span class="comment">#每个进程每秒最大连接数</span></span><br><span class="line">spread-checks   <span class="comment">#后端server状态check随机提前或延迟百分比时间，建议2-5(20%-50%)之间</span></span><br><span class="line">pidfile <span class="comment">#指定pid文件路径</span></span><br><span class="line"><span class="built_in">log</span> 127.0.0.1  local3 info <span class="comment">#定义全局的syslog服务器；最多可以定义两个</span></span><br></pre></td></tr></table></figure>

<ul>
<li>proxies：代理配置段<blockquote>
<p>defaults:为frontend,backend,listen提供默认配置<br>frontend &lt;\name&gt;:前端，相当于nginx中的server{}<br>backend &lt;\name&gt;：后端，相当于nginx中的upstream{}<br>listen &lt;\name&gt;：同时拥有前端和后端，适用于一对一环境。</p>
</blockquote>
</li>
</ul>
<p>注意：name字段只能用”-“,”.”,”、”,”:”,并严格区分大小写，例如：Web和web时完全不同的两组服务器。</p>
<p>defaults[&lt;\name&gt;] #默认配置项，针对以下的frontend、backend和listen生效，可以多个name</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">option redispatch    <span class="comment">#当server Id对应的服务器挂掉后，强制定向到其他健康的服务器  </span></span><br><span class="line">option abortonclose   <span class="comment">#当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接</span></span><br><span class="line">option http-keep-alive <span class="comment">#开启会话保持</span></span><br><span class="line">option  forwardfor <span class="comment">#开启IP透传</span></span><br><span class="line">mode http <span class="comment">#默认工作类型</span></span><br><span class="line">timeout connect 120s  <span class="comment">#连接到一台后端server的最长时间</span></span><br><span class="line">timeout client  600s  <span class="comment">#与客户端的最长空闲时间</span></span><br><span class="line">timeout server  600s  <span class="comment">#等待服务端的超时时长</span></span><br><span class="line">timeout http-keep-alive 120s <span class="comment">#session 会话保持时间</span></span><br><span class="line"><span class="comment">#timeout check   5s   #对后端服务器的检测超时时间</span></span><br></pre></td></tr></table></figure>
<p>bind：指定HAProxy的监听地址，可以是IPV4或IPV6，可以同时监听多个IP或端口，可同时用于listen字段中<br>bind [<address>]:<port_range> [, …] [param*]<br>mode  http/tcp      #指定负载协议类型<br>use_backend  backend_name   #调用的后端服务器组名称<br>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frontend  WEB_PORT</span><br><span class="line">    <span class="built_in">bind</span> :80,:8080</span><br><span class="line">    <span class="built_in">bind</span> 192.168.7.102:10080,192.168.7.102:10043</span><br><span class="line">    use_backend backend_name</span><br></pre></td></tr></table></figure>

<ul>
<li>check #对指定real进行健康状态检查，默认不开启<blockquote>
<p>addr IP    #可指定的健康状态监测IP<br>port num  #指定的健康状态监测端口<br>inter num #健康状态检查间隔时间，默认2000 ms<br>fall  num   #后端服务器失效检查次数，默认为3<br>rise num    #后端服务器从下线恢复检查次数，默认为2<br>weight  #默认为1，最大值为256，0表示不参与负载均衡<br>backup #将后端服务器标记为备份状态<br>disabled #将后端服务器标记为不可用状态<br>redir <a href="http://www.magedu.com/" target="_blank" rel="noopener">http://www.magedu.com/</a> #将请求临时重定向至其它URL，只适用于http模式<br>maxconn <maxconn>：当前后端server的最大并发连接数<br>backlog <backlog>：当server的连接数达到上限后的后援队列长度</p>
</blockquote>
</li>
</ul>
<p>也可以直接使用listen定义一组负载均衡：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># tail /etc/haproxy/haproxy.cfg </span></span><br><span class="line">listen web-port-80</span><br><span class="line">  <span class="built_in">bind</span> 192.168.34.100:80</span><br><span class="line">  mode http</span><br><span class="line">  option forwardfor</span><br><span class="line">  server web1 192.168.34.101:80 </span><br><span class="line">  server web2 192.168.34.102:80</span><br><span class="line">  server web3 192.168.34.103:80</span><br></pre></td></tr></table></figure>

<h4 id="HAProxy算法"><a href="#HAProxy算法" class="headerlink" title="HAProxy算法"></a>HAProxy算法</h4><p>无状态和有状态：</p>
<ul>
<li>无状态的请求实质两次请求之间没有关联，有状态反之。</li>
</ul>
<p>balance： 指明对后端服务器的调度算法，配置在listen或backend</p>
<p><strong>静态算法</strong><br>静态算法：按照事先定义好的规则轮询公平调度，不关心后端服务器的当前负载、链接数和相应速度等，且无法实时修改权重，只能重启后生效</p>
<ul>
<li><p>static-rr：基于权重的轮询调度，不支持权重的运行时调整及后端服务器慢启动，其后端主机数量没有限制</p>
</li>
<li><p>first：根据服务器在列表中的位置，自上而下进行调度，但是其只会当第一台服务器的连接数达到上限，新请求才会分配给下一台服务，因此会忽略服务器的权重设置。</p>
</li>
</ul>
<p><strong>动态算法</strong><br>动态算法：基于后端服务器 状态进行调度适当调整，比如优先调度至当前负载较低的服务器，且权重可以在haproxy运行时动态调整无需重启。</p>
<ul>
<li><p>roundrobin：基于权重的轮询动态调度算法，支持权重的运行时调整，不等于lvs 的rr，支持慢启动即新加的服务器会逐渐增加转发数，每个后端backend中最多支持4095个server，此为默认调度算法，server 权重设置 weight</p>
</li>
<li><p>leastconn： 加权的最少连接的动态，支持权重的运行时调整和慢启动，即当前后端服务器连接最少的优先调度，比较适合长连接的场景使用，比如MySQL等场景。</p>
</li>
<li><p>source：源地址hash，基于用户源地址hash并将请求转发到后端服务器，默认为静态即取模方式，但是可以通过hash-type支持的选项更改，后续同一个源地址请求将被转发至同一个后端web服务器，比较适用于session保持等场景。</p>
<blockquote>
<p>map-based：取模法，基于服务器权重的hash数组取模，该hash是静态的即不支持在线调整权重，不支持慢启动，其对后端服务器调度均衡，缺点是当服务器的总权重发生变化时，即有服务器上线或下线，都会因权重发生变化而导致调度结果整体改变。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>consistent：一致性哈希，该hash是动态的，支持在线调整权重，支持慢启动，优点在于当服务器的总权重发生变化时，对调度结果影响是局部的，不会引起大的变动，该算法很容易导致后端服务器负载不均衡，但是比较适合session保持。</p>
</blockquote>
<p>source算法示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.101:80</span><br><span class="line">    mode http</span><br><span class="line">    balance <span class="built_in">source</span></span><br><span class="line">    <span class="built_in">hash</span>-type consistent</span><br><span class="line">    <span class="built_in">log</span> global</span><br><span class="line">    option  forwardfor</span><br><span class="line">    server 192.168.7.101   192.168.7.101:8080   check inter 3000 fall 3 rise 5</span><br><span class="line">    server 192.168.7.102   192.168.7.102:8080   check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<ul>
<li>uri：基于对用户请求的uri做hash并将请求转发到后端指定服务器<blockquote>
<p> map-based：取模法<br>consistent：一致性哈希</p>
</blockquote>
</li>
</ul>
<p>uri: uniform resource identifier，统一资源标识符,是一个用于标识某一互联网资源名称的字符串</p>
<p>uri调度算法示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.101:80</span><br><span class="line">    mode http <span class="comment">#不支持tcp，会切换到tcp的roundrobin负载模式</span></span><br><span class="line">    balance uri</span><br><span class="line">    <span class="built_in">hash</span>-type consistent</span><br><span class="line">    <span class="built_in">log</span> global</span><br><span class="line">    option  forwardfor</span><br><span class="line">    server 192.168.7.101   192.168.7.101:8080   check inter 3000 fall 3 rise 5</span><br><span class="line">    server 192.168.7.102   192.168.7.102:8080   check inter 3000 fall 3 rise</span><br></pre></td></tr></table></figure>

<ul>
<li>url_param：对用户请求的url中的<params>部分中的参数name作hash计算，并由服务器总权重相除以后派发至某挑出的服务器；通常用于追踪用户，以确保来自同一个用户的请求始终发往同一个Backend Server</li>
</ul>
<p>url_param调度算法示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.101:80</span><br><span class="line">    mode http <span class="comment">#不支持tcp，会切换到tcp的roundrobin负载模式</span></span><br><span class="line">    balance url_param  name  <span class="comment">#基于参数name做hash</span></span><br><span class="line">    <span class="built_in">hash</span>-type consistent</span><br><span class="line">    <span class="built_in">log</span> global</span><br><span class="line">    option  forwardfor</span><br><span class="line">    server 192.168.7.101   192.168.7.101:8080   check inter 3000 fall 3 rise 5</span><br><span class="line">    server 192.168.7.102   192.168.7.102:8080   check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<ul>
<li>hdr(<name>)：针对用户每个http头部(header)请求中的指定信息做hash，此处由<name>指定的http首部将会被取出并做hash计算，然后由服务器总权重相除以后派发至某挑出的服务器，假如无有效的值，则会被轮询调度<blockquote>
<p>hdr( Cookie、 User-Agent、host )</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.101:80</span><br><span class="line">    mode http</span><br><span class="line">    balance hdr(User-Agent)</span><br><span class="line">    <span class="built_in">hash</span>-type consistent</span><br><span class="line">    <span class="built_in">log</span> global</span><br><span class="line">    option  forwardfor</span><br><span class="line">    server 192.168.7.101   192.168.7.101:8080   check inter 3000 fall 3 rise 5</span><br><span class="line">    server 192.168.7.102   192.168.7.102:8080   check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<ul>
<li>rdp-cookie对远程桌面的负载，使用cookie保持会话<br>rdp-cookie(<name>)</li>
</ul>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen RDP</span><br><span class="line"><span class="built_in">bind</span>  192.168.7.101:3389</span><br><span class="line">balance rdp-cookie</span><br><span class="line">mode tcp</span><br><span class="line">server rdp0 172.18.139.20:3389 check fall 3 rise 5 inter 2000 weight 1</span><br><span class="line">server rdp1 172.18.139.21:3389 check fall 3 rise 5 inter 2000 weight 1</span><br></pre></td></tr></table></figure>

<p>基于iptables实现目标地址转换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># iptables -t nat -A PREROUTING -d 192.168.34.101 -p tcp --dport 3389 -j DNAT --to-destnation 192.167.34.101:80</span></span><br><span class="line">~]<span class="comment"># iptables -t nat -A POSTROUTING -s 192.168.34.0/24 -j SNAT --to-source 192.168.34.101</span></span><br><span class="line">~]<span class="comment"># echo "net.ipv4.ip_forward = 1" &gt;&gt; /etc/sysctl.conf</span></span><br></pre></td></tr></table></figure>


<p>算法总结：<br>roundrobin——–&gt;tcp/http 动态<br>leastconn———–&gt;tcp/http 动态<br>static-rr————–&gt;tcp/http  静态<br>first——————–&gt;tcp/http  静态</p>
<p>source—————-&gt;tcp/http<br>Uri———————-&gt;http<br>url_param———-&gt;http                取决于hash_type是否consistent<br>hdr———————&gt;http<br>rdp-cookie———&gt;tcp</p>
<h4 id="HAProxy-服务器动态上下线"><a href="#HAProxy-服务器动态上下线" class="headerlink" title="HAProxy-服务器动态上下线"></a>HAProxy-服务器动态上下线</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># yum -y install socat</span></span><br><span class="line">[root@master ~]<span class="comment"># echo "show info"|socat stdio /var/lib/haproxy/haproxy.sock</span></span><br><span class="line">proxy.sock </span><br><span class="line">Name: HAProxy</span><br><span class="line">Version: 1.8.17</span><br><span class="line">Release_date: 2019/01/08</span><br><span class="line">Nbthread: 1</span><br><span class="line">Nbproc: 2</span><br><span class="line">Process_num: 2</span><br><span class="line">Pid: 17966</span><br><span class="line">Uptime: 0d 1h10m29s</span><br><span class="line">Uptime_sec: 4229</span><br><span class="line">Memmax_MB: 0</span><br><span class="line">PoolAlloc_MB: 0</span><br><span class="line">PoolUsed_MB: 0</span><br><span class="line">PoolFailed: 0</span><br><span class="line">Ulimit-n: 200032</span><br><span class="line">Maxsock: 200032</span><br><span class="line">Maxconn: 100000</span><br><span class="line">Hard_maxconn: 100000</span><br><span class="line">CurrConns: 0</span><br><span class="line">CumConns: 5</span><br><span class="line">CumReq: 8</span><br><span class="line">MaxSslConns: 0</span><br><span class="line">CurrSslConns: 0</span><br><span class="line">CumSslConns: 0</span><br><span class="line">Maxpipes: 0</span><br><span class="line">PipesUsed: 0</span><br><span class="line">PipesFree: 0</span><br><span class="line">ConnRate: 0</span><br><span class="line">ConnRateLimit: 0</span><br><span class="line">MaxConnRate: 1</span><br><span class="line">SessRate: 0</span><br><span class="line">SessRateLimit: 0</span><br><span class="line">MaxSessRate: 1</span><br><span class="line">SslRate: 0</span><br><span class="line">SslRateLimit: 0</span><br><span class="line">MaxSslRate: 0</span><br><span class="line">SslFrontendKeyRate: 0</span><br><span class="line">SslFrontendMaxKeyRate: 0</span><br><span class="line">SslFrontendSessionReuse_pct: 0</span><br><span class="line">SslBackendKeyRate: 0</span><br><span class="line">SslBackendMaxKeyRate: 0</span><br><span class="line">SslCacheLookups: 0</span><br><span class="line">SslCacheMisses: 0</span><br><span class="line">CompressBpsIn: 0</span><br><span class="line">CompressBpsOut: 0</span><br><span class="line">CompressBpsRateLim: 0</span><br><span class="line">ZlibMemUsage: 0</span><br><span class="line">MaxZlibMemUsage: 0</span><br><span class="line">Tasks: 5</span><br><span class="line">Run_queue: 1</span><br><span class="line">Idle_pct: 100</span><br><span class="line">node: master</span><br><span class="line">Stopping: 0</span><br><span class="line">Jobs: 4</span><br><span class="line">Listeners: 3</span><br></pre></td></tr></table></figure>

<h4 id="IP地址透传与基于cookie实现会话保持"><a href="#IP地址透传与基于cookie实现会话保持" class="headerlink" title="IP地址透传与基于cookie实现会话保持"></a>IP地址透传与基于cookie实现会话保持</h4><p>四层负载和七层的区别：<br>四层</p>
<pre><code>在四层负载设备中，把client发送的报文目标地址(原来是负载均衡设备的IP地址)，根据均衡设备设置的选择web服务器的规则选择对应的web服务器IP地址，这样client就可以直接跟此服务器建立TCP连接并发送数据。</code></pre><p>七层</p>
<pre><code>七层负载均衡服务器起了一个代理服务器的作用，服务器建立一次TCP连接要三次握手，而client要访问webserver要先于七层设备进行三次握手后建立TCP连接，把要访问的报文信息发送给七层负载均衡，然后七层负载均衡再根据设置的均衡规则选择特定的webserver，然后通过三次握手与此台webserver建立TCP连接，然后webserver把需要的数据发送给七层负载均衡设备，负载均衡设备再把数据发给client；所以，七层负载均衡设备起到了代理服务器的作用。</code></pre><p>抓包命令：</p>
<ul>
<li>tcpdump tcp -i eth0 -nn port !22 -w dump-tcp.pcap -v</li>
</ul>
<p>内核参数优化：</p>
<ul>
<li>/etc/sysctl.conf</li>
<li>/etc/security.conf</li>
</ul>
<h5 id="七层ip透传"><a href="#七层ip透传" class="headerlink" title="七层ip透传"></a>七层ip透传</h5><p>haproxy设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.102:80</span><br><span class="line">    mode  http</span><br><span class="line">    option  forwardfor</span><br><span class="line">server 192.168.7.102  blogs.studylinux.net:80   check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>后端server配置<br>nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line">access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br></pre></td></tr></table></figure>

<p>httpd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LogFormat <span class="string">"\"%&#123;X-Forwarded-For&#125;i\" %l %u %t \"%r\" %&gt;s %b"</span> common1</span><br><span class="line">CustomLog <span class="string">"logs/access_log"</span> common1</span><br></pre></td></tr></table></figure>

<h5 id="四层ip透传"><a href="#四层ip透传" class="headerlink" title="四层ip透传"></a>四层ip透传</h5><p>配置haproxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.102:80</span><br><span class="line">    mode  tcp</span><br><span class="line">    server 192.168.7.102  blogs.studylinux.net:80  send-proxy  check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>配置后端服务器(nginx)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen       80 proxy_protocol;</span><br><span class="line"><span class="string">'"tcp_ip":"$proxy_protocol_addr",'</span>   <span class="comment">#TCP获取客户端真实IP日志格式</span></span><br></pre></td></tr></table></figure>

<h5 id="基于cookie实现会话保持"><a href="#基于cookie实现会话保持" class="headerlink" title="基于cookie实现会话保持"></a>基于cookie实现会话保持</h5><p>cookie <value>：为当前server指定cookie值，实现基于cookie的会话黏性<br>cookie <name> [ rewrite | insert | prefix ] [ indirect ] [ nocache ]  [ postonly ] [ preserve ] [ httponly ] [ secure ]  [ domain <domain> ]* [ maxidle <idle> ] [ maxlife <life> ]<br><name>：cookie名称，用于实现持久连接<br>    rewrite：重写<br>    insert：插入<br>    prefix：前缀<br>    nocache：当client和hapoxy之间有缓存时，不缓存cookie</p>
<p>配置示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.34.100:80</span><br><span class="line">    mode  http</span><br><span class="line">    cookie  SERVER-COOKIE  insert indirect nocache</span><br><span class="line">    server web1 192.168.34.101:80  cookie web1 check inter 3000 fall 3 rise 5</span><br><span class="line">    server web2 192.168.34.102:80  cookie web2 check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node03 ~]<span class="comment"># curl --cookie "SERVER-COOKIE=web1" 192.168.34.100</span></span><br><span class="line">101</span><br><span class="line">[root@node03 ~]<span class="comment"># curl --cookie "SERVER-COOKIE=web2" 192.168.34.100</span></span><br><span class="line">102</span><br></pre></td></tr></table></figure>

<h4 id="状态页、日志配置和报文操作"><a href="#状态页、日志配置和报文操作" class="headerlink" title="状态页、日志配置和报文操作"></a>状态页、日志配置和报文操作</h4><p>haproxy状态页的使用</p>
<pre><code>stats enable   #基于默认的参数启用stats page
stats hide-version  # 隐藏版本
stats refresh &lt;delay&gt; # 设定自动刷新时间间隔
stats uri &lt;prefix&gt;  #自定义stats page uri，默认值：/haproxy?stats 
stats realm &lt;realm&gt; #账户认证时的提示信息，示例：stats realm : HAProxy\ Statistics
stats auth &lt;user&gt;:&lt;passwd&gt; #认证时的账号和密码，可使用多次，默认：no authentication
stats admin { if | unless } &lt;cond&gt; #启用stats page中的管理功能</code></pre><p>配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen stats</span><br><span class="line">        <span class="built_in">bind</span> :9009</span><br><span class="line">        stats <span class="built_in">enable</span></span><br><span class="line">        <span class="comment">#stats hide-version </span></span><br><span class="line">        stats uri  /haproxy-status</span><br><span class="line">        stats realm HAPorxy\ Stats\ Page</span><br><span class="line">        stats auth haadmin:123456</span><br><span class="line">        stats auth admin:123456</span><br><span class="line">        stats refresh 30s</span><br><span class="line">        stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure>
<p>在浏览器访问,就可以管理haproxy</p>
<p><strong>修改报文首部</strong><br>在请求报文尾部添加指定首部<br>      reqadd  <string> [{if | unless} <cond>]    #支持条件判断<br>在响应报文尾部添加指定首部<br>       rspadd <string> [{if | unless} <cond>]<br>      示例：rspadd X-Via:\ HAPorxy<br>从请求报文中删除匹配正则表达式的首部<br>        reqdel  <search> [{if | unless} <cond>]<br>        reqidel <search> [{if | unless} <cond>] 不分大小写   </p>
<p>从响应报文中删除匹配正则表达式的首部<br>        rspdel  <search> [{if | unless} <cond>]<br>        rspidel <search> [{if | unless} <cond>]<br>        示例： rspidel  server.* #从相应报文删除server信息<br>         rspidel X-Powered-By:.*  #从响应报文删除X-Powered-By信息</p>
<p><strong>HAProxy日志配置</strong><br>在default配置项定义：</p>
<pre><code>log 127.0.0.1  local{1-7} info #基于syslog记录日志到指定设备，级别有(err、warning、info、debug)</code></pre><p>配置rsyslog：</p>
<pre><code>$ModLoad imudp
$UDPServerRun 514
local3.*    /var/log/haproxy.log</code></pre><p>配置HAProxy：</p>
<pre><code>listen  web_port
 bind 127.0.0.1:80
 mode http
 log global
option tcplog
 server web1  127.0.0.1:8080  check inter 3000 fall 2 rise 5</code></pre><p>重启syslog服务并访问haproxy状态页</p>
<p><strong>自定义日志记录</strong><br>将特定信息记录在日志中</p>
<pre><code>capture cookie &lt;name&gt; len &lt;length&gt; #捕获请求和响应报文中的 cookie并记录日志    
capture request header &lt;name&gt; len &lt;length&gt; #捕获请求报文中指定的首部内容和长度并记录日志
capture response header &lt;name&gt; len &lt;length&gt; #捕获响应报文中指定的内容和长度首部并记录日志</code></pre><p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">capture request  header Host len  256</span><br><span class="line">capture request header User-Agent len 512</span><br></pre></td></tr></table></figure>

<p><strong>压缩功能</strong></p>
<pre><code>compression algo   #启用http协议中的压缩机制，常用算法有gzip deflate
compression type  #要压缩的类型</code></pre><p>示例</p>
<pre><code>compression algo gzip
compression type compression type text/plain text/html text/css text/xml text/javascript application/javascript</code></pre><p><strong>web服务器状态监测</strong><br>option httpchk<br>option httpchk <uri><br>option httpchk <method> <uri><br>option httpchk <method> <uri> <version></p>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_prot_http_nodes</span><br><span class="line">    <span class="built_in">bind</span>  192.168.7.102:80</span><br><span class="line">    mode  http</span><br><span class="line">    <span class="built_in">log</span> global</span><br><span class="line">    option httpchk GET /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.0  <span class="comment">#基于指定URL</span></span><br><span class="line">    <span class="comment">#option httpchk HEAD /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.0\r\nHost:\ 192.168.7.102 #通过request获取的头部信息进行匹配进行健康检测</span></span><br><span class="line">     server 192.168.7.102  blogs.studylinux.net:80   check inter 3000 fall 3 rise 5</span><br><span class="line">     server 192.168.7.101 192.168.7.101:8080  cookie web1 check inter 3000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>ACL必须在haproxy工作在http模式下才可以使用。</p>
<ul>
<li>acl：对接收到的报文进行匹配和过滤，基于请求报文头部中的源地址、源端口、目标地址、目标端口、请求方法、URL、文件后缀等信息内容进行匹配并执行进一步操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acl &lt;aclname&gt;  &lt;criterion&gt;   [flags]           [operator]        [&lt;value&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>acl      名称             条件       条件标记位     具体操作符     操作对象类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acl   image_service hdr_dom(host)   -i   img.magedu.com</span><br></pre></td></tr></table></figure>

<ul>
<li>ACL名称，可以使用大字母A-Z、小写字母a-z、数字0-9、冒号：、点.、中横线和下划线，并且严格区分大小写，必须Image_site和image_site完全是两个acl。</li>
</ul>
<p><strong>Criterion-acl</strong><br>&lt;\criterion&gt; ：匹配条件<br>dst         目标IP<br>dst_port       目标PORT<br>src            源IP<br>src_port      源PORT</p>
<p>hdr &lt;\string&gt;用于测试请求头部首部指定内容</p>
<pre><code>hdr_dom(host)  请求的host名称，如 www.magedu.com
hdr_beg(host)  请求的host开头，如 www. img. video. download. ftp.
hdr_end(host)  请求的host结尾，如 .com .net .cn
path_beg   请求的URL开头，如/static、/images、/img、/css
path_end   请求的URL中资源的结尾，如 .gif  .png  .css  .js .jpg .jpeg</code></pre><p><strong>flags</strong><br>&lt;\flags&gt;-条件标记<br>    -i 不区分大小写<br>    -m 使用指定的pattern匹配方法<br>    -n 不做DNS解析<br>    -u 禁止acl重名，否则多个同名ACL匹配或关系<br>    –  强制flag结束. 当字符串和某个flag相似时使用</p>
<p><strong>operator</strong><br> [operator]-操作符：<br>  整数比较：eq、ge、gt、le、lt<br>  字符比较：</p>
<ul>
<li>exact match     (-m str) :字符串必须完全匹配模式</li>
<li>substring match (-m sub) :在提取的字符串中查找模式，如果其中任何一个被发现，ACL将匹配</li>
<li>prefix match    (-m beg) :在提取的字符串首部中查找模式，如果其中任何一个被发现，ACL将匹配</li>
<li>suffix match    (-m end) :将模式与提取字符串的尾部进行比较，如果其中任何一个匹配，则ACL进行匹配</li>
<li>subdir match    (-m dir) :查看提取出来的用斜线分隔（“/”）的字符串，如果其中任何一个匹配，则ACL进行匹配</li>
<li>domain match    (-m dom) :查找提取的用点（“.”）分隔字符串，如果其中任何一个匹配，则ACL进行匹配    </li>
</ul>
<p><strong>value</strong><br><value>的类型：<br>    - Boolean #布尔值<br>    - integer or integer range #整数或整数范围，比如用于匹配端口范围<br>    - IP address / network #IP地址或IP范围<br>    - string<br>         exact –精确比较<br>            substring—子串    <a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a><br>            suffix-后缀比较<br>            prefix-前缀比较<br>            subdir-路径， /wp-includes/js/jquery/jquery.js<br>            domain-域名，<a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a><br>    - regular expression #正则表达式<br>    - hex block #16进制</p>
<p><strong>ACL定义与调用</strong><br>acl作为条件时的逻辑关系：<br>    - 与：隐式（默认）使用<br>    - 或：使用“or” 或 “||”表示<br>    - 否定：使用“!“ 表示    </p>
<pre><code>示例：
         if   invalid_src invalid_port      与关系
    if invalid_src || invalid_port      或
    if ! invalid_src             非</code></pre><p>acl 示例-域名匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">  <span class="built_in">bind</span> 192.168.7.102:8800</span><br><span class="line">  mode http</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  acl  test_host  hdr_dom(host)   www.magedu.com</span><br><span class="line">  use_backend   test_host   <span class="keyword">if</span>   test_host</span><br><span class="line">  default_backend default_web <span class="comment">#以上都没有匹配到的时候使用默认backend</span></span><br><span class="line"></span><br><span class="line">backend test_host</span><br><span class="line">  mode http</span><br><span class="line">  server web1 www.magedu.com check inter 2000 fall 3 rise 5</span><br><span class="line"></span><br><span class="line">backend default_web</span><br><span class="line">  mode http</span><br><span class="line">  server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>acl 示例-源地址子网匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">  <span class="built_in">bind</span> 192.168.7.102:8800</span><br><span class="line">  mode http</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  acl ip_range_test src 192.168.4.0/24</span><br><span class="line">  use_backend   web2   <span class="keyword">if</span>  ip_range_test</span><br><span class="line">  default_backend web1</span><br><span class="line"></span><br><span class="line">backend web1</span><br><span class="line">  mode http</span><br><span class="line">  server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line"></span><br><span class="line">backend web2</span><br><span class="line">  mode http</span><br><span class="line">  server web1 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>acl 示例-源地址访问控制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">  <span class="built_in">bind</span> 192.168.7.102:8800</span><br><span class="line">  mode http</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  acl block_test src 192.168.7.103 192.168.7.104</span><br><span class="line">  block  <span class="keyword">if</span>  block_test</span><br><span class="line">  default_backend web1</span><br><span class="line"></span><br><span class="line">backend web1</span><br><span class="line">  mode http</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>acl示例-匹配浏览器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">  <span class="built_in">bind</span> 192.168.7.102:8800</span><br><span class="line">  mode http</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  acl block_test src 192.168.7.103 192.168.7.104</span><br><span class="line">  acl redirect_test hdr(User-Agent) -m sub  -i <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko"</span></span><br><span class="line">  block  <span class="keyword">if</span>  block_test</span><br><span class="line">  redirect prefix   http://192.168.7.101:8080 <span class="keyword">if</span> redirect_test</span><br><span class="line">  default_backend web2</span><br><span class="line">backend web1</span><br><span class="line">  mode http</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>自定义错误页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">errorfile 500  /usr/<span class="built_in">local</span>/haproxy/html/500.html <span class="comment">#自定义错误页面跳转</span></span><br><span class="line">errorfile 502  /usr/<span class="built_in">local</span>/haproxy/html/502.html</span><br><span class="line">errorfile 503  /usr/<span class="built_in">local</span>/haproxy/html/503.html</span><br><span class="line">errorloc 503  http://192.168.7.103/error_page/503.html</span><br></pre></td></tr></table></figure>


<p>基于acl+文件后缀实现动静分离</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">    <span class="built_in">bind</span> 192.168.7.102:80</span><br><span class="line">    mode http</span><br><span class="line">    acl php_server path_end  -i .php</span><br><span class="line">    use_backend php_server_host <span class="keyword">if</span> php_server</span><br><span class="line">    acl image_server path_end  -i .jpg .png .jpeg -gif</span><br><span class="line">    use_backend image_server_host <span class="keyword">if</span> image_server</span><br><span class="line">    default_backend default_host</span><br><span class="line">backend default_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">backend php_server_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">backend image_server_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>acl-匹配访问路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">    <span class="built_in">bind</span> 192.168.7.102:80</span><br><span class="line">    mode http</span><br><span class="line">    acl static_path  path_beg  -i  /static /images /javascript</span><br><span class="line">    use_backend static_path_host <span class="keyword">if</span> static_path</span><br><span class="line">    </span><br><span class="line">    default_backend default_host</span><br><span class="line">backend default_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">backend static_path_host </span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>http模式下基于策略的访问控制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">    <span class="built_in">bind</span> 192.168.7.102:80</span><br><span class="line">    mode http    </span><br><span class="line">    acl badguy_deny src 192.168.4.1</span><br><span class="line">    http-request deny <span class="keyword">if</span> badguy_deny</span><br><span class="line">    http-request allow</span><br><span class="line">    default_backend default_host</span><br><span class="line">backend default_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">backend static_path_host </span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">backend image_server_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<p>预定义acl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ACL name	Equivalent to	Usage</span><br><span class="line">FALSE	always_false	never match</span><br><span class="line">HTTP	req_proto_http	match <span class="keyword">if</span> protocol is valid HTTP</span><br><span class="line">HTTP_1.0	req_ver 1.0	match HTTP version 1.0</span><br><span class="line">HTTP_1.1	req_ver 1.1	match HTTP version 1.1</span><br><span class="line">HTTP_CONTENT	hdr_val(content-length) gt 0	match an existing content-length</span><br><span class="line">HTTP_URL_ABS	url_reg ^[^/:]*://	match absolute URL with scheme</span><br><span class="line">HTTP_URL_SLASH	url_beg /	match URL beginning with <span class="string">"/"</span></span><br><span class="line">HTTP_URL_STAR	url *	match URL equal to <span class="string">"*"</span></span><br><span class="line">LOCALHOST	src 127.0.0.1/8	match connection from <span class="built_in">local</span> host</span><br><span class="line">METH_CONNECT	method CONNECT	match HTTP CONNECT method</span><br><span class="line">METH_DELETE	method DELETE	match HTTP DELETE method</span><br><span class="line">METH_GET	method GET HEAD	match HTTP GET or HEAD method</span><br><span class="line">METH_HEAD	method HEAD	match HTTP HEAD method</span><br><span class="line">METH_OPTIONS	method OPTIONS	match HTTP OPTIONS method</span><br><span class="line">METH_POST	method POST	match HTTP POST method</span><br><span class="line">METH_PUT	method PUT	match HTTP PUT method</span><br><span class="line">METH_TRACE	method TRACE	match HTTP TRACE method</span><br><span class="line">RDP_COOKIE	req_rdp_cookie_cnt gt 0	match presence of an RDP cookie</span><br><span class="line">REQ_CONTENT	req_len gt 0	match data <span class="keyword">in</span> the request buffer</span><br><span class="line">TRUE	always_true	always match</span><br><span class="line">WAIT_END	wait_end	<span class="built_in">wait</span> <span class="keyword">for</span> end of content analysis</span><br></pre></td></tr></table></figure>

<p>预定义acl的使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen  web_port</span><br><span class="line">    <span class="built_in">bind</span> 192.168.7.102:80</span><br><span class="line">    mode http</span><br><span class="line">    acl static_path  path_beg  -i  /static /images /javascript</span><br><span class="line">    use_backend static_path_host <span class="keyword">if</span>  HTTP_1.1 TRUE static_path</span><br><span class="line">    default_backend default_host</span><br><span class="line"></span><br><span class="line">backend default_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">backend static_path_host </span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<h4 id="四层访问控制"><a href="#四层访问控制" class="headerlink" title="四层访问控制"></a>四层访问控制</h4><p>tcp-request connection {accept|reject}  [{if | unless} <condition>]  根据第4层条件对传入连接执行操作</p>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen redis-port</span><br><span class="line">    <span class="built_in">bind</span> 192.168.7.102:6379</span><br><span class="line">    mode tcp</span><br><span class="line">    balance leastconn</span><br><span class="line">    acl invalid_src src 192.168.1.0/24 192.168.7.101</span><br><span class="line">    tcp-request connection reject <span class="keyword">if</span> invalid_src</span><br><span class="line">    server server1 192.168.7.104:6379 check</span><br><span class="line">    server server1 192.168.7.103:6379 check backup</span><br></pre></td></tr></table></figure>

<h4 id="HAProxy-https协议"><a href="#HAProxy-https协议" class="headerlink" title="HAProxy-https协议"></a>HAProxy-https协议</h4><pre><code>配置HAProxy支持https协议： 
支持ssl会话；
    bind *:443 ssl crt /PATH/TO/SOME_PEM_FILE    
    crt 后证书文件为PEM格式，且同时包含证书和所有私钥    
        cat  demo.crt demo.key &gt; demo.pem 
把80端口的请求重向定443
    bind *:80
    redirect scheme https if !{ ssl_fc }    
向后端传递用户请求的协议和端口（frontend或backend）
    http_request set-header X-Forwarded-Port %[dst_port]
    http_request add-header X-Forwared-Proto https if { ssl_fc }</code></pre><p>https证书制作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># mkdir /usr/local/haproxy/certs</span></span><br><span class="line">~]<span class="comment"># cd /usr/local/haproxy/cert</span></span><br><span class="line">~]<span class="comment"># openssl  genrsa -out haproxy.key 2048</span></span><br><span class="line">~]<span class="comment"># openssl  req -new -x509 -key haproxy.key  -out haproxy.crt -subj "/CN=www.magedu.net"</span></span><br><span class="line">~]<span class="comment"># cat haproxy.key  haproxy.crt  &gt; haproxy.pem</span></span><br><span class="line">~]<span class="comment"># openssl  x509 -in  haproxy.pem -noout -text #查看证书</span></span><br></pre></td></tr></table></figure>

<p>配置haproxy支持https</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frontend https</span><br><span class="line">  <span class="built_in">bind</span> 192.168.7.102:443 ssl crt  /usr/<span class="built_in">local</span>/haproxy/certs/haproxy.pem</span><br><span class="line">  use_backend web_host</span><br><span class="line"></span><br><span class="line">backend default_host</span><br><span class="line">    mode http</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">    server web2 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br><span class="line"></span><br><span class="line">backend web_host</span><br><span class="line">    mode http</span><br><span class="line">    http-request <span class="built_in">set</span>-header X-Forwarded-Port %[dst_port]</span><br><span class="line">    http-request add-header X-Forwarded-Proto https <span class="keyword">if</span> &#123; ssl_fc &#125;</span><br><span class="line">    server web1 192.168.7.101:8080 check inter 2000 fall 3 rise 5</span><br><span class="line">    server web2 192.168.7.102:8080 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>

<h4 id="HAProxy服务器动态上下线"><a href="#HAProxy服务器动态上下线" class="headerlink" title="HAProxy服务器动态上下线"></a>HAProxy服务器动态上下线</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># echo "show info" | socat stdio /var/lib/haproxy/haproxy.sock</span></span><br><span class="line">~]<span class="comment"># echo "get weight web_host/192.168.7.101" | socat stdio /var/lib/haproxy/haproxy.sock </span></span><br><span class="line">~]<span class="comment"># echo "disable server  web_host/192.168.7.101" | socat stdio /var/lib/haproxy/haproxy.sock </span></span><br><span class="line">~]<span class="comment"># echo "enable  server  web_host/192.168.7.101" | socat stdio /var/lib/haproxy/haproxy.sock</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>HAProxy</tag>
        <tag>负载均衡器</tag>
      </tags>
  </entry>
  <entry>
    <title>AIDE</title>
    <url>/2018/06/20/AIDE/</url>
    <content><![CDATA[<h2 id="AIDE入门"><a href="#AIDE入门" class="headerlink" title="AIDE入门"></a>AIDE入门</h2><h3 id="AIDE是一个实现系统功能完整性检查的工具"><a href="#AIDE是一个实现系统功能完整性检查的工具" class="headerlink" title="AIDE是一个实现系统功能完整性检查的工具"></a>AIDE是一个实现系统功能完整性检查的工具</h3><p>如果有黑客使用木马程序替换掉你系统上的ps程序，以使用ps命令查不到正在运行的木马程序；<br>如果入侵者发现管理员正在运行crontab作业，也有可能替换掉crontab程序等等。<br>此时，就可以使用aide监控这些应用程序，以避免被篡改。</p>
<h3 id="yum安装AIDE"><a href="#yum安装AIDE" class="headerlink" title="yum安装AIDE"></a>yum安装AIDE</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">		$ yum -y install aide</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">### aide命令的使用</span></span><br><span class="line"></span><br><span class="line">**初始化生成数据库**</span><br><span class="line">```bash</span><br><span class="line">		$ aide -i</span><br></pre></td></tr></table></figure>

<p>生成的数据库放在/var/lib/aide目录中</p>
<p><strong>对比被监控文件是否有变化</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv /var/lib/aide/aide.db.&#123;new.gz,gz&#125; <span class="string">"修改数据库名称用于对比"</span></span><br><span class="line">$ aide -C</span><br></pre></td></tr></table></figure>

<p><strong>aide配置监控规则</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#sed -n '/^[^#]/p' /etc/aide.conf </span></span><br><span class="line">@@define DBDIR /var/lib/aide <span class="string">"数据库存放目录"</span></span><br><span class="line">@@define LOGDIR /var/<span class="built_in">log</span>/aide <span class="string">"日志存放目录"</span></span><br><span class="line">database=file:@@&#123;DBDIR&#125;/aide.db.gz <span class="string">"用于比较的数据库，默认不会自动生成，需要改名"</span></span><br><span class="line">database_out=file:@@&#123;DBDIR&#125;/aide.db.new.gz <span class="string">"使用aide -i生成的数据库"</span></span><br><span class="line">gzip_dbout=yes <span class="string">"是否支持压缩"</span></span><br><span class="line">verbose=5</span><br><span class="line">report_url=file:@@&#123;LOGDIR&#125;/aide.log</span><br><span class="line">report_url=stdout</span><br><span class="line"><span class="comment">###These are the default rules. "监控规则"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#p:      permissions</span></span><br><span class="line"><span class="comment">#i:      inode:</span></span><br><span class="line"><span class="comment">#n:      number of links</span></span><br><span class="line"><span class="comment">#u:      user</span></span><br><span class="line"><span class="comment">#g:      group</span></span><br><span class="line"><span class="comment">#s:      size</span></span><br><span class="line"><span class="comment">#b:      block count</span></span><br><span class="line"><span class="comment">#m:      mtime</span></span><br><span class="line"><span class="comment">#a:      atime</span></span><br><span class="line"><span class="comment">#c:      ctime</span></span><br><span class="line"><span class="comment">#S:      check for growing size</span></span><br><span class="line"><span class="comment">#acl:           Access Control Lists</span></span><br><span class="line"><span class="comment">#selinux        SELinux security context</span></span><br><span class="line"><span class="comment">#xattrs:        Extended file attributes</span></span><br><span class="line"><span class="comment">#md5:    md5 checksum</span></span><br><span class="line"><span class="comment">#sha1:   sha1 checksum</span></span><br><span class="line"><span class="comment">#sha256:        sha256 checksum</span></span><br><span class="line"><span class="comment">#sha512:        sha512 checksum</span></span><br><span class="line"><span class="comment">#rmd160: rmd160 checksum</span></span><br><span class="line"><span class="comment">#tiger:  tiger checksum</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#haval:  haval checksum (MHASH only)</span></span><br><span class="line"><span class="comment">#gost:   gost checksum (MHASH only)</span></span><br><span class="line"><span class="comment">#crc32:  crc32 checksum (MHASH only)</span></span><br><span class="line"><span class="comment">#whirlpool:     whirlpool checksum (MHASH only)</span></span><br><span class="line">FIPSR = p+i+n+u+g+s+m+c+acl+selinux+xattrs+sha256 <span class="string">"自定义监控规则组合"</span></span><br><span class="line">ALLXTRAHASHES = sha1+rmd160+sha256+sha512+tiger</span><br><span class="line">EVERYTHING = R+ALLXTRAHASHES</span><br><span class="line">NORMAL = sha256</span><br><span class="line">DIR = p+i+n+u+g+acl+selinux+xattrs</span><br><span class="line">PERMS = p+u+g+acl+selinux+xattrs</span><br><span class="line">STATIC = p+u+g+acl+selinux+xattrs+i+n+b+c+ftype</span><br><span class="line">LOG = p+u+g+n+acl+selinux+ftype</span><br><span class="line">CONTENT = sha256+ftype</span><br><span class="line">CONTENT_EX = sha256+ftype+p+u+g+n+acl+selinux+xattrs</span><br><span class="line">DATAONLY =  p+n+u+g+s+acl+selinux+xattrs+sha256</span><br><span class="line"></span><br><span class="line">/boot/ DIR <span class="string">"监控的目录，以及用哪个规则监控"</span></span><br></pre></td></tr></table></figure>

<p>导入光盘文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler import --path=/misc/cd/ --name=centos-6.10-x86_64 --arch=x86_64</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cobbler import --path=/app/httpd/htdocs/centos/7/os/x86_64 --name=centos-7.5-x86_64 --arch=x86_64</span></span><br></pre></td></tr></table></figure>

<p>此时会自动在/var/lib/cobbler/kickstarts/文件夹下生成两个最小化安装的应答文件。<br>在新建主机启动就可以自动基于http最小化安装系统。</p>
<p>查看系统distro列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler distro list</span></span><br><span class="line">  centos-6.10-x86_64</span><br><span class="line">  centos-7.5-x86_64</span><br><span class="line">  centos7.5-x86_64</span><br></pre></td></tr></table></figure>

<p>查看引导文件列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler profile list</span></span><br><span class="line">  centos-6.10-x86_64</span><br><span class="line">  centos-7.5-x86_64</span><br><span class="line">  centos7.5-x86_64</span><br></pre></td></tr></table></figure>

<p><strong>导入自制的应答文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler profile add --name=centos-7.5-x86_64_mini --distro=centos7.5-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks7-mini.cfh</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>AIDE</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2018/06/20/docker/</url>
    <content><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h3><p>c/s架构，分为docker client，docker daemon，docker register。彼此之间基于http或https进行通信。docker采用分层构建，依赖于特定的文件系统。<br>docker daemon包括containers和images<br>当client执行诸如docker build，docker pull，docker run等指令时，docker daemon首先会查看images中是否有该镜像，如果有就直接创建或启动，如果没有就会去register上下来该镜像然后创建或启动指定的容器。<br>container的状态有：running,stopped,paused,created,deleted;使用docker container ps或docker ps命令可以查看容器的状态；创建容器：docker create或docker run命令。<br>restful概念：一种分布式程序开发调用的API，一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<h3 id="docker-container"><a href="#docker-container" class="headerlink" title="docker container"></a>docker container</h3><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p><strong>配置yum源</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb yum.repos.d]<span class="comment">#wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>

<p><strong>安装docker</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb yum.repos.d]<span class="comment">#yum -y install docker-ce</span></span><br></pre></td></tr></table></figure>
<p>由于docker的官方镜像时国外服务器，有可能比较慢，此时可以借助国内的镜像加速器进行加速，例如使用阿里云的docker镜像加速器。(需要注册阿里云账号)<br>登录阿里云的主站点dev.aliyun.com，登录自己的账号，在产品与服务上找到容器镜像服务，然后点到镜像加速器就可以看到自己的加速器地址。按照操作文档的提示修改daemon配置文件后即可使用。</p>
<h4 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h4><h5 id="images："><a href="#images：" class="headerlink" title="images："></a>images：</h5><ul>
<li>pull：下载镜像</li>
<li>push：上传镜像</li>
<li>rm：删除镜像</li>
<li>tag：给镜像打标签</li>
</ul>
<h5 id="container"><a href="#container" class="headerlink" title="container"></a>container</h5><p><strong>创建容器</strong></p>
<ul>
<li>docker create</li>
<li>docker run<blockquote>
<p>-t,–tty 指定一个终端<br>  -i,–interactive 交互式<br>  –name string 指定容器的名字<br>  –rm 容器停止时删除该容器<br>  -d 后台运行，并打印容器的ID</p>
</blockquote>
</li>
</ul>
<p><strong>删除容器</strong></p>
<ul>
<li>docker container rm name或docker rm name，删除容器时，容器内部的数据都会丢失，慎用。</li>
</ul>
<p><strong>在容器内执行命令</strong><br>docker container exec [选项] 容器 命令</p>
<ul>
<li>docker container exec -it redis /bin/sh 在redis内部以交互式的方式打开一个终端，运行/bin/sh程序</li>
<li>docker container exec redis netstat -ntl 在redis容器内部执行netstat -ntl命令，执行完命令后吧结果输出到当前终端，并退出容器。</li>
</ul>
<p><strong>查看容器的详细信息</strong></p>
<ul>
<li>docker container inspect container… 查看一个或多个容器的详细信息</li>
</ul>
<p><strong>查看容器资源占用情况</strong></p>
<ul>
<li>docker container stats container-name</li>
</ul>
<p><strong>查看容器内运行的所有进程的相关信息</strong></p>
<ul>
<li>docker container top container-name</li>
</ul>
<p><strong>进入某container</strong><br>docker container attach cotainer-name</p>
<h5 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h5><ul>
<li>docker container logs [options] container</li>
</ul>
<h4 id="使用docker管理容器"><a href="#使用docker管理容器" class="headerlink" title="使用docker管理容器"></a>使用docker管理容器</h4><p>使用docker search 关键词可以搜索想要使用的仓库，仓库分为顶层仓库(官方维护)和属于某组织或个人的仓库，也可以在docker官方站点搜索仓库<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<p><strong>下载redis镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb docker]<span class="comment">#docker pull redis:4-alpine</span></span><br><span class="line">4-alpine: Pulling from library/redis</span><br><span class="line">cd784148e348: Pull complete </span><br><span class="line">48d4c7155ddc: Pull complete </span><br><span class="line">6d908603dbe8: Pull complete </span><br><span class="line">fd4371c1c78e: Pull complete </span><br><span class="line">e6818dc808c2: Pull complete </span><br><span class="line">f1884d594f6f: Pull complete </span><br><span class="line">Digest: sha256:775bbf766a5b711acce88e4142faf56cd587d63ddc4d57b49f7872f71d56fab6</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:4-alpine</span><br><span class="line">[root@mariadb docker]<span class="comment">#docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               4-alpine            37abb58bfd68        12 days ago         30MB</span><br></pre></td></tr></table></figure>
<p><strong>基于下载的image启动一个容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name redis -d redis:4-alpine</span><br></pre></td></tr></table></figure>

<h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>docker镜像含有启动容器所需要的文件系统及其内容，因此，其用于创建并启动docker容器。<br>image采用分层构建机制，最底层为bootfs，其次为rootfs</p>
<ul>
<li>bootfs：用于系统引导的文件系统，包括BootLoader和kernel，容器启动完成后会被卸载以节约内存资源。</li>
<li>rootfs位于bootfs之上，表现为dicker容器的根文件系统<blockquote>
<p>传统模式中，系统启动时，内核挂载rootfs时会首先将其挂载为”只读”模式，完整性自检完成后将其重新挂在为读写模式。<br>  docker中，rootfs由内核挂载为”只读”模式，而后通过”联合挂载”技术额外挂载一个”可写”层。</p>
</blockquote>
</li>
</ul>
<p><strong>Aufs</strong><br>advanced multi-layered unification filesystem : 高级多层同一文件系统<br>用于为linux文件系统实现”联合挂载”<br>aufs时之前的unionfs的重新实现<br>dicker最初使用aufs作为容器文件系统层，它目前仍作为存储后端之一来支持<br>aufs的竞争产品时overlayfs，后者自从3.18版本开始被合并到linux内核<br>docker的分层镜像，除了aufs，还有btrfs、devicemapper和vfs等</p>
<ul>
<li>在Ubuntu系统下，docker默认使用Ubuntu的aufs，而在早期centos7上，用的是devicemapper。</li>
</ul>
<h3 id="docker-registry"><a href="#docker-registry" class="headerlink" title="docker registry"></a>docker registry</h3><p>启动容器时，docker daemon会试图从本地获取相关的镜像，本地镜像不存在时，其将从registry重下载该镜像并保存到本地。</p>
<p><strong>自制镜像</strong><br>创建自己的container后，在container上做了修改之后可以基于该container创建image，在创建image时不要停止container</p>
<ul>
<li>docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</li>
</ul>
<p>例如：docker container commit redis myimg/redis:v0.1</p>
<p>自制镜像后，可以将自制的镜像推到个人docker账号的仓库中<br>docker image push name[:tag]</p>
<p><strong>给已有的镜像打标签</strong></p>
<ul>
<li>docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</li>
</ul>
<h3 id="docker网络的实现"><a href="#docker网络的实现" class="headerlink" title="docker网络的实现"></a>docker网络的实现</h3><p><strong>封闭式网络</strong></p>
<ul>
<li>docker run -it –rm –network none –name tinyweb1 busybox</li>
</ul>
<p>上述命令以busybox为image创建一个封闭式网络的container tinyweb1，此container只有lo接口。</p>
<p><strong>bridge网络</strong><br>bridge网络可以实现不同的容器共用一个网络名称空间，而除了网络空间之外，其余的空间都是相互隔离的，这就能实现将amp分别放在不同的容器中运行，而让各自只监听127.0.0.1网址，依然能彼此通信。<br>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker run -it --rm --network bridge --name tinyweb1 busybox</span></span><br><span class="line">/ <span class="comment"># mkdir data</span></span><br><span class="line">/ <span class="comment"># cd /data/</span></span><br><span class="line">/data <span class="comment"># vi index.html</span></span><br><span class="line">/data <span class="comment"># httpd -h /data/</span></span><br><span class="line">/data <span class="comment"># wget -O - -q 127.0.0.1</span></span><br><span class="line">This is a <span class="built_in">test</span></span><br><span class="line">/data <span class="comment"># ps aux</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 sh</span><br><span class="line">   16 root      0:00 httpd -h /data/</span><br><span class="line">   20 root      0:00 ps aux</span><br><span class="line">[root@mariadb ~]<span class="comment">#docker run --name joinedc1 -it --rm --network container:tinyweb1 busybox</span></span><br><span class="line">/ <span class="comment"># wget -O - -q 127.0.0.1</span></span><br><span class="line">This is a <span class="built_in">test</span></span><br><span class="line">/ <span class="comment"># ps aux</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 sh</span><br><span class="line">   11 root      0:00 ps aux</span><br></pre></td></tr></table></figure>
<p>说明，上述分别创建了两个容器，在容器tinyweb1上运行httpd服务，容器joinedc1指定network为与tinyweb1共享网络，此时在容器joinedc1上访问127.0.0.1，能够访问容器tinyweb1上的httpd服务，说明两个容器在使用同一网络空间，而使用ps aux查看两个容器上运行的服务不同，说明两个容器仅共享网络空间，这就能实现上述所说的在不同的容器中运行amp，mp仅监听127.0.0.1地址，依然能实现彼此之间的通信的功能。</p>
<p><strong>host网络</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker run --name tinyweb1 -it --rm --network host busybox</span></span><br></pre></td></tr></table></figure>

<p>使用该命令创建的container和宿主机共用一个网络名称空间。<br>此外，docker创建container时还支持直接注入hosts解析和dns服务器，</p>
<ul>
<li>–add-host list    Add a custom host-to-IP mapping (host:ip)</li>
<li>–dns list       Set custom DNS servers</li>
<li>–dns-search list      Set custom DNS search domains</li>
</ul>
<p>docker在创建container时，还可以指定将container的某个端口映射至主机的某个端口上，这就要使用-p选项，-p的使用格式有四种：<br>-p, –publish list     Publish a container’s port(s) to the host</p>
<ul>
<li>-p &lt; containerPort&gt; 将指定的容器端口映射至主机所有地址的一个动态端口</li>
<li>-p &lt; hostPort&gt;:&lt; containerPort&gt; 将容器端口映射至指定的主机端口</li>
<li>-p &lt; ip&gt;::&lt; containerPort&gt; 将指定的容器端口映射至主机指定ip的动态端口</li>
<li>-p &lt; ip&gt;:&lt; hostPort&gt;:&lt; containerPort&gt; 将指定的容器端口映射至主机指定ip的端口</li>
</ul>
<p>其中”动态端口”指的是随机端口，具体的映射结果可使用dicker port命令查看</p>
<h4 id="创建网络名称空间"><a href="#创建网络名称空间" class="headerlink" title="创建网络名称空间"></a>创建网络名称空间</h4><p>docker可以手动创建网络名称空间，然后将container加入指定的网络名称空间</p>
<pre><code>[root@mariadb ~]#docker network create --help
Usage:    docker network create [OPTIONS] NETWORK
Create a network
Options:
      --attachable           Enable manual container attachment
      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])
      --config-from string   The network from which copying the configuration
      --config-only          Create a configuration only network
  -d, --driver string        Driver to manage the Network (default &quot;bridge&quot;)
      --gateway strings      IPv4 or IPv6 Gateway for the master subnet
      --ingress              Create swarm routing-mesh network
      --internal             Restrict external access to the network
      --ip-range strings     Allocate container ip from a sub-range
      --ipam-driver string   IP Address Management Driver (default &quot;default&quot;)
      --ipam-opt map         Set IPAM driver specific options (default map[])
      --ipv6                 Enable IPv6 networking
      --label list           Set metadata on a network
  -o, --opt map              Set driver specific options (default map[])
      --scope string         Control the network&apos;s scope
      --subnet strings       Subnet in CIDR format that represents a network segment</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker network create --subnet 10.10.0.0/24 mybr0</span></span><br><span class="line">5b1543c1500084026c08eec4a34d84f85452c975a013aa6c55c18addc9550e40</span><br><span class="line">[root@mariadb ~]<span class="comment">#docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8787fa490049        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">afb6f1041481        host                host                <span class="built_in">local</span></span><br><span class="line">5b1543c15000        mybr0               bridge              <span class="built_in">local</span></span><br><span class="line">30376c034536        none                null                <span class="built_in">local</span></span><br><span class="line">[root@mariadb ~]<span class="comment">#docker run --name web -d --network mybr0 -p 80:80 nginx:1.15-alpine</span></span><br><span class="line">[root@mariadb ~]<span class="comment">#docker container exec -it web /bin/sh</span></span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:0A:0A:00:02  </span><br><span class="line">          inet addr:10.10.0.2  Bcast:10.10.0.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:1569 (1.5 KiB)  TX bytes:504 (504.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure>

<p>此外，还可以将容器connect至指定的network上，此时相当于container上多了一块网卡,还可已使用disconnect命令将container从指定的接口上拔下来。</p>
<pre><code>[root@mariadb ~]#docker network connect --help
Usage:    docker network connect [OPTIONS] NETWORK CONTAINER
Connect a container to a network
Options:
      --alias strings           Add network-scoped alias
                                for the container
      --ip string               IPv4 address (e.g.,
                                172.30.100.104)
      --ip6 string              IPv6 address (e.g.,
                                2001:db8::33)
      --link list               Add link to another container
      --link-local-ip strings   Add a link-local address
                                for the container</code></pre><p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker container exec -it web /bin/sh</span></span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:0A:0A:00:02  </span><br><span class="line">          inet addr:10.10.0.2  Bcast:10.10.0.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:648 (648.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">[root@mariadb ~]<span class="comment">#docker network connect bridge web</span></span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:0A:0A:00:02  </span><br><span class="line">          inet addr:10.10.0.2  Bcast:10.10.0.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:648 (648.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02  </span><br><span class="line">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:6 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:508 (508.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure>

<p>docker自带的bridge桥的ip时172.17.0.1，这个默认的ip也是可以修改的，在/etc/docker/daemon.json文件中定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://gwtcf0z6.mirror.aliyuncs.com"</span>],</span><br><span class="line">  <span class="string">"bip"</span>: <span class="string">"172.31.0.1/16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启docker后生效。</p>
<h3 id="docker存储卷"><a href="#docker存储卷" class="headerlink" title="docker存储卷"></a>docker存储卷</h3><p>docker镜像是由多个只读层叠加而成，启动容器时，docker会加载只读镜像层并在镜像栈顶部添加一个读写层<br>如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，此即”写时复制(COW)”机制。<br>关闭并重启容器，其数据不受影响；但删除docker容器，则其更改将会全部丢失，此时存在以下问题：</p>
<ul>
<li>存储于联合文件系统中，不易于宿主机访问</li>
<li>容器间数据共享不便</li>
<li>删除容器其数据会丢失</li>
</ul>
<p>此时，就需要引入卷(volunme)来解决这些问题，卷是容器上的一个或多个”目录”，此类目录可绕过联合文件系统，与宿主机上的某目录”绑定(关联)”，此volunme就类似一个传送门，可以让container和宿主机之间传输文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker run --name web -v /mydata -it --rm busybox</span></span><br></pre></td></tr></table></figure>
<p>此时创建的container会自动生成/mydata目录，此目录映射到宿主机上的一个目录，即实现了容器和宿主机之间的文件共享，使用rm命令删除container时，宿主机上的卷是不会删除的，这就实现了在container生命周期结束时，container中的数据依然保留。但是此时的宿主机上的目录是自动生成的，可以使用如下方法指定宿主机的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker run --name web -v /data/volumes/v1:/mydata -it --rm busybox</span></span><br></pre></td></tr></table></figure>
<p>使用上述命令创建的容器，容器中的/mydata目录和宿主机上的/data/volumes目录之间共享目录，如果此时让另一个容器仍然映射到/data/volumes目录，就可以实现容器之间共享目录的功能，相当于将宿主机上的目录挂在到容器上。</p>
<p>–volume-from container选项可以实现容器之间目录的共享</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#docker run --name web --volumes-from web -it --rm busybox</span></span><br></pre></td></tr></table></figure>

<h2 id="实验：使用docker以容器化方式运行lamp-WordPress架构"><a href="#实验：使用docker以容器化方式运行lamp-WordPress架构" class="headerlink" title="实验：使用docker以容器化方式运行lamp+WordPress架构"></a>实验：使用docker以容器化方式运行lamp+WordPress架构</h2><h3 id="创建一个mysql容器，其数据目录使用卷的方式放在宿主机上，并在mysql上创建WordPress专用的数据和账号"><a href="#创建一个mysql容器，其数据目录使用卷的方式放在宿主机上，并在mysql上创建WordPress专用的数据和账号" class="headerlink" title="创建一个mysql容器，其数据目录使用卷的方式放在宿主机上，并在mysql上创建WordPress专用的数据和账号"></a>创建一个mysql容器，其数据目录使用卷的方式放在宿主机上，并在mysql上创建WordPress专用的数据和账号</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker ~]<span class="comment">#docker image pull mysql:latest</span></span><br><span class="line">[root@docker ~]<span class="comment">#docker run --name db -d -v /data/volumes/mysql/:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:latest</span></span><br><span class="line">[root@docker ~]<span class="comment">#docker container exec -it db /bin/sh </span></span><br><span class="line"><span class="comment"># mysql -p123456</span></span><br><span class="line">mysql&gt; create user wpuser@<span class="string">'172.17.0.%'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">mysql&gt; create database wpdb;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">mysql&gt; grant all on wpdb.* to wpuser@<span class="string">'172.17.0.%'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>这里有一点需要注意，就是本次实验室用的是mysql的最新版本即8.x版本的，而8.x版本默认的认证方式是caching_sha2_password而非mysql_native_password。这会导致WordPress连接数据库失败，解决办法有以下两种。<br><strong>第一种：修改my.cnf文件更改认证方式并重启mysql</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker ~]<span class="comment">#vi my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br></pre></td></tr></table></figure>

<p><strong>第二种：兼容新老版本的认证方式</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user wpuser@'172.17.0.%' identified by 'centos' password expire never; #修改加密规则</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br><span class="line">mysql&gt; alter user wpuser@'172.17.0.%' identified with mysql_native_password by 'centos'; #更新用户密码</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">mysql&gt; flush privileges; #刷新权限</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="comment">--创建新用户时使用以下语句，mysql8.x版本不支持授权的同时创建用户，只能分开来写。</span></span><br><span class="line">mysql&gt;create user root@'%' identified WITH mysql_native_password BY 'root';</span><br><span class="line">mysql&gt;grant all privileges on *.* to root@'%' with grant option;</span><br><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个centos容器，运行httpd-php"><a href="#创建一个centos容器，运行httpd-php" class="headerlink" title="创建一个centos容器，运行httpd+php"></a>创建一个centos容器，运行httpd+php</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker ~]<span class="comment">#docker image pull centos:7 #从registry拉取centos7的image</span></span><br><span class="line">[root@docker ~]<span class="comment">#docker run -it -d --name apache -v /data/volumes/wp/:var/www/html/ -h apache centos:7 #基于拉取的image创建一个用于跑httpd+php的容器</span></span><br><span class="line"><span class="comment"># 之后下载WordPress解压后放入宿主机的/data/volumes/wp/目录下并修改WordPress的配置文件</span></span><br><span class="line">[root@docker worpress]<span class="comment">#mv wp-config-sample.php wp-config.php</span></span><br><span class="line"> [root@docker worpress]<span class="comment">#vi wp-config.php</span></span><br><span class="line"> /** WordPress数据库的名称 */</span><br><span class="line">define(<span class="string">'DB_NAME'</span>, <span class="string">'wpdb'</span>);</span><br><span class="line"></span><br><span class="line">/** MySQL数据库用户名 */</span><br><span class="line">define(<span class="string">'DB_USER'</span>, <span class="string">'wpuser'</span>);</span><br><span class="line"></span><br><span class="line">/** MySQL数据库密码 */</span><br><span class="line">define(<span class="string">'DB_PASSWORD'</span>, <span class="string">'centos'</span>);</span><br><span class="line"></span><br><span class="line">/** MySQL主机 */</span><br><span class="line">define(<span class="string">'DB_HOST'</span>, <span class="string">'172.17.0.2'</span>);</span><br><span class="line">[root@docker ~]<span class="comment">#docker container exec -it apache /bin/bash #进入container</span></span><br><span class="line">[root@apache html]<span class="comment">#yum -y install httpd php php-mysql #安装相关包</span></span><br><span class="line">[root@apache html]<span class="comment">#httpd #启动httpd</span></span><br></pre></td></tr></table></figure>
<h3 id="使用lvs做前端负载均衡器，就可以管理该WordPress站点"><a href="#使用lvs做前端负载均衡器，就可以管理该WordPress站点" class="headerlink" title="使用lvs做前端负载均衡器，就可以管理该WordPress站点"></a>使用lvs做前端负载均衡器，就可以管理该WordPress站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker wp]<span class="comment">#yum -y install ipvsadm</span></span><br><span class="line">[root@docker wp]<span class="comment">#modprobe ip_vs</span></span><br><span class="line">[root@docker wp]<span class="comment">#ipvsadm -A -t 192.168.34.102:80(vip) -s wrr </span></span><br><span class="line">[root@docker wp]<span class="comment">#ipvsadm -a -t 192.168.34.102:80(vip) -r 172.17.0.3(rip) -m</span></span><br></pre></td></tr></table></figure>
<p>此时，在浏览器输入vip，就可以登入管理自己的WordPress站点，实验完毕。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>lvs</title>
    <url>/2018/06/18/lvs/</url>
    <content><![CDATA[<h2 id="LB-cluster"><a href="#LB-cluster" class="headerlink" title="LB cluster"></a>LB cluster</h2><p>一个创业公司刚刚起步的时候一般都是单机在跑，但是随着公司规模的不断扩大，当前的服务器已经不能够满足实际需要的时候，就需要扩展(Scale)，扩展的方式有两种：<br>Up，向上扩展，又称垂直扩展，即提升硬件水平<br>Out，向外扩展，横向扩展，提升服务器数量，即采用集群的方式提供服务</p>
<p>然而，受制于技术水平，向上扩展很快会受限，大部分正常的选择是向外扩展，<br>当服务其数量达到一定规模，形成一个集群时，就需要做一个负载均衡集群(LB cluster)(Load balance cluster)，此时就需要一个director负责调度分发请求，让各个web服务器根据分配的weighted进行接收处理请求。</p>
<p>如果有对个Web服务器，就涉及到会话保持的问题，即http是无状态的，而应用程序有事却需要状态追踪，那么如何进行状态追踪呢？<br>session 会话保持的三种方法</p>
<ul>
<li>session sticky 会话粘滞，同一用户始终调度到同一服务器，会损害负载均衡的效果，如果某服务器突然宕机，还会导致session丢失</li>
<li>session replication 会话共享，即将session传输到所有的服务器上，每个服务器中都保存所有的session，但是会大大web服务器的负载。</li>
<li>session server 搭建session服务器，将所有的session都放在专门的服务器上，所有的web服务器都要到session服务器上读取session，session可以采用redis、memcached等高性能存储解决方案。此时要考虑session server的高可用问题。</li>
</ul>
<h3 id="LB-cluster集群的实现"><a href="#LB-cluster集群的实现" class="headerlink" title="LB cluster集群的实现"></a>LB cluster集群的实现</h3><p>LB cluster需要使用调度器实现调度功能<br>七层调度：工作在应用层，由于七层调度每调度一次都要使用一个套接字进行主机到主机之间通信，而主机的端口又是有限制的，所以七层调度调度能力低，支持并发量小于4w<br>四层调度：内核级调度，调度能力高</p>
<p>负载的分类<br>硬负载：F5的big ip，A10的A10<br>软负载：</p>
<ul>
<li>四层：LVS,Nginx(stream),HAProxy(mod tcp)…</li>
<li>七层：Nginx,HAProxy,Envoy…</li>
</ul>
<h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>LVS,是四层负载均衡器，全称Linux Virtual Server<br>LVS有两部分组成<br><strong>ipvsadm</strong>：用户空间的命令行工具，规则管理器，用于管理集群服务及相关的RealServer<br><strong>ipvs</strong>：工作于内核空间的netfilter的INPUT钩子之上的框架，ipvs工作于INPUT链上，如果数据报文符合ipvsadm定义的规则，则ipvs会强行将请求转换到FORWARD链上，甚至直接转换到postrouting链上。<br>ipvs是直接被整合到内核中的一个模块，使用只需装载一下即可(modeprobe ip_vs).</p>
<h3 id="LVS的算法"><a href="#LVS的算法" class="headerlink" title="LVS的算法"></a>LVS的算法</h3><p>ipvs的调度算法(10种)，根据其调度室是否考虑各RS当前负载状态，可分为静态方法和动态方法两种。<br><strong>静态算法</strong>：仅根据算法本身和请求报文特征进行调度，注重起点公平</p>
<ul>
<li><p>rr：round-robin，轮询，依次将请求调度到各RS，</p>
</li>
<li><p>wrr：weighted-round-robin，加权轮询，对每个RS分配权重，权重越大的承载能力越高，将请求按照权重的比例调度到各RS，wrr算法是短链接无状态的最好算法(http)。</p>
</li>
<li><p>sh：source ip hashing 源地址哈希，即对请求的源地址进行哈希计算，将计算结果对权重之和取模之后，将请求调度给排在取模之后的数值对应的RS上(RS从0开始计数)，来自同一个客户端的请求每次都调度给同一个服务器，对需要会话追踪的连接，例如fpm集群，电商站点，应用程序服务器等情况下比较实用，因为sh能实现同一客户端始终绑定到同一real server上。</p>
<blockquote>
<p>sh算法的缺点<br>  如果RS宕机会造成session丢失<br>  增加RS服务器负载<br>  如果一个公网ip背后有多个私网主机进行访问，那么这些主机会被当成同一个client，这会对负载均衡的效果产生严重的负面影响。</p>
</blockquote>
</li>
<li><p>dh：destination ip hashing 目标地址哈希，用在内网访问外网的情况，例如内网很多台主机，为了提高访问速度，对内网用户做集群，通过调度分别分发道不同的代理服务器上向外发送请求报文，此时对内网发出的请求报文做dh，就能保证对同一目标服务器的访问始终都通过同一代理服务器发出，此时代理服务器上的缓存使用率就更高。</p>
</li>
</ul>
<p><strong>动态算法</strong>：额外考虑后端个RS的当前的负载状态，注重结果公平</p>
<ul>
<li>lc：least connection,最少连接算法，将请求调度给负载最低的RS，如果各RS的负载相同，则调度给最上面的服务器，计算RS负载的算法为：overhead=activeconns*256+inactiveconns;</li>
<li>wlc:weighted lc：加权最少连接算法，将请求调度给负载最低的RS，算法为：overhead=(activeconns+*256+inactiveconns)/weighted；wlc算法是lvs的默认算法。长连接的mysql连接的最好算法。</li>
<li>sed:shortest expect delay最短期望延迟，如果后端RS的负载相同时，将请求调度给权重最大的RS。算法为：overhead=((activeconns+1)*256+inactiveconns)/weighted</li>
<li>nq：never queue永不排队，将请求先按权重从大小依次分一个给各RS，然后将后面的请求再按照权重分给各RS。</li>
<li>lblc：locality-based LC,动态的DH算法；缺点：影响负载均衡的效果。</li>
<li>lblcr：LBLC with Replication，带复制功能的LBLC</li>
</ul>
<h3 id="LVS-Type"><a href="#LVS-Type" class="headerlink" title="LVS Type"></a>LVS Type</h3><p>LVS集群的四种类型</p>
<ul>
<li><p>lvs-nat：修改请求报文的目标ip(和端口)，多目标ip的DNAT；通过将请求报文中的目标地址和目标端口修改为某挑出的RS的rip和port实现转发</p>
<blockquote>
<p>rip和dip必须在同一个ip网络，且应该使用私网地址，RS的网关要指向dip<br>请求报文和响应报文都必须经由director转发，director易于称为系统瓶颈<br>支持端口映射，可修改请求报文的目标port<br>vs必须是linux系统，rs可以使任意系统</p>
</blockquote>
</li>
<li><p>lvs-dr：director routing，直接路由。通过为请求报文重新封装一个MAC首部进行转发，源MAC是DIP所在的接口的MAC，目标MAC是某挑选出的RS的rip所在接口的MAC地址，源ip/port，以及目标ip/port均保持不变<br>director和各RS都得配置实用VIP</p>
<blockquote>
<p>确保前端路由器将目标ip为vip的请求报文发往director，做法有以下几种：1.在前端网关做静态绑定；2.在RS上使用arptables；3.在RS上修改内核参数以限制arp通告及应答级别：</p>
</blockquote>
<blockquote>
<p>arp_announce<br>  0：默认值，表示可使用本地任意接口上配置的任意地址进行响应；<br>  1: 仅在请求的目标IP配置在本地主机的接收到请求报文接口上时，才给予响应；</p>
</blockquote>
<blockquote>
<p>arp_ignore<br>  0：默认值，把本机上的所有接口的所有信息向每个接口上的网络进行通告；<br>  1：尽量避免向非直接连接网络进行通告；<br>  2：必须避免向非本网络通告；</p>
</blockquote>
<blockquote>
<p>RS的rip可以使用私网地址，也可以是公网地址；rip与dip在同一ip网络，rip的网关不能指向dip，以确保响应报文不会经由director</p>
</blockquote>
<blockquote>
<p>RS跟director要在同一个物理网络</p>
</blockquote>
<blockquote>
<p>请求报文要经由director，但是响应报文不能经由director，而是有RS直接发往client</p>
</blockquote>
<blockquote>
<p>不支持端口映射</p>
</blockquote>
</li>
<li><p>lvs-tun：转发方式：不修改请求报文的ip首部(源ip为cip，目标ip为vip)，而是在源ip报文之外再封装一个ip首部(源ip是dip，目标ip是rip)，将报文发往挑选出的目标RS，RS直接响应给客户端(源ip是vip，目标ip是cip)；采用ip隧道的方式</p>
<blockquote>
<p>DIP,VIP,RIP都应该是公网地址<br>  RS的网关不能也不可能指向DIP<br>  请求报文要经由director，但是响应报文不能经由director<br>  不支持端口映射<br>  RS的OS得支持隧道功能</p>
</blockquote>
</li>
<li><p>lvs-fullnat：通过同时修改请求报文的源ip地址和目标ip地址进行转发，此类型默认不支持<br>CIP &lt;–&gt; DIP<br>VIP &lt;–&gt; RIP</p>
<blockquote>
<p>VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网段，因此，RIP的网关一般不会指向DIP<br>  RS收到的请求报文源地址是DIP，因此，只能响应给DIP；但是director还要将其发往client<br>  请求和响应报文都经由director<br>  支持端口映射</p>
</blockquote>
</li>
</ul>
<p><strong>总结</strong>：<br>lvs-nat, lvs-fullnat：请求和响应报文都经由Director；</p>
<ul>
<li>lvs-nat：RIP的网关要指向DIP；</li>
<li>lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信；</li>
</ul>
<p>lvs-dr, lvs-tun：请求报文要经由Director，但响应报文由RS直接发往Client；</p>
<ul>
<li>lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发；</li>
<li>lvs-tun：通过在原IP报文之外封装新的IP首部实现转发，支持远距离通信；</li>
</ul>
<h3 id="实验：LVS-nat模式验证"><a href="#实验：LVS-nat模式验证" class="headerlink" title="实验：LVS-nat模式验证"></a>实验：LVS-nat模式验证</h3><p>在主机上建立两个容器运行web服务，在宿主机上做ipvs规则，把宿主机当做director，测试nat模式的负载均衡效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker ~]<span class="comment">#docker run --name web1 -d -v /data/volumes/web1:/usr/shsre/nginx/html/ nginx:1.15-alpine </span></span><br><span class="line">[root@docker ~]<span class="comment">#docker run --name web2 -d -v /data/volumes/web2:/usr/share/nginx/html/ nginx:1.15-alpine</span></span><br><span class="line">[root@docker ~]<span class="comment">#echo web1 &gt; /data/volums/web1/index.html</span></span><br><span class="line">[root@docker ~]<span class="comment">#echo web2 &gt; data/volumes/web2/index.html</span></span><br><span class="line">[root@docker ~]<span class="comment">#ipvsadm -A -t 192.168.34.102:80(vip) -s mrr</span></span><br><span class="line">[root@docker ~]<span class="comment">#ipvsadm -a -t 192.168.34.102:80 -r 172.17.0.3(rip1) -m</span></span><br><span class="line">[root@docker ~]<span class="comment">#ipvsadm -a -t 192.168.34.102:80 -r 172.17.0.4(rip2) -m</span></span><br><span class="line">[root@docker ~]<span class="comment">#for i in `seq 10`;do curl 192.168.34.102;sleep .5 ;done #在客户端做访问测试，此时可以看到nat模式的工作效果</span></span><br></pre></td></tr></table></figure>
<p>这里存在一个问题，就是docker会自动将FORWARD链的默认策略修改为DROP，这就可能导致调度存在问题，可以通过修改docker的unit文件，在每次docker启动后都自动把FORWARD链的默认策略改为ACCEPT。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /var/lib/systemcd/system/docker.service</span><br><span class="line">[Service]</span><br><span class="line">ExecStartPost=/usr/sbin/iptables -P FORWARD -j ACCEPT</span><br></pre></td></tr></table></figure>


<h3 id="实验：lvs-dr模式验证"><a href="#实验：lvs-dr模式验证" class="headerlink" title="实验：lvs-dr模式验证"></a>实验：lvs-dr模式验证</h3><p>本实验采用三台服务器演示分别为ansible(192.168.34.103)做director，apache(192.168.34.108)做RS1，docker(192.168.34.102)做RS2<br>在RS1和RS2上分别部署web服务<br>采用dr模式，需要在每台服务器都配置vip，这会造成IP地址冲突的现象，所以要在RS修改内核参数，隐藏vip，而只将director的vip公布出来。</p>
<p>配置RS1,RS2的web服务，这里为了体现负载均衡效果，分别采用各自主机名做站点内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker ~]<span class="comment">#echo docker &gt; /var/www/html/index.html</span></span><br><span class="line">[root@docker ~]<span class="comment">#curl 192.168.34.102</span></span><br><span class="line">docker</span><br><span class="line">[root@apache ~]<span class="comment">#echo apache &gt; /var/www/html/index.html</span></span><br><span class="line">[root@apache ~]<span class="comment">#curl 192.168.34.108</span></span><br><span class="line">apache</span><br></pre></td></tr></table></figure>

<p>配置director的vip</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ifconfig ens33:0 192.168.34.123 netmask 255.255.255.255 broadcast 192.168.34.123 #现在director上配置vip，配置32位的子网掩码，并将广播只发给自己，防止干扰局域网通信。</span></span><br></pre></td></tr></table></figure>

<p>采用脚本的方式修改RS的内核参数并配置RS的vip，并将该脚本在各RS上分别执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker scripts]<span class="comment">#cat setlpara.sh </span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">vip=192.168.34.123</span><br><span class="line">mask=255.255.255.255</span><br><span class="line">interface=<span class="string">"lo:0"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">	<span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">	<span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">	<span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">	<span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line"></span><br><span class="line">	ifconfig <span class="variable">$interface</span> <span class="variable">$vip</span> netmask <span class="variable">$mask</span> broadcast <span class="variable">$vip</span> up</span><br><span class="line">	route add -host <span class="variable">$vip</span> dev lo:0</span><br><span class="line">	;;</span><br><span class="line">stop)</span><br><span class="line">	ifconfig <span class="variable">$interface</span> down	</span><br><span class="line">	<span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">	<span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">	<span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">	<span class="built_in">echo</span> 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">	;;</span><br><span class="line">*)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"Usage <span class="variable">$(basename $0)</span> start|stop"</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>在director上做ipvs规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible yum.repos.d]<span class="comment">#ipvsadm -A -t 192.168.34.123:80 -s wrr</span></span><br><span class="line">[root@ansible yum.repos.d]<span class="comment">#ipvsadm -a -t 192.168.34.123:80 -r 192.168.34.102 -g -w 2</span></span><br><span class="line">[root@ansible yum.repos.d]<span class="comment">#ipvsadm -a -t 192.168.34.123:80 -r 192.168.34.108 -g -w 1</span></span><br></pre></td></tr></table></figure>

<p>之后在客户端测试，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node03 ~]<span class="comment">#for i in `seq 10` ;do curl 192.168.34.123;sleep .5;done</span></span><br><span class="line">docker</span><br><span class="line">docker</span><br><span class="line">apache</span><br><span class="line">docker</span><br><span class="line">docker</span><br><span class="line">apache</span><br><span class="line">docker</span><br><span class="line">docker</span><br><span class="line">apache</span><br><span class="line">docker</span><br></pre></td></tr></table></figure>
<p>至此，dr模式的测试成功。</p>
<h3 id="LVS多端口绑定"><a href="#LVS多端口绑定" class="headerlink" title="LVS多端口绑定"></a>LVS多端口绑定</h3><p>LVS可以利用防火墙标记实现多端口绑定的功能，将多个应用程序绑定到一起进行调度。<br>firewallMark为服务实现分类器，从而实现将多个服务归类为一个服务。<br>在各RS上通过虚拟主机创建,模板如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker scripts]<span class="comment">#cd /etc/httpd/conf.d/</span></span><br><span class="line">[root@docker conf.d]<span class="comment">#vi vhost.conf</span></span><br><span class="line">Listen 8080</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName docker.80.com</span><br><span class="line">	DocumentRoot <span class="string">"/data/vhost1"</span></span><br><span class="line">	&lt;Directory <span class="string">"/data/vhost1"</span>&gt;</span><br><span class="line">		Options None</span><br><span class="line">		AllowOverride None</span><br><span class="line">		Require all granted</span><br><span class="line">	&lt;/Directory&gt;</span><br><span class="line">&lt;/Virtualhost&gt;</span><br><span class="line">&lt;VirtualHost *:8080&gt;</span><br><span class="line">        ServerName docker.8080.com</span><br><span class="line">        DocumentRoot <span class="string">"/data/vhost2"</span></span><br><span class="line">        &lt;Directory <span class="string">"/data/vhost2"</span>&gt;</span><br><span class="line">                Options None</span><br><span class="line">                AllowOverride None</span><br><span class="line">                Require all granted</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">&lt;/Virtualhost&gt;</span><br><span class="line">[root@docker conf.d]<span class="comment">#echo docker.80 &gt; /data/vhost1/index.html</span></span><br><span class="line">[root@docker conf.d]<span class="comment">#echo docker.8080 &gt; /data/vhost2/index.html</span></span><br></pre></td></tr></table></figure>
<p>在director上做规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#iptables -t mangle -A PREROUTING -d 192.168.34.123 -p tcp -m multiport --dports 80,8080 -j MARK --set-mark 7 #对目标地址是192.168.34.123的80和8080端口的tcp请求做防火墙标记，标记号为7</span></span><br><span class="line">[root@ansible yum.repos.d]<span class="comment">#ipvsadm -A -f 7 -s wrr</span></span><br><span class="line">[root@ansible yum.repos.d]<span class="comment">#ipvsadm -a -f 7 -r 192.168.34.102 -g -w 1</span></span><br><span class="line">[root@ansible yum.repos.d]<span class="comment">#ipvsadm -a -f 7 -r 192.168.34.108 -g -w 2</span></span><br></pre></td></tr></table></figure>
<p>此时在客户端请求，80和8080端口就可以被统一调度了。</p>
<h3 id="lvs持久连接"><a href="#lvs持久连接" class="headerlink" title="lvs持久连接"></a>lvs持久连接</h3><p>持久连接能实现不论是用何种调度算法，在一段时间内，都能够实现将来自同一客户端的请求始终发往同一RS<br>Usage：</p>
<ul>
<li>ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]]</li>
</ul>
<p>port Affinity:<br>每端口持久PPC：每个端口对应定义为一个集群服务，每集群服务单独调度；<br>每防火墙标记持久PFWM：基于防火墙标记集群服务，可实现将多个端口上的应用统一调度，即所谓的port Affinity；<br>每客户端持久PCC：基于0端口定义集群服务，即将客户端对所有应用的请求统统调度至后端主机，必须定义为持久模式。</p>
<h3 id="LVS保存及重载规则"><a href="#LVS保存及重载规则" class="headerlink" title="LVS保存及重载规则"></a>LVS保存及重载规则</h3><p><strong>保存规则</strong><br>建议保存至/etc/sysconfig/ipvsadm</p>
<ul>
<li>ipvsadm-save &gt; /PATH/TO/IPVSADM_FILE</li>
<li>ipvsadm -S &gt; /PATH/TO/IPVSADM_FILE</li>
</ul>
<p><strong>重载规则</strong></p>
<ul>
<li>ipvsadm-restore &lt; /PATH/FROM/IPVSADM_FILE</li>
<li>ipvsadm -R &lt; /PATH/FROM/IPVSADM_FILE</li>
</ul>
]]></content>
      <tags>
        <tag>负载均衡器</tag>
        <tag>lvs</tag>
        <tag>LB cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2018/06/15/redis-cluster/</url>
    <content><![CDATA[<h2 id="分布式系统基础"><a href="#分布式系统基础" class="headerlink" title="分布式系统基础"></a>分布式系统基础</h2><p>ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p>
<p>CAP理论<br>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[3]。）<br>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项[4]。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</li>
</ul>
<p>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p>
<p>数据分类：结构化数据，半结构化数据，非结构化数据。</p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>全称：Remote Directory Server</p>
<h3 id="redis配置文件详解"><a href="#redis配置文件详解" class="headerlink" title="redis配置文件详解"></a>redis配置文件详解</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">######### NETWORK ########## 网络相关的配置</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0 监听地址，0.0.0.0表示监听本机所有地址的6379端口</span><br><span class="line">protected-mode yes 是否启动保护模式</span><br><span class="line">port 6379 监听端口</span><br><span class="line">tcp-backlog 511 后援队列长度</span><br><span class="line">timeout 300 超时时间</span><br><span class="line">tcp-keepaive 300 tcp连接的超时时间</span><br><span class="line"><span class="comment">########## SECURITY ######### 安全相关的配置</span></span><br><span class="line">requirepass msq 登录密码，设置密码后，登录到redis上之后，需要先使用auth password 进行认证后才可以使用redis。</span><br><span class="line"><span class="comment">########### LIMITS ########## 资源限制相关的设置</span></span><br><span class="line">maxclients 10000 最大并发连接数</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存使用量，以字节为单位。</span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line">				淘汰策略：volatile-lru, allkeys-lru, volatile-random, allkeys-random, volatile-ttl, noeviction</span><br><span class="line">			 maxmemory-samples 5</span><br><span class="line">				淘汰算法运行时的采样样本数；</span><br></pre></td></tr></table></figure>

<h3 id="redis数据持久化"><a href="#redis数据持久化" class="headerlink" title="redis数据持久化"></a>redis数据持久化</h3><h3 id="redis主从复制"><a href="#redis主从复制" class="headerlink" title="redis主从复制"></a>redis主从复制</h3><p>配置从服务器指向主服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># vi /etc/redis.conf</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line">slaveof 192.168.34.103 6379</span><br><span class="line">masterauth msq</span><br><span class="line">slave-read-only yes</span><br><span class="line">slave-serve-stale-data yes <span class="comment">#从节点是否可以使用过期的数据</span></span><br></pre></td></tr></table></figure>
<p>主服务器只需绑定能够连接到从服务器的网卡上即可。</p>
<p>也可以在从服务器上直接配置以命令行的方式配置主从服务器，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF host port</span><br><span class="line">127.0.0.1:6379&gt; CONFIG SET masterauth msq</span><br><span class="line">127.0.0.1:6379&gt; CONFIG REWRITE <span class="comment">#将配置写入到配置文件中，</span></span><br></pre></td></tr></table></figure>

<p>在redis内部设置密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass msq</span><br><span class="line">127.0.0.1:6379&gt; auth msq</span><br><span class="line">127.0.0.1:6379&gt; config rewrite</span><br></pre></td></tr></table></figure>

<h3 id="redis-sentinel"><a href="#redis-sentinel" class="headerlink" title="redis sentinel"></a>redis sentinel</h3><p>redis sentinel主要有三个功能：监控，通知，自动故障转移<br>配置redis-sentinel,所有节点的sentinel配置应该保持一模一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># grep "^[a-Z]" /etc/redis-sentinel.conf </span></span><br><span class="line">port 26379</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0 <span class="comment">#最好设置bind</span></span><br><span class="line">dir /tmp</span><br><span class="line">sentinel monitor mymaster 192.168.34.103 6379 2 <span class="comment">#设定主从集群的名称为mymaster，master的ip为192.168.34.103，端口为6379，至少需要有2个sentinel节点同时判定主节点故障时，才认为其真的故障。</span></span><br><span class="line">sentinel auth-pass mymaster msq <span class="comment">#口令</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 5000 <span class="comment">#监控到指定的鸡群主节点异常状态持续多久才将其标记为故障。</span></span><br><span class="line">sentinel parallel-syncs mymaster 2 <span class="comment">#指在failover过程中，能够被sentinel并行配置的从节点的数量。</span></span><br><span class="line">sentinel failover-timeout mymaster 180000 <span class="comment">#sentinel必须在指定的时长内完成故障转移操作，否则将视故障转移操作失败。</span></span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/sentinel.log</span><br></pre></td></tr></table></figure>
<p>启动redis-sentinel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># systemctl start redis-sentinel</span></span><br></pre></td></tr></table></figure>

<p>此时，redis-sentinel会自动获取所有节点的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node03 ~]<span class="comment"># tail /etc/redis-sentinel.conf </span></span><br><span class="line">logfile <span class="string">"/var/log/redis/sentinel.log"</span></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">supervised systemd</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line">sentinel known-slave mymaster 192.168.34.104 6379</span><br><span class="line">sentinel known-slave mymaster 192.168.34.102 6379</span><br><span class="line">sentinel known-sentinel mymaster 192.168.34.103 26379 1459e120039f6886974a2a8953fbeb362bd1d90a</span><br><span class="line">sentinel known-sentinel mymaster 192.168.34.102 26379 fda45e97ef724fb28d9e398c6a94e3a136cd0d0c</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p>此时将主节点down掉观察效果，会发现，在经过设定的等待时长，且超过半数的sentinel都连接不到主节点时，会自动提升一个从节点为主节点，并将主节点自动降级为从节点。</p>
<h3 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h3><p>在哨兵sentinel机制中，可以解决redis高可用的问题，即当master故障后可以自动将slave提升为master从而可以保证redis服务的正常使用，但是无法解决redis单机写入的瓶颈问题，即单机的redis写入性能受限于单机的内存大小、并发数量、网卡速率等因素，因此redis官方在redis 3.0版本之后推出了无中心架构的redis cluster机制，在无中心的redis集群汇中，其每个节点保存当前节点数据和整个集群状态,每个节点都和其他所有节点连接，特点如下：</p>
<p>1：所有Redis节点使用(PING-PING机制)互联<br>2：集群中某个节点的实效是整个集群中超过半数的节点监测都实效才算真正的实效<br>3：客户端不需要proxy即可直接连接redis，且客户端不需要连接集群中的所有节点，只要连接集群中的任何一个节点即可。<br>4：redis cluster把所有的redisnode映射到 0-16383个槽位(slot)上，读写需要到指定的redis node上进行操作，因此有多少个reids node相当于redis 并发扩展了多少倍。<br>5：Redis集群预先分配16384个(slot)槽位，当需要在redis集群中写入一个key -value的时候，会使用CRC16(key)  mod 16384之后的值，决定将key写入值哪一个槽位从而决定写入哪一个Redis节点上，从而有效解决单机瓶颈。</p>
<h4 id="创建redis-cluster-集群的前提"><a href="#创建redis-cluster-集群的前提" class="headerlink" title="创建redis cluster 集群的前提"></a>创建redis cluster 集群的前提</h4><p>1.每个redis node节点采用相同的硬件配置、相同的密码<br>2.每个节点必须开启参数<br>cluster-enabled yes #必须开启集群状态，开启后redis 进程会有cluster显示<br>cluster-config-file nodes-6380.conf #此文件有redis cluster集群自动创建和维护，不需要任何手动操作</p>
<p>创建集群：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 etc]<span class="comment"># redis-cli -a msq --cluster create 192.168.34.101:6379 192.168.34.101:6380 192.168.34.102:6379 192.168.34.102:6380 192.168.34.103:6379 192.168.34.103:6380 --cluster-replicas 1</span></span><br></pre></td></tr></table></figure>
<h3 id="redis-cluster-集群维护"><a href="#redis-cluster-集群维护" class="headerlink" title="redis cluster 集群维护"></a>redis cluster 集群维护</h3><h4 id="动态添加节点"><a href="#动态添加节点" class="headerlink" title="动态添加节点"></a>动态添加节点</h4><p>将节点加入集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 redis]<span class="comment"># redis-cli -a msq --cluster add-node 192.168.34.104:6379 192.168.34.101:6379</span></span><br></pre></td></tr></table></figure>
<p>重新分片</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># redis-cli -a msq --cluster reshard 192.168.34.104:6379</span></span><br></pre></td></tr></table></figure>

<p>为新加入的master添加一个slave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># redis-cli -a msq --cluster add-node 192.168.34.104:6380 192.168.34.101:6379</span></span><br><span class="line">192.168.34.104:6380&gt; CLUSTER REPLICATE c411fffa2a7aac7236fc49f044c018cb474fac78 <span class="comment">#后面是刚刚添加的节点的node id，可以在redis-cli炼乳后使用cluster nodes命令获得。</span></span><br></pre></td></tr></table></figure>

<h4 id="动态删除节点"><a href="#动态删除节点" class="headerlink" title="动态删除节点"></a>动态删除节点</h4><p>先将节点的槽位导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456  --cluster reshard  192.168.7.102:6379</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.7.102:6379)</span><br><span class="line">M: 116c4c6de036fdbac5aaad25eb1a61ea262b64af 192.168.7.102:6379</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 70de3821dde4701c647bd6c23b9dd3c5c9f24a62 192.168.7.103:6379</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 886338acd50c3015be68a760502b239f4509881c 192.168.7.104:6379</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 7eda0bcf0c01bb7343313b81267c42dd1b26c8a6 192.168.7.103:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 116c4c6de036fdbac5aaad25eb1a61ea262b64af</span><br><span class="line">S: b9a00d59fa3c2a322080a1c7d84f53a2c853b089 192.168.7.104:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 886338acd50c3015be68a760502b239f4509881c</span><br><span class="line">S: 7186c6d03dd9a5e3be658f2d08e800bc55b04a09 192.168.7.102:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">S: 2b6e5d9c3944d79a5b64a19e54e52f83d48438d6 192.168.7.101:6380</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 70de3821dde4701c647bd6c23b9dd3c5c9f24a62</span><br><span class="line">M: f4cfc5cf821c0d855016488d6fbfb62c03a14fda 192.168.7.101:6379</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 4096 <span class="comment">#迁移master上的多少个槽位</span></span><br><span class="line">What is the receiving node ID? 886338acd50c3015be68a760502b239f4509881c <span class="comment">#接收槽位的服务器ID</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: f4cfc5cf821c0d855016488d6fbfb62c03a14fda #从哪个服务器迁移4096个槽位</span></span><br><span class="line">Source node <span class="comment">#2: done #写done，表示没有其他master了</span></span><br><span class="line">    Moving slot 5457 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">    Moving slot 5458 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">    Moving slot 5459 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">    Moving slot 5460 from f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes <span class="comment">#是否继续</span></span><br></pre></td></tr></table></figure>
<p>验证槽位迁移完成后然后删除节点<br>虽然槽位已经迁移完成，但是服务器IP信息还在集群当中，因此还需要将IP信息从集群删除<br>命令格式： redis-cli -a 123456  –cluster  del-node   IP:Port ID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@redis-s1 ~]<span class="comment"># redis-cli -a 123456 --cluster del-node 192.168.7.101:6379 f4cfc5cf821c0d855016488d6fbfb62c03a14fda</span></span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Removing node f4cfc5cf821c0d855016488d6fbfb62c03a14fda from cluster 192.168.7.101:6379</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; SHUTDOWN the node.</span><br></pre></td></tr></table></figure>
<h4 id="导入现有redis数据"><a href="#导入现有redis数据" class="headerlink" title="导入现有redis数据"></a>导入现有redis数据</h4><p>导入数据之前需要关闭各redis 服务器的密码，包括集群中的各node和源Redis server，避免认证带来的环境不一致从而无法导入，但是可以加参数–cluster-replace 强制替换Redis cluster已有的key。</p>
<p>执行数据导入</p>
<p>将源Redis server的数据直接导入之redis cluster。<br>命令格式：</p>
<ul>
<li><h1 id="redis-cli-–cluster-import-集群服务器IP-PORT-–cluster-from-外部Redis-node-IP-PORT-–cluster-copy-–cluster-replace"><a href="#redis-cli-–cluster-import-集群服务器IP-PORT-–cluster-from-外部Redis-node-IP-PORT-–cluster-copy-–cluster-replace" class="headerlink" title="redis-cli  –cluster import  集群服务器IP:PORT –cluster-from 外部Redis node-IP:PORT –cluster-copy –cluster-replace"></a>redis-cli  –cluster import  集群服务器IP:PORT –cluster-from 外部Redis node-IP:PORT –cluster-copy –cluster-replace</h1></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@redis-s2 redis]<span class="comment"># redis-cli  --cluster import  192.168.7.103:6379 --cluster-from  192.168.7.101:6379  --cluster-copy</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>分布式存储</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM参数调优</title>
    <url>/2018/06/03/JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>jvm运行时的区域：</p>
<ul>
<li>共享区：heap,method(Non-heap,非堆内存)</li>
<li>线程独有：JVM栈，本地栈，PC</li>
</ul>
<p>GC：garbage Collector,垃圾收集器<br>垃圾回收方式：</p>
<ul>
<li>增量回收</li>
<li>分代回收：将垃圾基于生命周期分类后基于不同生命周期的垃圾进行回收，分为新生代、老年代、持久代。Eden(新生代),From Survivor(存活区0),TO Survivor(存活区1)</li>
</ul>
<p>垃圾回收机制：</p>
<ul>
<li>串行</li>
<li>并行(STP:stop the world),将所有的进程停止，并发进行垃圾处理，处理完后再运行进程。</li>
<li>并发</li>
</ul>
<p>垃圾回收算法：<br>新生代：</p>
<pre><code>Serial
ParNew
Parallel Scavenge：吞吐量</code></pre><p>老年代：</p>
<pre><code>Serial Old：单GC线程回收老年代中不再被使用的对象
Parallel Old：多GC线程回收老年代中不再被使用的对象
CMS（Concurrent Mark Sweep）:以获得最短回收停顿时长为目标，是互联网站点服务端的B/S系统上较佳的回收算法；
    标记-清除
    整个过程分为四个阶段：
        初始标记
        并发标记
        重新标记
        并发清除</code></pre><p>G1：Garbage First<br>并行和并发，分代收集，空间整合，可预测的停顿</p>
<pre><code>标记-整理
初始标记
并发标记
最终标记
筛选回收</code></pre><h3 id="调优jvm内存空间的常用参数"><a href="#调优jvm内存空间的常用参数" class="headerlink" title="调优jvm内存空间的常用参数"></a>调优jvm内存空间的常用参数</h3><p> -Xmx：堆内存（新生代和老年代）的最大空间；<br>-Xms：初始分配内存空间；<br>-XX:NewSize：新生代空间大小；<br>    -Xms-(-XX:NewSize)<br>-XX:MaxNewSize：新生代的最大空间；<br>    -Xmx-（-XX:MaxNewSize）<br>-XX:NewRatio：新生代除以老年代的值；<br>-XX:SurvivorRation：Eden/Survivor=</p>
<p>-Xss：设置线程私有的栈空间大小；</p>
<p>指定垃圾收集器：<br>-XX:</p>
<ul>
<li><p>UseSerialGC：运行于Client模式下，新生代是Serial, 老年代使用SerialOld</p>
</li>
<li><p>UseParNewGC：新生代使用ParNew，老年代使用SerialOld</p>
</li>
<li><p>UseParalellGC：运行于server模式下，新生代使用Serial Scavenge, 老年代使用SerialOld</p>
</li>
<li><p>UseParalellOldGC：新生代使用Paralell Scavenge, 老年代使用Paralell Old</p>
</li>
<li><p>UseConcMarkSweepGC：新生代使用ParNew, 老年代优先使用CMS，备选方式为Serial Old</p>
<blockquote>
<p>CMSInitiatingOccupancyFraction：设定老年代空间占用比例达到多少后触发回收操作，默认为68%；<br>UseCMSCompactAtFullCollection：CMS完成内存回收后是否要进行内存碎片整理；<br>CMSFullGCsBeforeCompaction：在多少次回收后执行一次内存碎片整理；</p>
</blockquote>
</li>
<li><p>ParalellGCThreads：并行GC线程的数量；</p>
</li>
</ul>
<p>显示垃圾回收的统计信息：</p>
<pre><code>-XX:+PrintGC
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps</code></pre><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vim /etc/tomcat/tomcat.conf </span></span><br><span class="line">JAVA_OPTS=<span class="string">"-Xmx1g -Xms512m -XX:NewRatio=2 -XX:SurvivorRatio=3 -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:PrintGC"</span></span><br></pre></td></tr></table></figure>

<h3 id="jvm常用命令"><a href="#jvm常用命令" class="headerlink" title="jvm常用命令"></a>jvm常用命令</h3><p>JVM常用的分析工具： </p>
<pre><code>jps：用来查看运行的所有jvm进程；
jinfo：查看进程的运行环境参数，主要是jvm命令行参数；
jstat：对jvm应用程序的资源和性能进行实时监控；
jstack：查看所有线程的运行状态；
jmap：查看jvm占用物理内存的状态；
jhat：+UseParNew
jconsole：
jvisualvm：</code></pre><p>jps：Java virutal machine Process Status tool，</p>
<pre><code>jps [-q] [-mlvV] [&lt;hostid&gt;]
    -q：静默模式；
    -v：显示传递给jvm的命令行参数；
    -m：输出传入main方法的参数；
    -l：输出main类或jar完全限定名称；
    -V：显示通过flag文件传递给jvm的参数；
    [&lt;hostid&gt;]：主机id，默认为localhost；</code></pre><p>jinfo：输出给定的java进程的所有配置信息；</p>
<pre><code>jinfo [option] &lt;pid&gt;
    -flags：to print VM flags
    -sysprops：to print Java system properties
    -flag &lt;name&gt;：to print the value of the named VM flag</code></pre><p>jstack：查看指定的java进程的线程栈的相关信息；</p>
<pre><code>jstack [-l] &lt;pid&gt;
jstack -F [-m] [-l] &lt;pid&gt;
    -l：long listings，会显示额外的锁信息，因此，发生死锁时常用此选项；
    -m：混合模式，既输出java堆栈信息，也输出C/C++堆栈信息；
    -F：当使用“jstack -l PID&quot;无响应，可以使用-F强制输出信息；</code></pre><p>jstat：输出指定的java进程的统计信息</p>
<pre><code>jstat -help|-options
jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]
# jstat -options
    -class：class loader
    -compiler：JIT
    -gc：gc
    -gccapacity：统计堆中各代的容量
    -gccause：
    -gcmetacapacity
    -gcnew：新生代
    -gcnewcapacity
    -gcold：老年代
    -gcoldcapacity
    -gcutil
    -printcompilation

[&lt;interval&gt; [&lt;count&gt;]]
    interval：时间间隔，单位是毫秒；
    count：显示的次数；

-gc：
    YGC：新生代的垃圾回收次数；
    YGCT：新生代垃圾回收消耗的时长； 
    FGC：Full GC的次数；
    FGCT：Full GC消耗的时长；
    GCT：GC消耗的总时长；</code></pre><p>jmap：Memory Map, 用于查看堆内存的使用状态；<br>jhat：Java Heap Analysis Tool<br>    jmap [option] <pid></p>
<p>查看堆空间的详细信息：<br>    jmap -heap <pid></p>
<p>查看堆内存中的对象的数目：<br>    jmap -histo[:live] <pid><br>        live：只统计活动对象；</p>
<p>保存堆内存数据至文件中，而后使用jvisualvm或jhat进行查看：</p>
<pre><code>jmap -dump:&lt;dump-options&gt; &lt;pid&gt;
    dump-options:
    live         dump only live objects; if not specified, all objects in the heap are dumped.
    format=b     binary format
    file=&lt;file&gt;  dump heap to &lt;file&gt;</code></pre>]]></content>
      <tags>
        <tag>jvm</tag>
        <tag>tomcat</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix</title>
    <url>/2018/06/02/zabbix/</url>
    <content><![CDATA[<h3 id="安装zabbix-server"><a href="#安装zabbix-server" class="headerlink" title="安装zabbix-server"></a>安装zabbix-server</h3><h4 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [wpdb]&gt; create database zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [wpdb]&gt; grant all privileges on zabbix.* to zabbix@<span class="string">'10.10.10.%'</span> identified by <span class="string">'centos'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="编译安装zabbix"><a href="#编译安装zabbix" class="headerlink" title="编译安装zabbix"></a>编译安装zabbix</h4><p>到官方网站下载zabbix4.0.3版本的源码包<br><a href="https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/4.0.3/zabbix-4.0.3.tar.gz/download" target="_blank" rel="noopener">https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/4.0.3/zabbix-4.0.3.tar.gz/download</a><br>安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#yum install gcc libxml2-devel net-snmp net-snmp-devel curl curl-devel php php-bcmath php-mbstring mariadb mariadb-devel libevent-devel –y</span></span><br></pre></td></tr></table></figure>
<p>如果是最小化安装的系统，还需安装以下常用包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#yum install vim iotop bc gcc gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel zip unzip zlib-devel net-tools lrzsz tree ntpdate telnet lsof tcpdump wget libevent libevent-devel -y</span></span><br></pre></td></tr></table></figure>
<p>因为要支持java，所以要安装jdk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 bin]<span class="comment"># yum -y install java-11-openjdk-devel</span></span><br></pre></td></tr></table></figure>

<p>开始编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#pwd</span></span><br><span class="line">/root/tools/zabbix-4.0.3</span><br><span class="line">[root@10-10-10-11 tools]<span class="comment">#tar xf zabbix-4.0.3.tar.gz </span></span><br><span class="line">[root@10-10-10-11 tools]<span class="comment">#cd zabbix-4.0.3</span></span><br><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#useradd zabbix -s /sbin/nologin </span></span><br><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#./configure --prefix=/usr/local/zabbix --enable-server --enable-agent  --with-mysql --with-net-snmp --with-libcurl --with-libxml2 --enable-java</span></span><br><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>在编译过程中报错</p>
<pre><code>checking size of void *... 8
checking for mysql_config... no
checking for mariadb_config... no
configure: error: MySQL library not found</code></pre><p>解决方法为安装mysql-devel包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#yum -y install mysql-devel</span></span><br></pre></td></tr></table></figure>

<p>安装完成后修改zabbix-server.conf配置文件，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix]<span class="comment">#grep "^[a-Z]" /usr/local/zabbix/etc/zabbix_server.conf</span></span><br><span class="line">LogFile=/usr/<span class="built_in">local</span>/zabbix/logs/zabbix_server.log</span><br><span class="line">DebugLevel=3</span><br><span class="line">PidFile=/usr/<span class="built_in">local</span>/zabbix/pid/zabbix_server.pid</span><br><span class="line">SocketDir=/usr/<span class="built_in">local</span>/zabbox/socket</span><br><span class="line">DBHost=10.10.10.6</span><br><span class="line">DBName=zabbix</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=centos</span><br><span class="line">DBPort=3306</span><br><span class="line">Timeout=4</span><br><span class="line">LogSlowQueries=3000</span><br></pre></td></tr></table></figure>
<p>创建相关目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 mysql]<span class="comment">#mkdir /usr/local/zabbix/&#123;pid,logs,socket&#125; -pv</span></span><br><span class="line">[root@10-10-10-11 mysql]<span class="comment">#chown -R zabbix.zabbix /usr/local/zabbix/</span></span><br></pre></td></tr></table></figure>
<p>导入数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 mysql]<span class="comment">#pwd</span></span><br><span class="line">/root/tools/zabbix-4.0.3/database/mysql</span><br><span class="line">[root@10-10-10-11 mysql]<span class="comment">#mysql -uzabbix -pcentos -h10.10.10.23 zabbix &lt; schema.sql </span></span><br><span class="line">[root@10-10-10-11 mysql]<span class="comment">#mysql -uzabbix -pcentos -h10.10.10.23 zabbix &lt; images.sql </span></span><br><span class="line">[root@10-10-10-11 mysql]<span class="comment">#mysql -uzabbix -pcentos -h10.10.10.23 zabbix &lt; data.sql</span></span><br></pre></td></tr></table></figure>
<p>复制启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#pwd</span></span><br><span class="line">/root/tools/zabbix-4.0.3</span><br><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#cp misc/init.d/fedora/core/zabbix_server /etc/init.d/</span></span><br><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#cp misc/init.d/fedora/core/zabbix_agentd /etc/init.d/</span></span><br></pre></td></tr></table></figure>
<p>修改启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/init.d/zabbix_server</span><br><span class="line">vim /etc/init.d/zabbix_agent</span><br><span class="line">21 <span class="comment"># Zabbix-Directory</span></span><br><span class="line">22 BASEDIR=/usr/<span class="built_in">local</span>/zabbix</span><br></pre></td></tr></table></figure>
<p>启动zabbix-server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#service zabbix_server start</span></span><br></pre></td></tr></table></figure>
<p>配置web界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 html]<span class="comment">#yum -y install httpd</span></span><br><span class="line">[root@10-10-10-11 html]<span class="comment">#cp -a /root/tools/zabbix-4.0.3/frontends/php/* /var/www/html/</span></span><br><span class="line">[root@10-10-10-11 html]<span class="comment">#systemctl start httpd</span></span><br></pre></td></tr></table></figure>
<p>此时，在浏览可以通过ip访问该站点了。</p>
<p>访问zabbix时会出现几个报错，解决办法为：<br>安装缺少的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 html]<span class="comment">#yum install php-gettext php-session php-ctype php-xmlreader php-xmlwriter php-xml php-net-socket php-gd php-mysql -y</span></span><br></pre></td></tr></table></figure>
<p>修改php配置文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 html]<span class="comment">#vi /etc/php.ini </span></span><br><span class="line">post_max_size = 8M 改为 post_max_size = 16M</span><br><span class="line">max_execution_time = 30 改为 max_execution_time = 300</span><br><span class="line">max_input_time = 60 改为 max_input_time = 300</span><br><span class="line">;date.timezone = 改为 date.timezone = Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>重启httpd后再次访问web</p>
<p>之后按提示操作配置后就可以正常访问zabbix-server。</p>
<p>zabbix字体乱码的解决办法：<br>将Windows中的字体(控制面板-&gt;小图标-&gt;字体)拷贝到zabbix中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 fonts]<span class="comment">#pwd</span></span><br><span class="line">/var/www/html/fonts</span><br><span class="line">[root@10-10-10-11 fonts]<span class="comment">#ll</span></span><br><span class="line">total 12252</span><br><span class="line">-rw-r--r-- 1 zabbix zabbix   756072 Dec 20 19:24 DejaVuSans.ttf</span><br><span class="line">-rw-r--r-- 1 zabbix zabbix 11787328 Dec  4  2017 simkai.ttf</span><br><span class="line">[root@10-10-10-11 html]<span class="comment">#pwd</span></span><br><span class="line">/var/www/html</span><br><span class="line">[root@10-10-10-11 html]<span class="comment">#grep "DejaVuSans" ./* -R</span></span><br><span class="line">Binary file ./fonts/DejaVuSans.ttf matches</span><br><span class="line">./include/defines.inc.php:define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,		DejaVuSans<span class="string">'); // font file name</span></span><br><span class="line"><span class="string">./include/defines.inc.php:define('</span>ZBX_FONT_NAME<span class="string">', '</span>DejaVuSans<span class="string">');</span></span><br></pre></td></tr></table></figure>
<p>将搜索到的文件中的字体替换为刚才复制进来的字体即可。</p>
<h3 id="向zabbix-server中增加agent-被动模式"><a href="#向zabbix-server中增加agent-被动模式" class="headerlink" title="向zabbix server中增加agent(被动模式)"></a>向zabbix server中增加agent(被动模式)</h3><p><strong>先在客户端安装zabbix agent</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-13 zabbix-4.0.3]<span class="comment"># ./configure --enable-agent --prefix=/usr/local/zabbix </span></span><br><span class="line">[root@host-10-10-10-13 zabbix-4.0.3]<span class="comment">#make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>修改zabbix agent的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-13 zabbix]<span class="comment"># grep "^[a-Z]" /usr/local/zabbix/etc/zabbix_agentd.conf</span></span><br><span class="line">PidFile=/usr/<span class="built_in">local</span>/zabbix/pid/zabbix_agentd.pid</span><br><span class="line">LogFile=/usr/<span class="built_in">local</span>/zabbix/logs/zabbix_agentd.log</span><br><span class="line">DebugLevel=3</span><br><span class="line">Server=10.10.10.11 <span class="comment">##被动模式下的服务器地址</span></span><br><span class="line">StartAgents=3</span><br><span class="line">ServerActive=127.0.0.1 <span class="comment">##主动模式下的服务器地址</span></span><br><span class="line">Hostname=10.10.10.13 <span class="comment">##主机名，必须在整个zabbix监控组里面唯一，且与zabbix上的名称保持一致</span></span><br><span class="line">Timeout=30</span><br><span class="line">UnsafeUserParameters=1</span><br></pre></td></tr></table></figure>

<p>创建相关目录和zabbix用户，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-13 zabbix]<span class="comment"># mkdir /usr/local/zabbix/&#123;logs,pid&#125;</span></span><br><span class="line">[root@host-10-10-10-13 zabbix]<span class="comment"># useradd zabbix -s /sbin/nologin </span></span><br><span class="line">[root@host-10-10-10-13 zabbix]<span class="comment"># chown -R zabbix.zabbix /usr/local/zabbix/</span></span><br></pre></td></tr></table></figure>

<p>启动zabbix agent之后，即可以在web图形界面添加相应的主机。</p>
<p>zabbix get工具介绍：使用该工具可以获取zabbix agent数据命令。可以通过yum安装zabbix-get的rpm包获取该工具。<br>编译安装的zabbix在安装目录下的bin目录里面也有该工具，可以通过如下方式使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-11 zabbix-4.0.3]<span class="comment">#cd /usr/local/zabbix/</span></span><br><span class="line">[root@10-10-10-11 zabbix]<span class="comment">#ls bin</span></span><br><span class="line">zabbix_get  zabbix_sender</span><br><span class="line">[root@10-10-10-11 zabbix]<span class="comment">#cp bin/zabbix_get /usr/bin/</span></span><br></pre></td></tr></table></figure>

<h3 id="使用zabbix监控tomcat"><a href="#使用zabbix监控tomcat" class="headerlink" title="使用zabbix监控tomcat"></a>使用zabbix监控tomcat</h3><h4 id="在zabbix-server上安装配置java-gateway"><a href="#在zabbix-server上安装配置java-gateway" class="headerlink" title="在zabbix server上安装配置java gateway"></a>在zabbix server上安装配置java gateway</h4><p>java gateway可以配置在一个单独的服务器上，也可以和zabbix server配置在同一服务器上，这里以单独配置一台java gateway服务器为例。编译安装的zabbix开启–enable-java选项会自动安装java gateway功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#yum install gcc libxml2-devel net-snmp net-snmp-devel curl curl-devel php php-bcmath php-mbstring mariadb-devel java-1.8.0-openjdk-devel -y</span></span><br><span class="line">~]<span class="comment">#./configure --prefix=/usr/local/zabbix --enable-java --with-net-snmp --with-mysql --with-ssh2</span></span><br><span class="line">~]<span class="comment">#make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>编辑配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># vim /usr/local/zabbix/sbin/zabbix_java/settings.sh</span></span><br><span class="line">LISTEN_IP=<span class="string">"0.0.0.0"</span></span><br><span class="line">LISTEN_PORT=10052</span><br><span class="line">PID_FILE=<span class="string">"/tmp/zabbix_java.pid"</span></span><br><span class="line">START_POLLERS=20 <span class="comment">#启动多少个进程轮询java，要和java 应用保持一定关系</span></span><br><span class="line">TIMEOUT=30</span><br></pre></td></tr></table></figure>
<p>启动java gateway</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#/usr/local/zabbix/sbin/zabbix_java/startup.sh</span></span><br></pre></td></tr></table></figure>
<h4 id="单独配置一台java-gateway服务器"><a href="#单独配置一台java-gateway服务器" class="headerlink" title="单独配置一台java gateway服务器"></a>单独配置一台java gateway服务器</h4><p>下载安装java gateway的rpm包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker tools]<span class="comment">#wget https://mirrors.aliyun.com/zabbix/zabbix/4.0/rhel/7/x86_64/zabbix-java-gateway-4.0.3-1.el7.x86_64.rpm</span></span><br><span class="line">[root@docker tools]<span class="comment">#yum install zabbix-java-gateway-4.0.3-1.el7.x86_64.rpm</span></span><br></pre></td></tr></table></figure>
<p>编辑配置文件,此配置文件和编译安装的配置文件一样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker tools]<span class="comment">#grep "^[a-Z]" /etc/zabbix/zabbix_java_gateway.conf </span></span><br><span class="line">PID_FILE=<span class="string">"/var/run/zabbix/zabbix_java.pid"</span></span><br><span class="line">START_POLLERS=10</span><br><span class="line">TIMEOUT=30</span><br></pre></td></tr></table></figure>
<p>启动java gateway</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker tools]<span class="comment">#systemctl start zabbix-java-gateway</span></span><br></pre></td></tr></table></figure>

<h4 id="配置zabbix-server调用java-gateway"><a href="#配置zabbix-server调用java-gateway" class="headerlink" title="配置zabbix server调用java gateway"></a>配置zabbix server调用java gateway</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vim /usr/local/zabbix/etc/zabbix_server.conf</span></span><br><span class="line">JavaGateway=192.168.15.203 <span class="comment">#指定java gateway的地址</span></span><br><span class="line">JavaGatewayPort=10052 <span class="comment">#指定java gateway的服务器监听端口，如果是默认端口可以不写</span></span><br><span class="line">StartJavaPollers=20 <span class="comment">#启动多少个进程去轮训 java gateway，要和java gateway的配置一致</span></span><br><span class="line">Timeout=30</span><br></pre></td></tr></table></figure>

<h4 id="配置tomcat启用jmx远程监控"><a href="#配置tomcat启用jmx远程监控" class="headerlink" title="配置tomcat启用jmx远程监控"></a>配置tomcat启用jmx远程监控</h4><p>配置tomcat的启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker tomcat]<span class="comment">#vi /usr/local/tomcat/bin/catalina.sh</span></span><br><span class="line">CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span></span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote #启用远程监控JMX</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.port=12345 #默认启动的JMX端口号，要和zabbix添加主机时候的端</span></span><br><span class="line"><span class="string">口一致即可</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.authenticate=false #不使用用户名密码</span></span><br><span class="line"><span class="string">-Dcom.sun.management.jmxremote.ssl=false #不使用ssl认证</span></span><br><span class="line"><span class="string">-Djava.rmi.server.hostname=192.168.34.102"</span>  <span class="comment">#tomcat主机自己的IP地址，不要写zabbix服务器的地址</span></span><br></pre></td></tr></table></figure>
<p>之后启动tomcat就可以在zabbix server上增加该主机的jmx监控。</p>
<h4 id="监控java的排错方法"><a href="#监控java的排错方法" class="headerlink" title="监控java的排错方法"></a>监控java的排错方法</h4><p>测试能否获取到java当前已经分配的线程数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># java -jar cmdline-jmxclient-0.10.3.jar - 192.168.15.203:12345 'Catalina:name="http-bio8080",type=ThreadPool' currentThreadCount</span></span><br></pre></td></tr></table></figure>

<h3 id="zabbix-proxy-被动模式"><a href="#zabbix-proxy-被动模式" class="headerlink" title="zabbix proxy(被动模式)"></a>zabbix proxy(被动模式)</h3><p>zabbix 是一个分布式的监控系统，支持通过代理服务器zabbix proxy收集zabbix agent的数据，然后把收集保存在本地数据库并发送给zabbix server进行统一存储和展示。</p>
<h4 id="安装zabbix-proxy"><a href="#安装zabbix-proxy" class="headerlink" title="安装zabbix proxy"></a>安装zabbix proxy</h4><p>安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zabbix-proxy ~]<span class="comment"># yum install gcc libxml2-devel net-snmp net-snmp-devel curl curl-devel php php-bcmath php-mbstring mariadb mariadb-devel java-1.8.0-openjdk-devel -y</span></span><br></pre></td></tr></table></figure>
<p>准备mysql数据库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt;create database zabbix_proxy character set utf8 collate utf8_bin;</span><br><span class="line">MariaDB [(none)]&gt;grant all privileges on zabbix_proxy.* to proxy@'%' identified by '123456';</span><br></pre></td></tr></table></figure>
<p>编译安装zabbix</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-12 zabbix-4.0.3]<span class="comment"># ./configure --prefix=/usr/local/zabbix --enable-proxy --enable-agent --with-mysql --with-net-snmp --with-libcurl --with-libxml2 --enable-java</span></span><br></pre></td></tr></table></figure>
<p>导入数据库，由于此zabbix仅作为proxy使用，所以只需导入schema.sql这一个库即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-12 tools]<span class="comment"># mysql -uproxy -pcentos -h10.10.10.23 zabbix_proxy &lt; /root/tools/zabbix-4.0.3/database/mysql/schema.sql</span></span><br></pre></td></tr></table></figure>
<p>配置被动模式下的zabbix proxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache zabbix]<span class="comment">#grep "^[a-Z]" etc/zabbix_proxy.conf</span></span><br><span class="line">ProxyMode=1 <span class="comment">#0为主动，1为被动</span></span><br><span class="line">Server=192.168.15.201 <span class="comment">#zabbix server服务器的地址或主机名</span></span><br><span class="line">Hostname=proxy1-mage-passive <span class="comment">#代理服务器名称，需要与zabbix server添加代理时候的proxy name是一致的！</span></span><br><span class="line">LogFile=/tmp/zabbix_proxy.log</span><br><span class="line">DBHost=192.168.15.203 <span class="comment">#数据库服务器地址</span></span><br><span class="line">DBName=zabbix_proxy <span class="comment">#使用的数据库名称</span></span><br><span class="line">DBUser=proxy <span class="comment">#连接数据库的用户名称</span></span><br><span class="line">DBPassword=123456 <span class="comment">#数据库用户密码</span></span><br><span class="line">DBPort=3306 <span class="comment">#数据库端口</span></span><br><span class="line">ProxyLocalBuffer=3 <span class="comment">#已经提交到zabbix server的数据保留时间</span></span><br><span class="line">ProxyOfflineBuffer=24 <span class="comment">#未提交到zabbix server的时间保留时间</span></span><br><span class="line">HeartbeatFrequency=60 <span class="comment">#心跳间隔检测时间，默认60秒，范围0-3600秒，被动模式不使用</span></span><br><span class="line">ConfigFrequency=5 <span class="comment">#间隔多久从zabbix server 获取监控信息</span></span><br><span class="line">DataSenderFrequency=5 <span class="comment">#数据发送时间间隔，默认为1秒，范围为1-3600秒，被动模式不使用</span></span><br><span class="line">StartPollers=20 <span class="comment">#启动的数据采集器数量</span></span><br><span class="line">JavaGateway=192.168.15.202 <span class="comment">#java gateway服务器地址,当需要监控java的时候必须配置否则监控不到数据</span></span><br><span class="line">JavaGatewayPort=10052 <span class="comment">#Javagatewa服务端口</span></span><br><span class="line">StartJavaPollers=20 <span class="comment">#启动多少个线程采集数据</span></span><br><span class="line">CacheSize=2G <span class="comment">#保存监控项而占用的最大内存</span></span><br><span class="line">HistoryCacheSize=2G <span class="comment">#保存监控历史数据占用的最大内存</span></span><br><span class="line">Timeout=30 <span class="comment">#监控项超时时间，单位为秒</span></span><br><span class="line">LogSlowQueries=3000 <span class="comment">#毫秒，多久的数据库查询会被记录到日志</span></span><br></pre></td></tr></table></figure>
<p>编译安装zabbix agent</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@web-server zabbix-4.0.1]<span class="comment"># grep "^[a-Z]" /usr/local/zabbix/etc/zabbix_agentd.conf</span></span><br><span class="line">LogFile=/tmp/zabbix_agentd.log</span><br><span class="line">DebugLevel=4</span><br><span class="line">Server=192.168.15.202,192.168.15.201</span><br><span class="line">ListenPort=10050</span><br><span class="line">ListenIP=0.0.0.0</span><br><span class="line">StartAgents=3</span><br><span class="line">ServerActive=192.168.15.202</span><br><span class="line">Hostname=192.168.34.101</span><br><span class="line">Timeout=30</span><br><span class="line">UnsafeUserParameters=1</span><br></pre></td></tr></table></figure>
<p>注意，如果agent是通过proxy将数据发到server上的，那么agent配置文件的server要同时写上server和proxy的地址，以逗号分隔。</p>
<h3 id="zabbix主动模式"><a href="#zabbix主动模式" class="headerlink" title="zabbix主动模式"></a>zabbix主动模式</h3><p>zabbix主被动模式是相对agent来说的，主动模式是agent自动采集数据后发送给server或者proxy，不需要zabbix server的干预，因此主动模式在一定程度上可减轻zabbix server的压力。<br>zabbix被动模式是server主动向客户端发送请求，客户端被动收集数据后发送给sever，由于zabbix server需要周期性的项agent索取数据，这种模式的最大问题就是会加大zabbix server的工作量，在数百台服务器的环境下zabbix server不能及时获取到最新的数据，被动模式时zabbix默认的工作模式。</p>
<p>zabbix是一个分布式的监控系统，支持通过代理服务器zabbix proxy收集zabbix agent的数据，然后收集保存在本地数据库并发送给zabbix server进行统一存储和展示。</p>
<h4 id="配置主动模式的proxy"><a href="#配置主动模式的proxy" class="headerlink" title="配置主动模式的proxy"></a>配置主动模式的proxy</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache zabbix]<span class="comment">#grep "^[a-Z]" etc/zabbix_proxy.conf</span></span><br><span class="line">ProxyMode=0 <span class="comment">#0为主动，1为被动</span></span><br><span class="line">Server=192.168.34.100 <span class="comment">#zabbix server服务器的地址或主机名</span></span><br><span class="line">Hostname=proxy1-mage-passive <span class="comment">#代理服务器名称，需要与zabbix server添加代理时候的proxy name是一致的！</span></span><br><span class="line">LogFile=/tmp/zabbix_proxy.log</span><br><span class="line">DBHost=192.168.15.203 <span class="comment">#数据库服务器地址</span></span><br><span class="line">DBName=zabbix_proxy <span class="comment">#使用的数据库名称</span></span><br><span class="line">DBUser=proxy <span class="comment">#连接数据库的用户名称</span></span><br><span class="line">DBPassword=123456 <span class="comment">#数据库用户密码</span></span><br><span class="line">DBPort=3306 <span class="comment">#数据库端口</span></span><br><span class="line">ProxyLocalBuffer=3 <span class="comment">#已经提交到zabbix server的数据保留时间</span></span><br><span class="line">ProxyOfflineBuffer=24 <span class="comment">#未提交到zabbix server的时间保留时间</span></span><br><span class="line">HeartbeatFrequency=60 <span class="comment">#心跳间隔检测时间，默认60秒，范围0-3600秒，被动模式不使用</span></span><br><span class="line">ConfigFrequency=5 <span class="comment">#间隔多久从zabbix server 获取监控信息</span></span><br><span class="line">DataSenderFrequency=5 <span class="comment">#数据发送时间间隔，默认为1秒，范围为1-3600秒，被动模式不使用</span></span><br><span class="line">StartPollers=20 <span class="comment">#启动的数据采集器数量</span></span><br><span class="line">JavaGateway=192.168.15.202 <span class="comment">#java gateway服务器地址,当需要监控java的时候必须配置否则监控不到数据</span></span><br><span class="line">JavaGatewayPort=10052 <span class="comment">#Javagatewa服务端口</span></span><br><span class="line">StartJavaPollers=20 <span class="comment">#启动多少个线程采集数据</span></span><br><span class="line">CacheSize=2G <span class="comment">#保存监控项而占用的最大内存</span></span><br><span class="line">HistoryCacheSize=2G <span class="comment">#保存监控历史数据占用的最大内存</span></span><br><span class="line">Timeout=30 <span class="comment">#监控项超时时间，单位为秒</span></span><br><span class="line">LogSlowQueries=3000 <span class="comment">#毫秒，多久的数据库查询会被记录到日志</span></span><br></pre></td></tr></table></figure>

<h4 id="配置主动模式的agent"><a href="#配置主动模式的agent" class="headerlink" title="配置主动模式的agent"></a>配置主动模式的agent</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment"># grep "^[a-Z]" etc/zabbix_agentd.conf</span></span><br><span class="line">PidFile=/usr/<span class="built_in">local</span>/zabbix/pid/zabbix_agentd.pid</span><br><span class="line">LogFile=/usr/<span class="built_in">local</span>/zabbix/logs/zabbix_agentd.log</span><br><span class="line">Server=192.168.34.100,192.168.34.103</span><br><span class="line">ServerActive=192.168.34.100,192.168.34.103 <span class="comment">#主动模式下的server地址</span></span><br><span class="line">Hostname=192.168.34.103 <span class="comment">#本机的名称，必须与添加主机时的主机名一样</span></span><br><span class="line">Timeout=30</span><br><span class="line">UnsafeUserParameters=1</span><br></pre></td></tr></table></figure>

<p>编译安装的步骤：</p>
<ul>
<li>configure，检查编译环境是否符合要求，如果符合要求生成Makefile</li>
<li>make，根据Makefile生成模块</li>
<li>make install，将生成的模块拷贝到指定的目录，完成安装。</li>
</ul>
<h3 id="监控TCP连接数"><a href="#监控TCP连接数" class="headerlink" title="监控TCP连接数"></a>监控TCP连接数</h3><p>创建获取数据的脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment"># cat /usr/local/zabbix/etc/zabbix_agentd.conf.d/tcp_conn_plugin.sh </span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">tcp_conn_status</span></span>()&#123;</span><br><span class="line">	TCP_STAT=<span class="variable">$1</span></span><br><span class="line">	ss -ant | awk <span class="string">'NR&gt;1 &#123;++s[$1]&#125; END &#123;for (i in s) print i,s[i]&#125;'</span> &gt; /tmp/tcp_conn.txt</span><br><span class="line">	TCP_STAT_VALUE=$(grep <span class="string">"<span class="variable">$TCP_STAT</span>"</span> /tmp/tcp_conn.txt | cut -d <span class="string">' '</span> -f2)</span><br><span class="line">	<span class="keyword">if</span> [ -z <span class="variable">$&#123;TCP_STAT_VALUE&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">		TCP_STAT_VALUE=0</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$TCP_STAT_VALUE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">		tcp_status)</span><br><span class="line">			tcp_conn_status <span class="variable">$2</span></span><br><span class="line">			;;</span><br><span class="line">		*)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span> + tcp_status + STATUS"</span></span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line">main <span class="variable">$1</span> <span class="variable">$2</span></span><br></pre></td></tr></table></figure>

<p>创建conf文件引用脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment"># vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/all.conf</span></span><br><span class="line">UserParameter=linux_status[*],/usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.conf.d/tcp_conn_plugin.sh “<span class="variable">$1</span>” “<span class="variable">$2</span>” <span class="comment">#添加用户自定义参数</span></span><br></pre></td></tr></table></figure>
<p>此方法需要在agent配置文件导入自定义配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment">#vim /usr/local/zabbix/etc/zabbix_agentd.conf</span></span><br><span class="line">Include=/usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>或者直接在agent配置文件中添加自定义监控项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment">#vim /usr/local/zabbix/etc/zabbix_agentd.conf</span></span><br><span class="line">UserParameter=linux_status[*],/usr/<span class="built_in">local</span>/zabbix/etc/zabbix_agentd.conf.d/tcp_conn_plugin.sh “<span class="variable">$1</span>” “<span class="variable">$2</span>” <span class="comment">#添加用户自定义参数</span></span><br></pre></td></tr></table></figure>

<p>重启agent服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment">#/etc/init.d/zabbix_agentd restart</span></span><br></pre></td></tr></table></figure>

<p>在被监控的服务器为zabbix用户授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment"># vi /etc/sudoers</span></span><br><span class="line">zabbix  ALL=(ALL)       NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<p>测试获取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost zabbix]<span class="comment"># zabbix_get -s 192.168.15.204 -p 10050 -k "linux_status["tcp_status","LISTEN"]"</span></span><br></pre></td></tr></table></figure>

<h3 id="监控redis"><a href="#监控redis" class="headerlink" title="监控redis"></a>监控redis</h3>]]></content>
      <tags>
        <tag>zabbix</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat</title>
    <url>/2018/05/24/tomcat/</url>
    <content><![CDATA[<h3 id="Tomcat和Java基础"><a href="#Tomcat和Java基础" class="headerlink" title="Tomcat和Java基础"></a>Tomcat和Java基础</h3><p>软件架构模式</p>
<ul>
<li>分层架构：表现层，业务层，持久层，数据库层</li>
<li>事件驱动架构：分布式一步架构，调度解耦</li>
<li>微内核架构：即插件式架构，把大的架构做成小的核心模块和插件的形式。</li>
<li>微服务架构：API REST-based，application REST-based,中心化消息，组成架构的每个模块都是一个服务，都需要监听套接字。</li>
<li>基于空间的架构：云架构</li>
</ul>
<p>Java代码的运行：<br>    *.java(source code) –&gt; javac –&gt; *.class(bytecode)<br>    jvm：class loader，加载程序的类文件，及程序的类文件依赖到的其它的类文件而后运行； 整个运行表现为一个jvm进程；threads；</p>
<p>java技术体系：</p>
<ul>
<li>Java编程语言</li>
<li>Java Class文件格式</li>
<li>Java API </li>
<li>Java VM <blockquote>
<p>class loader<br>执行引擎</p>
</blockquote>
</li>
</ul>
<p>JVM运行时区域：</p>
<ul>
<li>方法区：线程共享； 用于存储被JVM加载的class信息、常量、静态变量、方法等；堆：是jvm所管理的内存中占用空间最大的一部分；也是GC管理的主要区域；存储对象；</li>
<li>Java栈：线程私有，存储 线程自己的局部变量；</li>
<li>PC寄存器：线程私有的内存空间，程序的指令指针；</li>
<li>本地方法栈：</li>
</ul>
<p>安装JDK<br>了解当前的Java环境</p>
<pre><code>~]#java -version</code></pre><p>JDK分类：<br>openjdk<br>java-VERSION-openjdk：<br>    The OpenJDK runtime environment.<br>java-VERSION-openjdk-headless：<br>     The OpenJDK runtime environment without audio and video support.<br>java-VERSION-openjdk-devel：<br>    The OpenJDK development tools.</p>
<p>注意：多版本并存时，可使用alternatives命令设定默认使用的版本。</p>
<p>Oracle JDK：<br>安装相应版本的rpm包；<br>    jdk-VERSION-OS-ARCH.rpm<br>    例如:jdk-1.8.0_25-linux-x64.rpm </p>
<p>注意：安装完成后，要配置JAVA_HOME环境变量，指向java的安装路径；<br>    OpenJDK：<br>        JAVA_HOME=/usr<br>    Oracle JDK:<br>        JAVA_HOME=/usr/java/jdk_VERSION</p>
<p>JVM是C语言编写的，其需要编写多个版本以适应不同的操作系统，而Java程序则只需一个版本就可以运行在不同的操作系统之上，即一次编写，处处运行。Java是纯对象编程。</p>
<p>编译：将源代码转换成对CPU指令集调用的格式，使其可以在CPU上运行。<br>Java的编译：将Java程序转换成可以在JVM上运行的格式。</p>
<p>编译运行和解释运行：<br>编译运行：将程序编译完成后在运行，运行速度快。<br>解释运行：编译一行，运行一行，运行速度慢。</p>
<p>J2SE：Standard Edition，标准版<br>J2ME:Mobile Edition，移动版<br>J2EE:Enterprise Edition，企业版</p>
<p>JDK：Java development killer Java开发工具箱</p>
<p>GC：垃圾回收器</p>
<p>Java程序运行过程：<br>.jsp -&gt; Jasper -&gt; .java -&gt; JavaC -&gt; .class -&gt; Servlet -&gt; </p>
<p>jsp时Java 2 EE类库中的组件。</p>
<h3 id="使用Tomcat前的准备工作"><a href="#使用Tomcat前的准备工作" class="headerlink" title="使用Tomcat前的准备工作"></a>使用Tomcat前的准备工作</h3><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>jdk有两种，openjdk和oraclejdk，<br>#####rpm包方式安装官方OracleJDK(需先下载rpm包)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># rpm -ivh jdk-8u191-linux-x64.rpm</span></span><br></pre></td></tr></table></figure>
<p>安装目录为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># ls /usr/java/ -l</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root  16 Jan 16 14:59 default -&gt; /usr/java/latest</span><br><span class="line">drwxr-xr-x 8 root root 258 Jan 16 14:58 jdk1.8.0_191-amd64</span><br><span class="line">lrwxrwxrwx 1 root root  28 Jan 16 14:59 latest -&gt; /usr/java/jdk1.8.0_191-amd64</span><br></pre></td></tr></table></figure>
<p>其中latest和default可以不是同一个，只需手动修改符号链接即可。</p>
<p>测试安装是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 bin]<span class="comment"># pwd</span></span><br><span class="line">/usr/java/jdk1.8.0_191-amd64/bin</span><br><span class="line">[root@node01 bin]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_191"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure>
<p>如果能看到Java的版本号说明JDK安装成功。</p>
<p>将Java加入环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 bin]<span class="comment"># vi /etc/profile.d/java.sh</span></span><br><span class="line">JAVA_HOME=/usr/java/default</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<h5 id="安装openjdk"><a href="#安装openjdk" class="headerlink" title="安装openjdk"></a>安装openjdk</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 bin]<span class="comment"># yum -y install java-11-openjdk-devel</span></span><br></pre></td></tr></table></figure>

<p>jdk多版本是可以同时安装的，可以使用alternatives命令设定默认使用的版本。</p>
<h4 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h4><h5 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h5><p>Tomcat相关包介绍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 bin]<span class="comment"># yum list tomcat*</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Available Packages</span><br><span class="line">tomcat.noarch                    </span><br><span class="line">tomcat-admin-webapps.noarch      <span class="comment">#tomcat自身管理的包</span></span><br><span class="line">tomcat-docs-webapp.noarch        </span><br><span class="line">tomcat-el-2.2-api.noarch         </span><br><span class="line">tomcat-javadoc.noarch            </span><br><span class="line">tomcat-jsp-2.2-api.noarch        </span><br><span class="line">tomcat-jsvc.noarch               </span><br><span class="line">tomcat-lib.noarch               </span><br><span class="line">tomcat-native.x86_64                </span><br><span class="line">tomcat-servlet-3.0-api.noarch    </span><br><span class="line">tomcat-webapps.noarch            <span class="comment">##Tomcat示例</span></span><br><span class="line">tomcatjss.noarch</span><br></pre></td></tr></table></figure>

<p>安装Tomcat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 bin]<span class="comment"># yum -y install tomcat-admin-webapps tomcat-webapps tomcat-docs-webapp</span></span><br></pre></td></tr></table></figure>
<p>安装完成后会自动生成一个unit file，可借助该unit file管理Tomcat。</p>
<p>Tomcat本身是java编写的文件，其各项功能的实现都需要通过类文件。提供类文件的包为tomcat-lib</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 yum.repos.d]<span class="comment"># yum info tomcat-lib</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Available Packages</span><br><span class="line">Name        : tomcat-lib</span><br><span class="line">Arch        : noarch</span><br><span class="line">Version     : 7.0.76</span><br><span class="line">Release     : 8.el7_5</span><br><span class="line">Size        : 3.9 M</span><br><span class="line">Repo        : updates-local</span><br><span class="line">Summary     : Libraries needed to run the Tomcat Web container</span><br><span class="line">URL         : http://tomcat.apache.org/</span><br><span class="line">License     : ASL 2.0</span><br><span class="line">Description : Libraries needed to run the Tomcat Web container.</span><br></pre></td></tr></table></figure>

<p>tomcat默认监听的端口有</p>
<ul>
<li>8080：http</li>
<li>8009：ajp</li>
<li>8005： 管理接口</li>
</ul>
<h5 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h5><p>由于yum仓库提供的版本比较旧，因此可以选择到官网下载较新的安装包自行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 tools]<span class="comment"># wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.37/bin/apache-tomcat-8.5.37.tar.gz</span></span><br><span class="line">[root@node02 tools]<span class="comment"># tar xf apache-tomcat-8.5.37.tar.gz -C /usr/local </span></span><br><span class="line">[root@node02 <span class="built_in">local</span>]<span class="comment"># ln -s apache-tomcat-8.5.37 tomcat</span></span><br><span class="line">[root@node02 tomcat]<span class="comment"># useradd tomcat #添加一个普通通湖以运行tomcat</span></span><br><span class="line">[root@node02 tomcat]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/tomcat/</span><br><span class="line">[root@node02 tomcat]<span class="comment"># chown -R tomcat.tomcat . #更改属主和所属组</span></span><br><span class="line">[root@node02 tomcat]<span class="comment"># su - tomcat -c "/usr/local/tomcat/bin/catalina.sh start" #以tomcat的身份运行</span></span><br></pre></td></tr></table></figure>

<p>经过以上步骤，实现了两种方式安装tomcat<br>OpenJDK 11 + Tomcat 7.0<br>Oracle JDK 8u191 + Tomcat 8.5</p>
<h3 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h3><p>tomcat的配置文件构成：</p>
<pre><code>server.xml：主配置文件；
web.xml：每个webapp只有“部署”后才能被访问，它的部署方式通常由web.xml进行定义，其存放位置为WEB-INF/目录中；此文件为所有的webapps提供默认部署相关的配置；
context.xml：每个webapp都可以专用的配置文件，它通常由专用的配置文件context.xml来定义，其存放位置为WEB-INF/目录中；此文件为所有的webapps提供默认配置；
tomcat-users.xml：用户认证的账号和密码文件；
catalina.policy：当使用-security选项启动tomcat时，用于为tomcat设置安全策略； 
catalina.properties：Java属性的定义文件，用于设定类加载器路径，以及一些与JVM调优相关参数；
logging.properties：日志系统相关的配置；    log4j</code></pre><p>Tomcat的核心组件：server.xml</p>
<pre><code>&lt;Server&gt;
    &lt;Service&gt;
        &lt;connector/&gt;
        &lt;connector/&gt;
        ...
        &lt;Engine&gt;
            &lt;Host&gt;
                &lt;Context/&gt;
                &lt;Context/&gt;
                ...
            &lt;/Host&gt;
            &lt;Host&gt;
                ...
            &lt;/Host&gt;
            ...
        &lt;/Engine&gt;
    &lt;/Service&gt;
&lt;/Server&gt;</code></pre><p>每一个组件都由一个Java“类”实现，这些组件大体可分为以下几个类型：<br>    顶级组件：Server<br>    服务类组件：Service<br>    连接器组件：http, https, ajp（apache jserv protocol）<br>    容器类：Engine, Host, Context<br>    被嵌套类：valve, logger, realm, loader, manager, …<br>    集群类组件：listener, cluster, …</p>
<p>java时春面向对象的，所以其每个组建的应用都必须先定义成一个类。</p>
<ul>
<li><p>对象式编程：以数据为中心，代码服务于数据。</p>
<blockquote>
<p>类：类通过属性实例化，类要通过方法进行调用。</p>
</blockquote>
</li>
<li><p>过程式编程：以代码为中心，数据服务于代码。</p>
</li>
</ul>
<p>JSP WebAPP的组织结构：</p>
<pre><code>/: webapps的根目录
    index.jsp, index.html：主页；
    WEB-INF/：当前webapp的私有资源路径；通常用于存储当前webapp的web.xml和context.xml配置文件；
    META-INF/：类似于WEB-INF/；
    classes/：类文件，当前webapp所提供的类；
    lib/：类文件，当前webapp所提供的类，被打包为jar格式；


    root /web/htdocs
        bbs/index.html =&gt; /bbs/index.html
        images/logo.jpg =&gt; /images/logo.jpg
        WEB-INF/web.xml =&gt; /WIN-INF/web.xml </code></pre><p>webapp归档格式：</p>
<pre><code>.war：webapp
.jar：EJB的类打包文件；
.rar：资源适配器类打包文件；
.ear：企业级webapp；</code></pre><p>部署(deploy)webapp的相关操作：</p>
<pre><code>deploy：将webapp的源文件放置于目标目录(网页程序文件存放目录)，配置tomcat服务器能够基于web.xml和context.xml文件中定义的路径来访问此webapp；将其特有的类和依赖的类通过class loader装载至JVM；
    部署有两种方式：
        自动部署：auto deploy
        手动部署:
            冷部署：把webapp复制到指定的位置，而后才启动tomcat；
            热部署：在不停止tomcat的前提下进行部署；
                部署工具：manager、ant脚本、tcd(tomcat client deployer)等；                    
undeploy：反部署，停止webapp，并从tomcat实例上卸载webapp；
start：启动处于停止状态的webapp；
stop：停止webapp，不再向用户提供服务；其类依然在jvm上；
redeploy：重新部署；</code></pre><h4 id="部署一个新子站点示例"><a href="#部署一个新子站点示例" class="headerlink" title="部署一个新子站点示例"></a>部署一个新子站点示例</h4><p>创建站点所需的目录及测试文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 ~]<span class="comment"># mkdir testapp/&#123;WEB-INF,META-INF,classes,lib&#125; -pv</span></span><br><span class="line">[root@node02 testapp]<span class="comment"># vi index.jsp</span></span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> %&gt; <span class="comment">#声明编程语言为java</span></span><br><span class="line">&lt;%@ page import=<span class="string">"java.util.*"</span> %&gt; <span class="comment">#导入java类库，名为java.util</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;Test Page&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;% out.println(<span class="string">"hello world"</span>); <span class="comment">#java代码，输出hello world</span></span><br><span class="line">		%&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>修改配置文件<br>将创建的测试程序放入tomcat主站点内，如果是yum安装的tomcat，则主站点在/usr/share/tomcat/webapps/目录下，这里是二进制安装的tomcat，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 webapps]<span class="comment"># cp -r /root/testapp-v0.1/ .</span></span><br><span class="line">[root@node02 webapps]<span class="comment"># ls</span></span><br><span class="line">docs  examples  host-manager  manager  ROOT  testapp-v0.1</span><br><span class="line">[root@node02 webapps]<span class="comment"># mv testapp-v0.1/ testapp</span></span><br><span class="line">[root@node02 webapps]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/tomcat/webapps</span><br></pre></td></tr></table></figure>
<p>此时在浏览器访问该站点就可以看到该程序内容</p>
<ul>
<li><a href="http://172.20.102.107:8080/testapp/" target="_blank" rel="noopener">http://172.20.102.107:8080/testapp/</a></li>
</ul>
<h4 id="将上述的子站点更改为一个独立的虚拟主机"><a href="#将上述的子站点更改为一个独立的虚拟主机" class="headerlink" title="将上述的子站点更改为一个独立的虚拟主机"></a>将上述的子站点更改为一个独立的虚拟主机</h4><p>修改配置文件，在engine内新增一个Host</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment"># vi /etc/tomcat/server.xml</span></span><br><span class="line">&lt;Host name=<span class="string">"www.msq.com"</span> appBase=<span class="string">"/root/webapp"</span></span><br><span class="line">            unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br></pre></td></tr></table></figure>


<h4 id="tomcat的工作目录"><a href="#tomcat的工作目录" class="headerlink" title="tomcat的工作目录"></a>tomcat的工作目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 work]<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/tomcat/work</span><br><span class="line">[root@node02 work]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">└── Catalina</span><br><span class="line">    └── localhost <span class="comment">#当前虚拟主机的名称</span></span><br><span class="line">        ├── docs</span><br><span class="line">        ├── examples</span><br><span class="line">        ├── host-manager</span><br><span class="line">        ├── manager</span><br><span class="line">        ├── ROOT</span><br><span class="line">        │   └── org</span><br><span class="line">        │       └── apache</span><br><span class="line">        │           └── jsp</span><br><span class="line">        │               ├── index_jsp.class</span><br><span class="line">        │               └── index_jsp.java</span><br><span class="line">        └── testapp</span><br><span class="line">            └── org</span><br><span class="line">                └── apache</span><br><span class="line">                    └── jsp</span><br><span class="line">                        ├── index_jsp.class</span><br><span class="line">                        └── index_jsp.java</span><br><span class="line"></span><br><span class="line">14 directories, 4 files</span><br></pre></td></tr></table></figure>

<h4 id="tomcat的server-xml配置文件"><a href="#tomcat的server-xml配置文件" class="headerlink" title="tomcat的server.xml配置文件"></a>tomcat的server.xml配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 tomcat]<span class="comment"># vi conf/server.xml</span></span><br><span class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt; <span class="comment">#server内建的管理接口，只要链上8005端口，送上一个'SHUTDOWN'字符串，就可以停止tomcat进程。所以比较危险，可以通过将该port改为-1来禁止监听该端口。</span></span><br><span class="line">&lt;Listener className=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><br><span class="line">&lt;Service name=<span class="string">"Catalina"</span>&gt; <span class="comment">#把connector与engine建立关联关系</span></span><br><span class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt; <span class="comment">#连接器，监听8080端口，使用http/1.1协议，连接超时时长为20s。</span></span><br><span class="line">               <span class="comment">#redirectport以为如果用户发送的连接请求为https，则将会话重定向至8443端口。</span></span><br><span class="line">               <span class="comment">#http协议的connector可以定义多个，但是要使用不同的端口。</span></span><br><span class="line">&lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span> jvmRoute=<span class="string">"jvm1"</span>&gt;</span><br><span class="line">	<span class="comment">#name为该引擎的名字，默认虚拟主机为localhost，JVMRoute为</span></span><br><span class="line">&lt;Host name=<span class="string">"localhost"</span>  appBase=<span class="string">"webapps"</span></span><br><span class="line">            unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt; <span class="comment">#虚拟主机，名字为localhost，</span></span><br><span class="line">            <span class="comment">#网页文件根目录为webapp，可以使用相对路径或绝对路径，相对路径是相对tomcat的根木目录来说。</span></span><br><span class="line">            <span class="comment">#是否自动展开WAR格式的文件，是否自动部署。</span></span><br><span class="line">     &lt;Valve className=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> directory=<span class="string">"logs"</span></span><br><span class="line">               prefix=<span class="string">"localhost_access_log."</span> suffix=<span class="string">".txt"</span></span><br><span class="line">               pattern=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt; <span class="comment">#定义日志格式</span></span><br><span class="line"> &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>

<p>定义虚拟主机host组件的常用属性说明<br>(1) appBase：此Host的webapps的默认存放目录，指存放非归档的web应用程序的目录或归档的WAR文件目录路径；可以使用基于$CATALINA_BASE变量所定义的路径的相对路径；<br>(2) autoDeploy：在Tomcat处于运行状态时，将某webapp放置于appBase所定义的目录中时，是否自动将其部署至tomcat；</p>
<p>在server.xml中新增一个host用于测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Host  name=<span class="string">"www.msq.com"</span>  appBase=<span class="string">"/data/testapp"</span></span><br><span class="line">                unpackWARs=<span class="string">"true"</span>  autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>
<p>此时在linux中按照配置生成测试文件如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node02 tomcat]<span class="comment"># tree /data/</span></span><br><span class="line">/data/</span><br><span class="line">└── testapp</span><br><span class="line">    ├── ROOT -&gt; /data/testapp/webapp-v0.1/</span><br><span class="line">    └── webapp-v0.1</span><br><span class="line">        ├── classes</span><br><span class="line">        ├── index.jsp</span><br><span class="line">        ├── lib</span><br><span class="line">        ├── META-INF</span><br><span class="line">        └── WEB-INF</span><br><span class="line"></span><br><span class="line">7 directories, 1 file</span><br></pre></td></tr></table></figure>
<p>此时在浏览器中就可以基于主机名访问host，注意名字解析！</p>
<h5 id="context组件"><a href="#context组件" class="headerlink" title="context组件"></a>context组件</h5><p>Context组件:类似于nginx中的alias。可内嵌与host组建中使用。</p>
<pre><code>示例：
    &lt;Context path=&quot;/PATH&quot; docBase=&quot;/PATH/TO/SOMEDIR&quot; reloadable=&quot;&quot;/&gt;</code></pre><p>Context使用示例，在上述创建的host中内嵌一个Context</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> &lt;Host  name=<span class="string">"www.msq.com"</span>  appBase=<span class="string">"/data/testapp"</span></span><br><span class="line">                unpackWARs=<span class="string">"true"</span>  autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">          &lt;Context path=<span class="string">"/myapp"</span> docBase=<span class="string">"/myapps/testapp"</span> reloadable=<span class="string">""</span>/&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>

<h5 id="valve组件"><a href="#valve组件" class="headerlink" title="valve组件"></a>valve组件</h5><p>过滤器</p>
<p><Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
    prefix="localhost_access_log" suffix=".txt"
    pattern="%h %l %u %t &quot;%r&quot; %s %b" /></p>
<p>Valve存在多种类型：</p>
<pre><code>定义访问日志：org.apache.catalina.valves.AccessLogValve
定义访问控制：org.apache.catalina.valves.RemoteAddrValve 

 &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; deny=&quot;172\.16\.100\.67&quot;/&gt;</code></pre><h5 id="manager-app"><a href="#manager-app" class="headerlink" title="manager app"></a>manager app</h5><p>管理应用程序的组件，程序的部署，反部署，启动，停止，增加虚拟主机或删除虚拟主机。<br><strong>使用manager app</strong><br>编辑tomcat-users.xml配置文件在其中增加一个管理用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ~]<span class="comment">#cd /etc/tomcat/</span></span><br><span class="line">[root@apache tomcat]<span class="comment">#vi tomcat-users.xml</span></span><br><span class="line">&lt;tomcat-users&gt;</span><br><span class="line">...</span><br><span class="line">&lt;role rolename=<span class="string">"manager-gui"</span>/&gt;</span><br><span class="line">&lt;user username=<span class="string">"tomcat"</span> password=<span class="string">"centos"</span> roles=<span class="string">"manager-gui"</span>/&gt;   </span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>
<p>之后在网站首页点击manager-app，输入用户名和密码即可使用manager app</p>
<p>在manager app中可以很方便的部署应用程序。</p>
<h5 id="host-manager"><a href="#host-manager" class="headerlink" title="host manager"></a>host manager</h5><p>管理虚拟主机的组件，可以停止或者启动，删除虚拟主机。</p>
<h3 id="使用nginx反向代理tomcat"><a href="#使用nginx反向代理tomcat" class="headerlink" title="使用nginx反向代理tomcat"></a>使用nginx反向代理tomcat</h3><p>使用nginx方向代理tomcat，如果被代理的tomcat上有多个虚拟主机时，要写被代理主机的主机名而非ip地址，如果内网主机太多时，就需要构建内网dns服务器。有两种代理方式<br>一、将所有的请求都代理给tomcat</p>
<pre><code>location / {
    proxy_pass http://127.0.0.1:8080
}</code></pre><p>二、动静分离的方式代理</p>
<pre><code>location ~* \.(jsp|do) {
    proxy_pass http://127.0.0.1:8080;
}
location / {
    root /data/myapp/ROOT/;
}</code></pre><p><strong>将tomcat放在docker容器中，在宿主机上安装nginx，使用nginx方向代理tomcat</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ~]<span class="comment">#docker run --name tc1 -v /uar/local/tomcat/webapps/ tomcat:8.5-alpine</span></span><br><span class="line">[root@apache ~]<span class="comment"># vi /etc/nginx/nginx.conf</span></span><br><span class="line">server&#123;</span><br><span class="line">	...</span><br><span class="line">	proxy_pass http:172.17.0.2:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用httpd反向代理tomcat"><a href="#使用httpd反向代理tomcat" class="headerlink" title="使用httpd反向代理tomcat"></a>使用httpd反向代理tomcat</h3><p>httpd的代理模块：</p>
<pre><code>proxy_module
proxy_http_module：适配http协议客户端；
proxy_ajp_module：适配ajp协议客户端；

proxy_http_module代理配置示例：
        &lt;VirtualHost *:80&gt;
            ServerName      tc1.magedu.com
            ProxyRequests Off
            ProxyVia        On
            ProxyPreserveHost On
            &lt;Proxy *&gt;
                Require all granted
            &lt;/Proxy&gt;
            ProxyPass / http://tc1.magedu.com:8080/
            ProxyPassReverse / http://tc1.magedu.com:8080/ 
            &lt;Location /&gt;
                Require all granted
            &lt;/Location&gt;
        &lt;/VirtualHost&gt;

            &lt;LocationMatch &quot;\.(jsp|do)$&gt;
                ProxyPass / http://tc1.magedu.com:8080/
            &lt;/LocationMatch&gt;</code></pre><p>proxy_ajp_module代理配置示例：</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ServerName      tc1.magedu.com
    ProxyRequests Off
    ProxyVia        On
    ProxyPreserveHost On
    &lt;Proxy *&gt;
        Require all granted
    &lt;/Proxy&gt;
        ProxyPass / ajp://tc1.magedu.com:8009/ 
        ProxyPassReverse / ajp://tc1.magedu.com:8009/ 
    &lt;Location /&gt;
        Require all granted
    &lt;/Location&gt;
&lt;/VirtualHost&gt;</code></pre><p>&lt;%@ page language=”java” %&gt;</p>
<html>
    <head><title>TomcatA</title><meta name="generator" content="Hexo 4.2.0"></head>
    <body>
        <h1><font color="red">TomcatA.magedu.com</font></h1>
        <table align="centre" border="1">
            <tr>
                <td>Session ID</td>
            <% session.setAttribute("magedu.com","magedu.com"); %>
                <td><%= session.getId() %></td>
            </tr>
            <tr>
                <td>Created on</td>
                <td><%= session.getCreationTime() %></td>
            </tr>
        </table>
    </body>
</html>

<h3 id="tomcat会话保持"><a href="#tomcat会话保持" class="headerlink" title="tomcat会话保持"></a>tomcat会话保持</h3><h4 id="session-sticky：会话保持，需要调度器用调度算法解决，会影响调度器的调度效果，也会导致session单点故障风险。"><a href="#session-sticky：会话保持，需要调度器用调度算法解决，会影响调度器的调度效果，也会导致session单点故障风险。" class="headerlink" title="session sticky：会话保持，需要调度器用调度算法解决，会影响调度器的调度效果，也会导致session单点故障风险。"></a>session sticky：会话保持，需要调度器用调度算法解决，会影响调度器的调度效果，也会导致session单点故障风险。</h4><p>session replication cluster：后端服务器，组织成集群，会增加服务器负载。</p>
<p>session server：在后端服务器之后设置session服务器专门存储session，session放在专门的session server上。将问题不断后置，对session server需要做高可用及主从。</p>
<p>在使用nginx负载均衡tomcat时，默认的算法为轮询(round roubin),这会导致每一个会话都会被当成一个新会话，没有会话保持的功能，session会话保持一：<strong>session sticky</strong>可以利用负载均衡器的算法实现：<br>配置负载均衡器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@docker ~]<span class="comment">#vi /etc/nginx/nginx.conf</span></span><br><span class="line">http&#123;</span><br><span class="line">	...</span><br><span class="line">	upstream websrvs &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$remote_addr</span> consistent;</span><br><span class="line">        server 192.168.34.108:8080;</span><br><span class="line">        server 192.168.34.103:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server&#123;</span><br><span class="line">    	...</span><br><span class="line">    	location / &#123;</span><br><span class="line">            proxy_pass http://websrvs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置可以实现将每个请求根据源地址哈希之后，都转发给固定的web服务器响应，但是这会影响负载均衡的效果，也会导致session单点丢失的可能。</p>
<h5 id="基于httpd的sessionsticky和blancer-manager功能"><a href="#基于httpd的sessionsticky和blancer-manager功能" class="headerlink" title="基于httpd的sessionsticky和blancer-manager功能"></a>基于httpd的sessionsticky和blancer-manager功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/httpd/conf.d/tomcat-httpd-claster.conf</span></span><br><span class="line">&lt;proxy balancer://tcsrvs&gt;</span><br><span class="line">	BalancerMember ajp://172.18.100.67:8009</span><br><span class="line">	BalancerMember ajp://172.18.100.68:8009</span><br><span class="line">	ProxySet lbmethod=byrequests</span><br><span class="line">&lt;/Proxy&gt;</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName lb.magedu.com</span><br><span class="line">	ProxyVia On</span><br><span class="line">	ProxyRequests Off</span><br><span class="line">	ProxyPreserveHost On</span><br><span class="line">	&lt;Proxy *&gt;</span><br><span class="line">		Require all granted</span><br><span class="line">	&lt;/Proxy&gt;</span><br><span class="line">	ProxyPass / balancer://tcsrvs/</span><br><span class="line">	ProxyPassReverse / balancer://tcsrvs/</span><br><span class="line">	&lt;Location /&gt;</span><br><span class="line">		Require all granted</span><br><span class="line">	&lt;/Location&gt;</span><br><span class="line">	&lt;Location /balancer-manager&gt;</span><br><span class="line">		SetHandler balancer-manager</span><br><span class="line">		ProxyPass !</span><br><span class="line">		Require all granted</span><br><span class="line">	&lt;/Location&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<h4 id="session-replication-cluster"><a href="#session-replication-cluster" class="headerlink" title="session replication cluster"></a>session replication cluster</h4><p>配置server.xml文件,在host配置段增加一个cluster的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache tomcat]<span class="comment">#vi /etc/tomcat/server.xml </span></span><br><span class="line">&lt;Host ...&gt;</span><br><span class="line">&lt;Cluster className=<span class="string">"org.apache.catalina.ha.tcp.SimpleTcpCluster"</span></span><br><span class="line">                 channelSendOptions=<span class="string">"8"</span>&gt;</span><br><span class="line"></span><br><span class="line">          &lt;Manager className=<span class="string">"org.apache.catalina.ha.session.DeltaManager"</span></span><br><span class="line">                   expireSessionsOnShutdown=<span class="string">"false"</span></span><br><span class="line">                   notifyListenersOnReplication=<span class="string">"true"</span>/&gt;</span><br><span class="line"></span><br><span class="line">          &lt;Channel className=<span class="string">"org.apache.catalina.tribes.group.GroupChannel"</span>&gt;</span><br><span class="line">            &lt;Membership className=<span class="string">"org.apache.catalina.tribes.membership.McastService"</span></span><br><span class="line">                        address=<span class="string">"228.0.0.4"</span></span><br><span class="line">                        port=<span class="string">"45564"</span></span><br><span class="line">                        frequency=<span class="string">"500"</span></span><br><span class="line">                        dropTime=<span class="string">"3000"</span>/&gt;</span><br><span class="line">            &lt;Receiver className=<span class="string">"org.apache.catalina.tribes.transport.nio.NioReceiver"</span></span><br><span class="line">                      address=<span class="string">"auto"</span></span><br><span class="line">                      port=<span class="string">"4000"</span></span><br><span class="line">                      autoBind=<span class="string">"100"</span></span><br><span class="line">                      selectorTimeout=<span class="string">"5000"</span></span><br><span class="line">                      maxThreads=<span class="string">"6"</span>/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;Sender className=<span class="string">"org.apache.catalina.tribes.transport.ReplicationTransmitter"</span>&gt;</span><br><span class="line">              &lt;Transport className=<span class="string">"org.apache.catalina.tribes.transport.nio.PooledParallelSender"</span>/&gt;</span><br><span class="line">            &lt;/Sender&gt;</span><br><span class="line">            &lt;Interceptor className=<span class="string">"org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"</span>/&gt;</span><br><span class="line">            &lt;Interceptor className=<span class="string">"org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor"</span>/&gt;</span><br><span class="line">          &lt;/Channel&gt;</span><br><span class="line"></span><br><span class="line">          &lt;Valve className=<span class="string">"org.apache.catalina.ha.tcp.ReplicationValve"</span></span><br><span class="line">                 filter=<span class="string">""</span>/&gt;</span><br><span class="line">          &lt;Valve className=<span class="string">"org.apache.catalina.ha.session.JvmRouteBinderValve"</span>/&gt;</span><br><span class="line"></span><br><span class="line">          &lt;Deployer className=<span class="string">"org.apache.catalina.ha.deploy.FarmWarDeployer"</span></span><br><span class="line">                    tempDir=<span class="string">"/tmp/war-temp/"</span></span><br><span class="line">                    deployDir=<span class="string">"/tmp/war-deploy/"</span></span><br><span class="line">                    watchDir=<span class="string">"/tmp/war-listen/"</span></span><br><span class="line">                    watchEnabled=<span class="string">"false"</span>/&gt;</span><br><span class="line"></span><br><span class="line">          &lt;ClusterListener className=<span class="string">"org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener"</span>/&gt;</span><br><span class="line">          &lt;ClusterListener className=<span class="string">"org.apache.catalina.ha.session.ClusterSessionListener"</span>/&gt;</span><br><span class="line">        &lt;/Cluster&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>
<p>配置web.xml文件，添加以下元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache tomcat]<span class="comment">#vi /webapps/myapp/WEB-INF/web.xml </span></span><br><span class="line">&lt;distributable/&gt;</span><br></pre></td></tr></table></figure>
<p>此时，session cluster就完成了配置，重启tomcat服务器就可以实现session replication cluster。</p>
<h3 id="session-server"><a href="#session-server" class="headerlink" title="session server"></a>session server</h3><p>将session会话保存到特殊的存储服务器上，存储系统性能要足够高，而且要有冗余能力，</p>
<h4 id="基于memcached建立session-server"><a href="#基于memcached建立session-server" class="headerlink" title="基于memcached建立session server"></a>基于memcached建立session server</h4><p>memcached是一种基于cache的存储系统，</p>
<ul>
<li>cache：无持久能力，重启后数据丢失。</li>
</ul>
<p>redis是一种store类型的存储系统</p>
<ul>
<li>store：持久是必备功能</li>
</ul>
<p>memcached实用内存的方法，将分配的内存一次性占用完，做预分配，减少出现内存随便，<br>安装memcached</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#yum -y install memcached</span></span><br></pre></td></tr></table></figure>
<p>安装memcached客户端命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#yum -y install libmemcached</span></span><br></pre></td></tr></table></figure>
<p>tomcat要使用memcached作为session服务器，需要安装相关组件：<br><a href="https://github.com/magro/memcached-session-manager" target="_blank" rel="noopener">https://github.com/magro/memcached-session-manager</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache tomcat]<span class="comment">#wget http://repo1.maven.org/maven2/de/javakaffee/msm/memcached-session-manager/2.3.2/memcached-session-manager-2.3.2.jar</span></span><br><span class="line">[root@apache tomcat]<span class="comment">#wget http://repo1.maven.org/maven2/net/spy/spymemcached/2.12.3/spymemcached-2.12.3.jar</span></span><br></pre></td></tr></table></figure>

<p>修改配置文件，对需要增加配置的虚拟主机增加一个context</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/tomcat/server.xml</span></span><br><span class="line">&lt;Context path=<span class="string">"/myapp"</span> docBase=<span class="string">"/webapps/myapp"</span> reloadable=<span class="string">""</span>&gt;</span><br><span class="line">        &lt;Manager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span><br><span class="line">    memcachedNodes=<span class="string">"n1:host1.yourdomain.com:11211,n2:host2.yourdomain.com:11211"</span></span><br><span class="line">    failoverNodes=<span class="string">"n1"</span></span><br><span class="line">    requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">    transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span></span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<p>此时重启tomcat局可以将session保存在memcached中，需要保证java正常启动不报错，openjdk和tomcat7组合使用会报错，tomcat7和openjdk8组合使用正常。</p>
]]></content>
      <tags>
        <tag>tomcat</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible进阶</title>
    <url>/2018/05/20/ansible%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="YAML语言简介"><a href="#YAML语言简介" class="headerlink" title="YAML语言简介"></a>YAML语言简介</h2><p>YAML是一个可读性高的用来表达资料序列的格式。<br>YAML参考了其他多种语言，包括：XML、C语言、Python以及电子邮件格式RFC2822等。<br>YAML特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YAML的可读性好</span><br><span class="line">YAML和脚本语言的交互性好</span><br><span class="line">YAML使用实现语言的数据类型</span><br><span class="line">YAML有一个一致的信息模型</span><br><span class="line">YAML易于实现</span><br><span class="line">YAML可以基于流来处理</span><br><span class="line">YAML表达能力强，扩展性好</span><br></pre></td></tr></table></figure>

<h3 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在单一档案中，可用连续三个连字号(-)区分多个档案。另外，还有选择性的连续三个点号( ... )用来表示档案结尾，次行开始正常写Playbook的内容，一般建议写明该Playbook的功能</span><br><span class="line">使用#号注释代码</span><br><span class="line">缩进必须是统一的，不能空格和tab混用</span><br><span class="line">缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的</span><br><span class="line">YAML文件内容是区别大小写的，k&#x2F;v的值均需大小写敏感</span><br><span class="line">k&#x2F;v的值可同行写也可换行写。同行使用:分隔</span><br><span class="line">v可是个字符串，也可是另一个列表</span><br><span class="line">一个完整的代码块功能需最少元素需包括 name: task</span><br><span class="line"> 一个name只能包括一个task</span><br><span class="line"> YAML文件扩展名通常为yml或yaml</span><br></pre></td></tr></table></figure>

<p><strong>List：列表，其所有元素均使用”-“开头</strong><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># A list of tasty fruits</span><br><span class="line">- Apple</span><br><span class="line">- Orange</span><br><span class="line">- Strawberry</span><br><span class="line">- Mango</span><br></pre></td></tr></table></figure>

<p><strong>Dictionary：字典，通常由多个key与value构成</strong><br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># An employee record</span><br><span class="line">name: Example Developer</span><br><span class="line">job: Developer</span><br><span class="line">skill: Elite</span><br></pre></td></tr></table></figure>
<p>也可以将key:value放置于{}中进行表示，用,分割多个key:value<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># An employee record</span><br><span class="line">&#123;name: Example Developer, job: Developer, skill: Elite&#125;</span><br></pre></td></tr></table></figure>

<p>YAML的语法和其他高阶语言类似，并且可以简单的表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列(Sequence)里的项用”-“来代表，Map里的键值对用”:”分割<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: John Smith</span><br><span class="line">age: 41</span><br><span class="line">gender: Male</span><br><span class="line">spouse:</span><br><span class="line">  - name: Jane Smith</span><br><span class="line">    age: 37</span><br><span class="line">    gender: Female</span><br><span class="line">children:</span><br><span class="line">  - name: Jimmy Smith</span><br><span class="line">    age: 17</span><br><span class="line">    gender: Male</span><br><span class="line">  - name: Jenny Smith</span><br><span class="line">    age 13</span><br><span class="line">    gender: Female</span><br></pre></td></tr></table></figure>

<h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><h3 id="playbook核心元素"><a href="#playbook核心元素" class="headerlink" title="playbook核心元素"></a>playbook核心元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hosts 执行的远程主机列表</span><br><span class="line">Tasks 任务集</span><br><span class="line">Varniables 内置变量或自定义变量在playbook中调用</span><br><span class="line">Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件</span><br><span class="line">Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</span><br><span class="line">tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断</span><br><span class="line">	ansible-playbook –t tagsname useradd.yml</span><br></pre></td></tr></table></figure>

<h3 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h3><p><strong>hosts</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hosts：</span><br><span class="line">	playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中</span><br><span class="line">	可以是如下形式：</span><br><span class="line">		one.example.com</span><br><span class="line">		one.example.com:two.example.com</span><br><span class="line">		192.168.1.50</span><br><span class="line">		192.168.1.*</span><br><span class="line">	Websrvs:dbsrvs 或者，两个组的并集</span><br><span class="line">	Websrvs:&amp;dbsrvs 与，两个组的交集</span><br><span class="line">	webservers:!phoenix 在websrvs组，但不在dbsrvs组</span><br><span class="line"> 		示例: - hosts: websrvs：dbsrvs</span><br></pre></td></tr></table></figure>

<p><strong>remote_user</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote_user: 可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: test connection</span><br><span class="line">    ping:</span><br><span class="line">    remote_user: magedu</span><br><span class="line">    sudo: yes # 默认sudo为root</span><br><span class="line">    sudo_user:wang # sudo为wang</span><br></pre></td></tr></table></figure>

<p><strong>task列表和action</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后，再开始第二个任务</span><br><span class="line">task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致</span><br><span class="line">每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出</span><br></pre></td></tr></table></figure>
<p><strong>tasks：任务列表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两种格式：</span><br><span class="line">	(1) action: module arguments</span><br><span class="line">	(2) module: arguments 建议使用</span><br><span class="line">注意：shell和command模块后面跟命令，而非key&#x3D;value</span><br><span class="line">某任务的状态在运行后为changed时，可通过“notify”通知给相应的handlers</span><br><span class="line">任务可以通过&quot;tags“打标签，可在ansible-playbook命令上使用-t指定进行调用</span><br><span class="line">	 示例：</span><br><span class="line"> 	tasks:</span><br><span class="line">	- name: disable selinux</span><br><span class="line"> 	  command: &#x2F;sbin&#x2F;setenforce 0</span><br></pre></td></tr></table></figure>

<p><strong>是某些返回值不为0的任务不报错的方法</strong><br>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: &#x2F;usr&#x2F;bin&#x2F;somecommand || &#x2F;bin&#x2F;true</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: &#x2F;usr&#x2F;bin&#x2F;somecommand</span><br><span class="line">    ignore_errors: True</span><br></pre></td></tr></table></figure>

<h3 id="运行playbook"><a href="#运行playbook" class="headerlink" title="运行playbook"></a>运行playbook</h3><p><strong>运行playbook的方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible-playbook filename.yml ... [options]</span><br></pre></td></tr></table></figure>
<p><strong>常见option</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--check -C 只检测可能会发生的改变，但不真正执行操作</span><br><span class="line">--list-hosts 列出运行任务的主机</span><br><span class="line">--list-tags 列出tag</span><br><span class="line">--list-tasks 列出task</span><br><span class="line">--limit 主机列表 只针对主机列表中的主机执行</span><br><span class="line">-v -vv -vvv 显示过程</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible-playbook file.yml --check 只检测</span><br><span class="line">ansible-playbook file.yml</span><br><span class="line">ansible-playbook file.yml --limit websrvs</span><br></pre></td></tr></table></figure>

<h3 id="handlers和notify结合使用触发条件"><a href="#handlers和notify结合使用触发条件" class="headerlink" title="handlers和notify结合使用触发条件"></a>handlers和notify结合使用触发条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handlers</span><br><span class="line">	是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作</span><br><span class="line">Notify此action可用于在每个play的最后被触发，这样可避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。</span><br><span class="line">在notify中列出的操作称为handler，也即notify中调用handler中定义的操作</span><br></pre></td></tr></table></figure>

<h3 id="在playbook中使用标签"><a href="#在playbook中使用标签" class="headerlink" title="在playbook中使用标签"></a>在playbook中使用标签</h3><p>Ansible 允许给playbook里面的资源通过自定义的关键字打上标签，然后只运行与关键字一致的部分代码<br>多个动作可以使用同一个标签<br>只执行特定tags</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible-playbook -t tags file.yml</span><br></pre></td></tr></table></figure>

<p><strong>使用示例：playbook实现安装配置运行httpd服务，并且当配置发生更改时重启服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat httpd_install.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: groupadd</span><br><span class="line">      group: name=apache gid=80 system=yes</span><br><span class="line">    - name: useradd</span><br><span class="line">      user: name=apache uid=80 group=apache comment=apache </span><br><span class="line">            shell=/sbin/nologin system=yes home=/usr/share/apache</span><br><span class="line">            password=<span class="string">'$1$Z6yqJ4Ea$Ti0QkIPmPWwaFrWbkPwzy1'</span></span><br><span class="line">    - name: install app</span><br><span class="line">      tags: install</span><br><span class="line">      yum: name=httpd</span><br><span class="line">    - name: conf</span><br><span class="line">      copy: src=/root/httpd.conf dest=/etc/httpd/conf/httpd.conf </span><br><span class="line">            backup=yes</span><br><span class="line">      tags: config</span><br><span class="line">      notify: </span><br><span class="line">        - restart</span><br><span class="line">        - check httpd</span><br><span class="line">    - name: service</span><br><span class="line">      tags: service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart</span><br><span class="line">      service: name=httpd state=restarted</span><br><span class="line">    - name: check httpd</span><br><span class="line">      shell: /usr/bin/killall -0 httpd &amp;&gt; /tmp/httpd.log</span><br></pre></td></tr></table></figure>

<h2 id="playbook中的变量"><a href="#playbook中的变量" class="headerlink" title="playbook中的变量"></a>playbook中的变量</h2><p>变量名：仅能由字母、数字和下划线组成，且只能以字母开头</p>
<p><strong>变量来源</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、ansible setup facts远程主机的所有变量都可直接调用</span><br><span class="line">2、在&#x2F;etc&#x2F;ansible&#x2F;hosts中定义</span><br><span class="line">  普通变量：主机组中主机单独定义，优先级个哦与公共变量</span><br><span class="line">  公共（组）变量：针对主机组中所有主机定义同一变量</span><br><span class="line">3、通过命令行指定变量，优先级最高</span><br><span class="line">  ansible-playbook -e varname&#x3D;balue</span><br><span class="line">4、在playbook中定义变量</span><br><span class="line">  vars:</span><br><span class="line">    - var1: value1</span><br><span class="line">    - var2: value2</span><br><span class="line">5、在独立的变量YAML文件中定义</span><br><span class="line">6、在role中定义</span><br></pre></td></tr></table></figure>

<p>变量的生效顺序：</p>
<p><strong>变量使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过&#123;&#123; variable_name &#125;&#125;调用变量，且变量名前后必须有空格，有时用&quot;&#123;&#123; variable_name &#125;&#125;&quot;才能生效</span><br><span class="line">ansible-playbook -e 选项指定</span><br><span class="line">  ansible-playbook test.yml -e &quot;hosts&#x3D;www user&#x3D;msq&quot;</span><br></pre></td></tr></table></figure>

<h3 id="变量使用示例"><a href="#变量使用示例" class="headerlink" title="变量使用示例"></a>变量使用示例</h3><p><strong>使用ansible命令定义变量</strong><br>在playbook中调用变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cat /root/playbook/vars_test.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: install app</span><br><span class="line">      yum: name=&#123;&#123; app_name &#125;&#125;</span><br><span class="line">    - name: start app</span><br><span class="line">      service: name=&#123;&#123; app_name &#125;&#125; state=started</span><br></pre></td></tr></table></figure>

<p>在执行playbook时定义给变量赋值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible-playbook /root/playbook/vars_test.yml -e app_name=vsftpd</span></span><br></pre></td></tr></table></figure>

<p><strong>在playbook中直接定义变量，并调用变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat vars_test.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    - name1: samba</span><br><span class="line">    - name2: smbd</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install app</span><br><span class="line">      yum: name=&#123;&#123; name1 &#125;&#125; </span><br><span class="line">    - name: start app</span><br><span class="line">      service: name=&#123;&#123; name2 &#125;&#125; state=started</span><br></pre></td></tr></table></figure>

<p><strong>使用专门的文件存放变量</strong><br>将变量存放在专门的文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat vars.yml </span></span><br><span class="line">name1: samba</span><br><span class="line">nsme2: smbd</span><br></pre></td></tr></table></figure>

<p>在playbook中调用存放变量的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat vars_test.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars_files:</span><br><span class="line">    - vars.yml</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install app</span><br><span class="line">      yum: name=&#123;&#123; name1 &#125;&#125; </span><br><span class="line">    - name: start app</span><br><span class="line">      service: name=&#123;&#123; name2 &#125;&#125; state=started</span><br></pre></td></tr></table></figure>

<p><strong>在主机清单中定义变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat /etc/ansible/hosts</span></span><br><span class="line">[appsrvs]</span><br><span class="line">192.168.34.106 nodename=centos7_1</span><br><span class="line">192.168.34.101 nodename=centod7_2 <span class="comment">#主机变量</span></span><br><span class="line"></span><br><span class="line">[appsrvs:vars] <span class="comment">#组变量</span></span><br><span class="line">suffix=msq</span><br></pre></td></tr></table></figure>

<p>在playbook中调用变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cat /root/playbook/changename.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: changename</span><br><span class="line">      hostname: name=&#123;&#123; nodename &#125;&#125;.&#123;&#123; suffix &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板templates"><a href="#模板templates" class="headerlink" title="模板templates"></a>模板templates</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文本文件，嵌套有脚本（使用模板编程语言编写）</span><br><span class="line">Jinja2语言，使用字面量，有下面形式</span><br><span class="line">  字符串：使用单引号或双引号</span><br><span class="line">  数字：整数，浮点数</span><br><span class="line">  列表：[item1, item2, ...]</span><br><span class="line">  元组：(item1, item2, ...)</span><br><span class="line">  字典：&#123;key1:value1, key2:value2, ...&#125;</span><br><span class="line">  布尔型：true&#x2F;false</span><br><span class="line">算术运算：+, -, *, &#x2F;, &#x2F;&#x2F;(整除；与取模正好相反), %, **</span><br><span class="line">比较操作：&#x3D;&#x3D;, !&#x3D;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</span><br><span class="line">逻辑运算：and, or, not</span><br><span class="line">流表达式：For If When</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">templates功能：根据模块文件动态生成对应的配置文件</span><br><span class="line">  templates文件必须存放于templates目录下，且命名为 .j2 结尾</span><br><span class="line">  yaml&#x2F;yml 文件需和templates目录平级，目录结构如下：</span><br><span class="line">    .&#x2F;</span><br><span class="line">    ├── temnginx.yml</span><br><span class="line">    └── templates</span><br><span class="line">        └── nginx.conf.j2</span><br></pre></td></tr></table></figure>

<p><strong>模板使用示例</strong><br><em>以安装nginx为例</em><br>模板文件必须放在templates文件夹下，templates文件夹与调用该模板的playbook需要是平级的关系。<br>将NGINX配置文件作为模板放入templates中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cp /etc/nginx/nginx.conf /root/playbook/templates/nginc.conf.j2</span></span><br></pre></td></tr></table></figure>
<p>在playbook中使用模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat nginx_install.yml </span></span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install</span><br><span class="line">      yum: name=nginx</span><br><span class="line">    - name: template</span><br><span class="line">      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">      notify: restart</span><br><span class="line">    - name: service</span><br><span class="line">      service: name=nginx state=started</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart</span><br><span class="line">      service: name=nginx state=restarted</span><br></pre></td></tr></table></figure>
<p>此时的目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">├── nginx_install.yml</span><br><span class="line">├── templates</span><br><span class="line">│   └── nginx.conf.j2</span><br></pre></td></tr></table></figure>

<p><em>此例即为使用模板批量配置多台主机，模板文件中可以使用变量。</em></p>
<h3 id="plabook中的template-for-if语句的用法示例"><a href="#plabook中的template-for-if语句的用法示例" class="headerlink" title="plabook中的template for if语句的用法示例"></a>plabook中的template for if语句的用法示例</h3><p><strong>变量示例</strong><br>写一个测试用playbook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat for_test3.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    ports:</span><br><span class="line">      - 81</span><br><span class="line">      - 82</span><br><span class="line">      - 83</span><br><span class="line">  tasks:</span><br><span class="line">    - name: template</span><br><span class="line">      template: src=test_for3.conf.j2 dest=/data/test_for3.conf</span><br></pre></td></tr></table></figure>

<p>增加一个对应的模板文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat templates/test_for3.conf.j2 </span></span><br><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> ports %&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen &#123;&#123;i&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>执行该playbook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#ansible-playbook  for_test3.yml</span></span><br></pre></td></tr></table></figure>

<p>查看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#ansible appsrvs -a 'cat /data/test_for3.conf'</span></span><br><span class="line">192.168.34.106 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 81</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 82</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 83</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">192.168.34.101 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 81</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 82</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 83</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>字典示例</strong><br>写一个测试用paybook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat for_test2.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    ports:</span><br><span class="line">      - listen_port: 81</span><br><span class="line">      - listen_port: 82</span><br><span class="line">      - listen_port: 83</span><br><span class="line">  tasks:</span><br><span class="line">    - name: template</span><br><span class="line">      template: src=test_for2.conf.j2 dest=/data/test_for2.conf</span><br></pre></td></tr></table></figure>

<p>增加一个对应的模板文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">      template: src=test_for2.conf.j2 dest=/data/test_for2.conf</span><br><span class="line">[root@ansible ~/playbook]<span class="comment">#cat templates/test_for2.conf.j2 </span></span><br><span class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> ports %&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen &#123;&#123;i.listen_port&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>执行该playbook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#ansible-playbook  for_test2.yml</span></span><br></pre></td></tr></table></figure>

<p>到客户端查看执行效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#ansible appsrvs -a 'cat /data/test_for2.conf'</span></span><br><span class="line">192.168.34.106 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 81</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 82</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 83</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">192.168.34.101 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 81</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 82</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 83</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>列表示例</strong><br>写一个测试用playbook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat for_test.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  vars:</span><br><span class="line">    vhosts:</span><br><span class="line">      - host1:</span><br><span class="line">        listen_port: 81</span><br><span class="line">        host_name: www.a.com</span><br><span class="line">        dirname: /data/www1</span><br><span class="line">      - host2:</span><br><span class="line">        listen_port: 82</span><br><span class="line">        <span class="comment">#host_name: www.b.com</span></span><br><span class="line">        dirname: /data/www2</span><br><span class="line">      - host3:</span><br><span class="line">        listen_port: 83</span><br><span class="line">        host_name: www.c.com</span><br><span class="line">        dirname: /data/www3</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: template</span><br><span class="line">      template: src=test_for.conf.j2 dest=/data/test_for.conf</span><br></pre></td></tr></table></figure>

<p>增加一个模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat templates/test_for.conf.j2 </span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">for</span> p <span class="keyword">in</span> ports %&#125; </span><br><span class="line"> server&#123;</span><br><span class="line">        listen &#123;&#123;p.listen_port&#125;&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> p.host_name is defined %&#125;</span><br><span class="line">        server_name &#123;&#123;p.hostname&#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">        dirname &#123;&#123;p.dirname&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p>执行playbook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#ansible-playbook for_test.yml</span></span><br></pre></td></tr></table></figure>

<p>取被控端主机检查执行效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#ansible appsrvs -a 'cat /data/tes*'</span></span><br><span class="line">192.168.34.106 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  listen 81</span><br><span class="line">  host_name www.a.com</span><br><span class="line">  dirname /data/www1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  listen 82</span><br><span class="line">  <span class="comment">#host_name www.b.com</span></span><br><span class="line">  dirname /data/www2</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  listen 83</span><br><span class="line">  host_name www.c.com</span><br><span class="line">  dirname /data/www3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">192.168.34.101 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  listen 81</span><br><span class="line">  host_name www.a.com</span><br><span class="line">  dirname /data/www1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  listen 82</span><br><span class="line">  <span class="comment">#host_name www.b.com</span></span><br><span class="line">  dirname /data/www2</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">  listen 83</span><br><span class="line">  host_name www.c.com</span><br><span class="line">  dirname /data/www3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="在playbook中使用when判断"><a href="#在playbook中使用when判断" class="headerlink" title="在playbook中使用when判断"></a>在playbook中使用when判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">条件测试：如果需要根据变量、facts或此前任务的执行结果来作为某task执行与否的前提时要用到条件测试，通过when语句实现，在task中使用，jinja2的语法格式</span><br><span class="line">when语句</span><br><span class="line">  在task后添加when子语句即可使用条件测试；when语句支持jinja2表达式语法</span><br></pre></td></tr></table></figure>
<p><strong>when条件测试使用示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat nginx_install.yml </span></span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install</span><br><span class="line">      yum: name=nginx</span><br><span class="line">    - name: template</span><br><span class="line">      template: src=nginx6.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">      notify: restart</span><br><span class="line">      when: ansible_distribution_major_version==<span class="string">"6"</span></span><br><span class="line">    - name: template</span><br><span class="line">      template: src=nginx7.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">      when: ansible_distribution_major_version==<span class="string">"7"</span></span><br><span class="line">      notify: restart</span><br><span class="line">    - name: service</span><br><span class="line">      service: name=nginx state=started</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart</span><br><span class="line">      service: name=nginx state=restarted</span><br></pre></td></tr></table></figure>

<p>在playbook文件夹下的templates文件夹中，存放了nginx6.conf.j2、nginx7.conf.j2两个配置文件。其目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">├── nginx_install.yml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── nginx6.conf.j2</span><br><span class="line">│   └── nginx7.conf.j2</span><br></pre></td></tr></table></figure>

<h2 id="playbook中的迭代"><a href="#playbook中的迭代" class="headerlink" title="playbook中的迭代"></a>playbook中的迭代</h2><p>with_items：当有需要重复执行的任务时，可以使用迭代机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对迭代选项的引用，固定变量名为&quot;item&quot;</span><br><span class="line">要在task中使用with_items给定要迭代的元素列表</span><br><span class="line">列表格式：</span><br><span class="line">  字符串</span><br><span class="line">  字典</span><br></pre></td></tr></table></figure>

<p><strong>with_items使用示例</strong><br>字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat with_items.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: useradd</span><br><span class="line">      user: name=&#123;&#123; item &#125;&#125;</span><br><span class="line">      with_items:</span><br><span class="line">        - testuser1</span><br><span class="line">        - testuser2</span><br></pre></td></tr></table></figure>
<p>字典</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#cat with_items.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: groupadd</span><br><span class="line">      group: name=&#123;&#123;item&#125;&#125;</span><br><span class="line">      with_items:</span><br><span class="line">        - g1</span><br><span class="line">        - g2</span><br><span class="line">    - name: useradd</span><br><span class="line">      user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125;</span><br><span class="line">      with_items:</span><br><span class="line">        - &#123;name: <span class="string">'user1'</span>,group: <span class="string">'g1'</span>&#125;</span><br><span class="line">        - &#123;name: <span class="string">'user2'</span>,group: <span class="string">'g2'</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><p><em>ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中</em></p>
<p>复杂场景：建议使用roles，代码复用度高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变更指定主机或主机组</span><br><span class="line">如命名不规范维护和传承成本太大</span><br><span class="line">某些功能需要多个playbook，通过includes即可实现</span><br></pre></td></tr></table></figure>

<p><strong>roles的文件结构</strong><br>需要执行的yml文件和roles文件夹是同级的关系，在roles问价下有实现各种不同功能的子目录如httpd等，在httpd下又有子目录如tasks、files、vars等目录。如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~/playbook]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">├── httpd_install.yml</span><br><span class="line">├── nginx_install.yml</span><br><span class="line">├── ping.yml</span><br><span class="line">├── roles</span><br><span class="line">│   ├── httpd</span><br><span class="line">│   │   ├── files</span><br><span class="line">│   │   ├── handlers</span><br><span class="line">│   │   ├── tasks</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   └── vars</span><br><span class="line">│   ├── memcached</span><br><span class="line">│   │   ├── files</span><br><span class="line">│   │   ├── handlers</span><br><span class="line">│   │   ├── tasks</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   └── vars</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   │   ├── files</span><br><span class="line">│   │   ├── handlers</span><br><span class="line">│   │   ├── tasks</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   └── vars</span><br><span class="line">│   └── nginx</span><br><span class="line">│       ├── files</span><br><span class="line">│       ├── handlers</span><br><span class="line">│       ├── tasks</span><br><span class="line">│       ├── templates</span><br><span class="line">│       └── vars</span><br></pre></td></tr></table></figure>

<h4 id="示例：用角色的方式实现httpd的安装"><a href="#示例：用角色的方式实现httpd的安装" class="headerlink" title="示例：用角色的方式实现httpd的安装"></a>示例：用角色的方式实现httpd的安装</h4><p><strong>将各个task分别写成文件放入tasks文件夹下，将模板文件放到files文件夹下，tasks文件夹中的main.yml文件内写入各个task的执行次序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible httpd]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">├── files</span><br><span class="line">│   └── httpd.conf</span><br><span class="line">├── handlers</span><br><span class="line">├── tasks</span><br><span class="line">│   ├── config.yml</span><br><span class="line">│   ├── group.yml</span><br><span class="line">│   ├── install.yml</span><br><span class="line">│   ├── main.yml</span><br><span class="line">│   ├── service.yml</span><br><span class="line">│   └── user.yml</span><br><span class="line">├── templates</span><br><span class="line">└── vars</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ansible httpd]<span class="comment">#cat tasks/main.yml </span></span><br><span class="line">- include: group.yml</span><br><span class="line">- include: user.yml</span><br><span class="line">- include: install.yml</span><br><span class="line">- include: config.yml</span><br><span class="line">- include: service.yml</span><br></pre></td></tr></table></figure>

<p><strong>在与roles同级别目录下写一个playbook，调用该role</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible playbook]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">├── httpd_role.yml</span><br><span class="line">├── roles</span><br><span class="line">│   ├── httpd</span><br><span class="line">│   │   ├── files</span><br><span class="line">│   │   │   └── httpd.conf</span><br><span class="line">│   │   ├── handlers</span><br><span class="line">│   │   ├── tasks</span><br><span class="line">│   │   │   ├── config.yml</span><br><span class="line">│   │   │   ├── group.yml</span><br><span class="line">│   │   │   ├── install.yml</span><br><span class="line">│   │   │   ├── main.yml</span><br><span class="line">│   │   │   ├── service.yml</span><br><span class="line">│   │   │   └── user.yml</span><br><span class="line">│   │   ├── templates</span><br><span class="line">│   │   └── vars</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible playbook]<span class="comment">#cat httpd_role.yml </span></span><br><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  roles:</span><br><span class="line">    - role: httpd</span><br></pre></td></tr></table></figure>

<h4 id="示例：用角色的方式定制memcached的缓存大小"><a href="#示例：用角色的方式定制memcached的缓存大小" class="headerlink" title="示例：用角色的方式定制memcached的缓存大小"></a>示例：用角色的方式定制memcached的缓存大小</h4><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="roles之间的相互调用"><a href="#roles之间的相互调用" class="headerlink" title="roles之间的相互调用"></a>roles之间的相互调用</h3><h4 id="以安装NGINX为例示范roles之间的相互调用"><a href="#以安装NGINX为例示范roles之间的相互调用" class="headerlink" title="以安装NGINX为例示范roles之间的相互调用"></a>以安装NGINX为例示范roles之间的相互调用</h4><p><strong>文件结构如下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible nginx]<span class="comment">#pwd</span></span><br><span class="line">/root/playbook/roles/nginx</span><br><span class="line">[root@ansible nginx]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">├── files</span><br><span class="line">├── handlers</span><br><span class="line">│   └── main.yml</span><br><span class="line">├── tasks</span><br><span class="line">│   ├── config.yml</span><br><span class="line">│   ├── data.yml</span><br><span class="line">│   ├── install.yml</span><br><span class="line">│   ├── main.yml</span><br><span class="line">│   └── service.yml</span><br><span class="line">├── templates</span><br><span class="line">│   └── nginx.conf.j2</span><br><span class="line">└── vars</span><br></pre></td></tr></table></figure>

<p><strong>其中data.yml文件调用httpd角色中的文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible nginx]<span class="comment">#cat tasks/data.yml </span></span><br><span class="line">- name: copy</span><br><span class="line">  copy: src=roles/httpd/files/index.html dest=/usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p><strong>在config.yml中使用notify-handler组合</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible nginx]<span class="comment">#cat tasks/config.yml </span></span><br><span class="line">- name: config file</span><br><span class="line">  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  notify: restart</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible nginx]<span class="comment">#cat handlers/main.yml </span></span><br><span class="line">- name: restart</span><br><span class="line">  service: name=nginx state=restarted</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> ：handlers文件夹下必须以main.yml为文件名，不然会报错，因为找不到执行handler的入口</p>
]]></content>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible入门</title>
    <url>/2018/05/08/ansible%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="相关专业术语"><a href="#相关专业术语" class="headerlink" title="相关专业术语"></a>相关专业术语</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IaaS	基础设施即服务</span><br><span class="line">PaaS	平台即服务</span><br><span class="line">SaaS	软件即服务</span><br></pre></td></tr></table></figure>

<p><strong>安装ansible</strong><br>需要使用epel源安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#yum -y install ansible</span></span><br></pre></td></tr></table></figure>

<p><strong>ansible特性</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模块化：调用特定的模块，完成特定的内容</span><br><span class="line">有Paramiko，PyYAML，jinja2（模板语言）三个关键模块</span><br><span class="line">支持自定义模块</span><br><span class="line">基于python语言实现</span><br><span class="line">部署简单，基于python和SSH，agentless（无代理）-w</span><br><span class="line">安全，基于openssh</span><br><span class="line">支持playbook编排任务</span><br><span class="line">幂等性，一个任务执行一边和n遍效果一样不因重复执行带来意外情况</span><br><span class="line">无需代理不依赖PKI（无需ssl）</span><br><span class="line">可使用任何编程语言编写模块</span><br><span class="line">YAML格式，编排任务，支持丰富的数据结构</span><br><span class="line">交强大的多层解决方案</span><br></pre></td></tr></table></figure>

<h2 id="Ansible主要组成部分"><a href="#Ansible主要组成部分" class="headerlink" title="Ansible主要组成部分"></a>Ansible主要组成部分</h2><h3 id="INVENTORY-主机清单"><a href="#INVENTORY-主机清单" class="headerlink" title="INVENTORY(主机清单)"></a>INVENTORY(主机清单)</h3><p>存放在/etc/ansible/hosts</p>
<p><strong>查看主机清单中的主机数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all --list-hosts</span></span><br></pre></td></tr></table></figure>

<p><strong>查看主机清单中某个分组的主机数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible groupname --list-hosts</span></span><br></pre></td></tr></table></figure>

<p><strong>查看即在A组又在B组中的主机数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible "A:&amp;B" --list-hosts</span></span><br></pre></td></tr></table></figure>

<p><strong>查看A组合B租中的所有有主机数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible "A:B" --list-hosts</span></span><br></pre></td></tr></table></figure>

<p><strong>查看在A组中却不在B组中的主机数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible 'A:!B' --list-hosts</span></span><br></pre></td></tr></table></figure>
<p>有叹号只能用单引号</p>
<h3 id="ansible配置文件修改以提高工作效率"><a href="#ansible配置文件修改以提高工作效率" class="headerlink" title="ansible配置文件修改以提高工作效率"></a>ansible配置文件修改以提高工作效率</h3><p><strong>ansible配置文件中的默认值说明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[defaults]</span><br><span class="line"></span><br><span class="line"># some basic default values...</span><br><span class="line"></span><br><span class="line">#inventory      &#x3D; &#x2F;etc&#x2F;ansible&#x2F;hosts	#主机清单文件</span><br><span class="line">#library        &#x3D; &#x2F;usr&#x2F;share&#x2F;my_modules&#x2F;	#库文件存放目录</span><br><span class="line">#module_utils   &#x3D; &#x2F;usr&#x2F;share&#x2F;my_module_utils&#x2F; 	#模块存放路径</span><br><span class="line">#remote_tmp     &#x3D; ~&#x2F;.ansible&#x2F;tmp 	#远程执行py命令文件临时存放目录</span><br><span class="line">#local_tmp      &#x3D; ~&#x2F;.ansible&#x2F;tmp 	#本地命令文件临时存放目录</span><br><span class="line">#plugin_filters_cfg &#x3D; &#x2F;etc&#x2F;ansible&#x2F;plugin_filters.yml 	#插件</span><br><span class="line">#forks          &#x3D; 5  	#默认并发数</span><br><span class="line">#poll_interval  &#x3D; 15 	#拉取间隔</span><br><span class="line">#sudo_user      &#x3D; root 	#默认sudo用户</span><br><span class="line">#ask_sudo_pass &#x3D; True 	#每次执行ansible命令是否询问ssh密码</span><br><span class="line">#ask_pass      &#x3D; True</span><br><span class="line">#transport      &#x3D; smart</span><br><span class="line">#remote_port    &#x3D; 22</span><br><span class="line">#module_lang    &#x3D; C</span><br><span class="line">#module_set_locale &#x3D; False</span><br></pre></td></tr></table></figure>

<p><strong>启用ansible日志功能</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#sed -i -r '/log_path/s/#(.*)/\1/' /etc/ansible/ansible.cfg</span></span><br></pre></td></tr></table></figure>

<p><strong>禁用ssh_key检查</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#sed -i -r '/ssh_key_checking/s/#(.*)/\1/' /etc/ansible/ansible.cfg</span></span><br></pre></td></tr></table></figure>

<h3 id="ansible命令的执行过程"><a href="#ansible命令的执行过程" class="headerlink" title="ansible命令的执行过程"></a>ansible命令的执行过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加载自己的配置文件，默认为&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg</span><br><span class="line">加载自己对应的模块文件，如command</span><br><span class="line">通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME&#x2F;.ansible&#x2F;tmp&#x2F;ansible-tmp-数字&#x2F;XXX.PY文件</span><br><span class="line">给文件加执行权限+x</span><br><span class="line">执行并返回结果</span><br><span class="line">删除临时文件，sleep 0退出</span><br></pre></td></tr></table></figure>

<p><strong>命令执行状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绿色：执行成功并且不需要做改变的操作</span><br><span class="line">黄色：执行成功并且对目标主机做改变</span><br><span class="line">红色：执行失败</span><br></pre></td></tr></table></figure>

<h2 id="ansible系列命令"><a href="#ansible系列命令" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h2><p><strong>ansible-vault 给敏感文件加密或解密</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: ansible-vault [create|decrypt|edit|encrypt|encrypt_string|rekey|view] [options] [vaultfile.yml]</span><br></pre></td></tr></table></figure>

<p><strong>ansible-console</strong><br>可交互执行命令</p>
<h3 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h3><p>连接<a href="https://galaxy.ansible.com" target="_blank" rel="noopener">https://galaxy.ansible.com</a> 下载响应的roles</p>
<p><strong>列出所有已经安装的Galaxy</strong><br>    ansible-galaxy list</p>
<p><strong>安装Galaxy</strong><br>    ansible-galaxy install roles-name</p>
<h2 id="ansible常见模块介绍"><a href="#ansible常见模块介绍" class="headerlink" title="ansible常见模块介绍"></a>ansible常见模块介绍</h2><p><strong>修改默认模块</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#sed -i -r '/module_name/s/.*/module_name = shell/' /etc/ansible/ansible.cfg</span></span><br></pre></td></tr></table></figure>

<h3 id="command模块"><a href="#command模块" class="headerlink" title="command模块"></a>command模块</h3><p>在远程主机执行linux命令</p>
<h3 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h3><h3 id="script模块"><a href="#script模块" class="headerlink" title="script模块"></a>script模块</h3><p>调用脚本在远程主机执行</p>
<p>使用方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m script -a "脚本的绝对路径"</span></span><br></pre></td></tr></table></figure>


<h3 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h3><p>将服务器文件复制到客户端</p>
<p>使用案例:将本机/root/playbook/install_nginx.yml文件拷贝到websrvs组各主机的/data目录下,并制定权限和属主，如果木变主机存在同名文件，则先备份后复制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m copy -a "src=/root/playbook/install_nginx.yml dest=/data/ mode=644 owner=msq backup=yes"</span></span><br></pre></td></tr></table></figure>

<h3 id="fetch模块"><a href="#fetch模块" class="headerlink" title="fetch模块"></a>fetch模块</h3><p>从客户端呢拉取文件至服务器，与copy模块功能相反，目录可先打包tar</p>
<p>使用案例，将websrvs组中的主机上/data目录中的install_nginx.yml文件拉取到本机的/data目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m fetch -a 'src=/data/install_nginx.yml dest=/data/'</span></span><br></pre></td></tr></table></figure>

<p>此时/data目录结构是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#tree /data/</span></span><br><span class="line">/data/</span><br><span class="line">├── 192.168.34.106</span><br><span class="line">│   └── data</span><br><span class="line">│       └── install_nginx.yml</span><br><span class="line">└── 192.168.34.108</span><br><span class="line">    └── data</span><br><span class="line">        └── install_nginx.yml</span><br><span class="line"></span><br><span class="line">4 directories, 2 files</span><br></pre></td></tr></table></figure>

<p>说明：从目标主机拉取文件，会放到指定dest下以目标主机ip为名字的文件夹下</p>
<h3 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a>file模块</h3><p>设置文件属性</p>
<p><strong>使用案例1：将websrvs组中的主机的/data/install_nginx.yml文件的属主改为msq，权限设为600.</strong><br>开始其属性如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -a 'ls -l /data/install_nginx.yml'</span></span><br><span class="line">192.168.34.106 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">-rw-r--r-- 1 root root 145 Nov 21 20:39 /data/install_nginx.yml</span><br><span class="line"></span><br><span class="line">192.168.34.108 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">-rw-r--r-- 1 root root 145 Nov 21 20:38 /data/install_nginx.yml</span><br></pre></td></tr></table></figure>

<p>更改属性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m file -a 'path=/data/install_nginx.yml owner=msq mode=600'</span></span><br></pre></td></tr></table></figure>

<p>之后在查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -a 'ls -l /data/install_nginx.yml'</span></span><br><span class="line">192.168.34.106 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">-rw------- 1 msq root 145 Nov 21 20:39 /data/install_nginx.yml</span><br><span class="line"></span><br><span class="line">192.168.34.108 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">-rw------- 1 msq root 145 Nov 21 20:38 /data/install_nginx.yml</span><br></pre></td></tr></table></figure>

<p><strong>使用案例2：为websrvs组的各主机上的/data/install_nginx.yml文件创建软连接</strong></p>
<p>创建测试文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m file -a 'dest=/data/f1 state=touch'</span></span><br></pre></td></tr></table></figure>

<p>创建软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m file -a 'src=/data/f1 dest=/data/f1.link state=link'</span></span><br></pre></td></tr></table></figure>

<h3 id="cron模块"><a href="#cron模块" class="headerlink" title="cron模块"></a>cron模块</h3><p>管理计划任务</p>
<p><strong>使用案例：为主机列表中的额所有主机设置定时任务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m cron -a 'name=synctime minute=*/5 job="ntpdate 192.168.34.103 &amp;&gt; /dev/null"'</span></span><br></pre></td></tr></table></figure>

<p><strong>临时禁用上一步设置的定时任务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m cron -a 'name=synctime minute=*/5 job="ntpdate 192.168.34.103 &amp;&gt; /dev/null" disabled=yes'</span></span><br></pre></td></tr></table></figure>

<p><strong>再启用刚才禁用的计划任务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m cron -a 'name=synctime minute=*/5 job="ntpdate 192.168.34.103 &amp;&gt; /dev/null" disabled=false'</span></span><br></pre></td></tr></table></figure>
<p>禁用的时候，不能只加name，需要加计划任务的内容</p>
<p><strong>永久删除该计划任务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m cron -a 'name=synctime minute=*/5 job="ntpdate 192.168.34.103 &amp;&gt; /dev/null" state=absent'</span></span><br></pre></td></tr></table></figure>
<p>删除的时候可以只加name</p>
<h3 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h3><p>利用yum管理安装包</p>
<p><strong>使用案例1：安装NGINX</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m yum -a 'name=nginx'</span></span><br></pre></td></tr></table></figure>

<p><strong>使用案例2：删除NGINX，连带删除安装NGINX是安装的依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible all -m yum -a 'name=nginx autoremove=yes'</span></span><br></pre></td></tr></table></figure>

<h3 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a>service模块</h3><p>管理服务</p>
<p><strong>开启服务，并加入开机自启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansiblde websrvs -m service -a 'name=httpd state=started enabled=yes'</span></span><br></pre></td></tr></table></figure>
<p>除此之外，state还有restarted reload stop 等各种状态。</p>
<h3 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a>user模块</h3><p>管理用户</p>
<p><strong>创建用户test，并指定uid，主组，从组，家目录，shell，描述，</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m user -a 'name=test uid=1024 group=root groups=msq shell=/bin/csh comment="this is a test" '</span></span><br></pre></td></tr></table></figure>

<p><strong>删除用户连带删除家目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ansible websrvs -m user -a 'name=test state=absent remove=yes'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2018/04/19/nginx/</url>
    <content><![CDATA[<h2 id="Nginx作为web服务器"><a href="#Nginx作为web服务器" class="headerlink" title="Nginx作为web服务器"></a>Nginx作为web服务器</h2><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p><strong>main配置段常见的配置指令</strong></p>
<ul>
<li><p>正常运行必备的配置</p>
<blockquote>
<p>user<br>  Syntax: user user [group];<br>  Default: user nobody nobody<br>  Context: main<br>  定义Nginx的worker进程的属主和属组</p>
</blockquote>
<blockquote>
<p>pid /path/to/pid_file;<br>  指定存储NGINX主进程进程号的文件路径</p>
</blockquote>
<blockquote>
<p>include file | mask;<br>  指明包含进来的其他配置文件片段</p>
</blockquote>
<blockquote>
<p>load_module file;<br>  指明要装载的动态模块</p>
</blockquote>
</li>
<li><p>性能优化相关的配置</p>
<blockquote>
<p>worker_processes number | auto;<br>  worker进程的数量，通常应该等于小于当前主机的cpu的物理核心数<br>  auto：当前主机物理CPU核心数</p>
</blockquote>
<blockquote>
<p>worker_cpu_affinity cpumask…;<br>  worker_cpu_affinity auto [cpumask];<br>  nginx进程的CPU亲缘性，让特定进程与特定CPU绑定，提升缓存的命中率，提升性能。<br>  CPU mask：bit mask<br>  00000000：<br>  0000 0001：0号CPU<br>  0000 0010：1号CPU<br>  0000 0100：2号CPU<br>  … …</p>
</blockquote>
<p>  0000 0011：0和1号CPU；</p>
<blockquote>
<p>worker_priority number;<br>  指定worker进程的nice值，设定worker进程优先级；[-20,20]</p>
</blockquote>
<blockquote>
<p>worker_rlimit_nofile number;<br>  worker进程所能够打开的文件数连接上限</p>
</blockquote>
</li>
<li><p>调试、定位问题</p>
<blockquote>
<p>daemon on|off<br>  是否以master/worker模型运行NGINX；默认为on</p>
</blockquote>
<blockquote>
<p>error_log file [level];</p>
</blockquote>
</li>
<li><p>时间驱动相关的配置</p>
<blockquote>
<p>events {<br>  …<br>}<br>worker_connections number;<br>  每个worker进程所能够打开的最大并发连接数数量<br>  worker_processes * worker_connections为网站最大并发连接量</p>
</blockquote>
<blockquote>
<p>use method;<br>  执行并发连接请求的处理方法<br>  use epoll;</p>
</blockquote>
<blockquote>
<p>accept_mutex on | off;<br>  处理新的连接请求的方法，on意味着由各worker轮流处理新情求，off意味着每个新情求的到达都会通知所有的worker进程。</p>
</blockquote>
</li>
</ul>
<p><strong>与套接字相关的配置</strong><br>配置在http{}语句块内</p>
<ul>
<li><p>server {…}<br>配置一个虚拟主机</p>
<blockquote>
<p>server{<br>  listen address[:port] | PORT;<br>  server_name SERVER_NAME;<br>  root /path/to/document_root;<br>}</p>
</blockquote>
</li>
<li><p>listen PORT|address[:port]|unix:/path/to/socket_file<br>listen address[:port] [default_server] [ssl] [http2|spdy] [backlog=number] [rcvbuf=size] [sndbuf=size]</p>
<blockquote>
<p>default_server:设定为默认虚拟主机；<br>ssl：限制仅能够通过ssl连接提供服务；<br>backlog=number：后援队列长度；<br>rcvbuf=size：接受缓冲区大小；<br>sndbuf=size：发送缓冲区大小；</p>
</blockquote>
</li>
<li><p>server_name name …;<br>指明虚拟主机的主机名称；后可跟多个由空白字符分割的字符串；<br>支持*通配任意长度的任意字符串；servername *.msq.com <a href="http://www.msq.\" target="_blank" rel="noopener">www.msq.\</a>*<br>支持~起始的字符做正则表达式模式匹配；server_name ~^www\d+.msq.com$</p>
<blockquote>
<p>匹配机制：<br>首先是字符串精确匹配<br>左侧*通配符<br>右侧*通配符<br>正则表达式</p>
</blockquote>
</li>
<li><p>tcp_nodelay on|off;<br>在keepalived模式下的连接是否启用TCP_NODELAY选项；建议启用<br>tcp_nopush on|off;<br>在sendfile模式下，是否启用TCP_CORK选项；</p>
</li>
<li><p>sendfile on|off;<br>是否启用sendfile功能；内核直接将封装的效应报文返回给客户端。</p>
</li>
</ul>
<p><strong>定义路径相关的配置</strong></p>
<ul>
<li><p>root path;<br>设置web资源路径映射，用于指明用户请求的URL所对应的本地文件系统上的文档所在目录路径；可用的位置：http,server,location,if in location;</p>
</li>
<li><p>location [=|<del>|</del>*|^~] uri {…}<br>在一个server中location配置段可存在多个，用于实现从uri到文件系统的路径映射；nginx会根据用户请求的URI来检查定义的所有location，并找出一个最佳匹配，而后应用其配置。</p>
<blockquote>
<p>=:对URI做正则表达式模式匹配，区分字符大小写；<br><del>：对URI做正则表达式模式匹配，区分字符大小写；<br>~*：对URI做正则表达式模式匹配，不区分字符大小写；<br>^</del>：对URI的左半部分做匹配检查，不区分字符大小写；<br>不带符号：以URI为前缀的所有URI；</p>
</blockquote>
</li>
</ul>
<p>匹配优先级：=, ^<del>, ~/</del>*，不带符号；<br>location配置示例：<br>location = / {<br>    [ configuration A ]<br>}</p>
<p>location / {<br>    [ configuration B ]<br>}</p>
<p>location /documents/ {<br>    [ configuration C ]<br>}</p>
<p>location ^~ /images/ {<br>    [ configuration D ]<br>}</p>
<p>location ~* .(gif|jpg|jpeg)$ {<br>    [ configuration E ]<br>}<br>The “/” request will match configuration A, the “/index.html” request will match configuration B, the “/documents/document.html” request will match configuration C, the “/images/1.gif” request will match configuration D, and the “/documents/1.jpg” request will match configuration E.</p>
<ul>
<li><p>alias path;<br>定义别名，文档映射的另一种机制；仅能用于location上下文；<br>注意：location中使用root指令和alias指令的意义不同；</p>
<blockquote>
<p>root:给定的路径对应于location中的/uri/左侧的/;<br>alias：给定的路径对应于location中的/uri/右侧的/;</p>
</blockquote>
</li>
<li><p>index file …;<br>默认资源，可放在http,server,location字段。</p>
</li>
<li><p>error_page code … [=[response]] uri;<br>defined the URI that will be shown for the specified errors.</p>
<blockquote>
<p>error_page 404 /404.html;<br>location = /404.html {<br>  root “/www/error_pages”;<br>}</p>
</blockquote>
</li>
<li><p>try_file file … rui;<br>定义客户端请求的相关配置</p>
</li>
<li><p>keepalive_timeout timeout [header_timeout];<br>设定保持连接的超时时长，0表示禁止长连接；默认为75s。</p>
</li>
<li><p>keepalive_requests number;<br>在一次长连接上所允许请求的资源的最大数量，默认为100；</p>
</li>
<li><p>keepalived_disable none | browser …;<br>对那种浏览器禁用长连接。</p>
</li>
<li><p>send_timeout time;<br>向客户端发送响应报文的超时时长，此处，是指两次写操作之间的间隔时长。</p>
</li>
<li><p>client_body_buffer_size size;<br>用于接受客户端请求报文的body部分的缓冲区大小；默认为16k；超出此大小时，其将被暂存到磁盘上的有client_body_temp_path指令所定义的位置；</p>
</li>
<li><p>client_body_temp_path path [level1 [level2 [level3]]];<br>设定用于存储客户端请求报文的body部分的临时存储路径及子目录结构和数量；</p>
</li>
</ul>
<p><strong>对客户端进行限制的相关配置</strong></p>
<ul>
<li><p>limit_rate rate;<br>限制响应给客户端的传输速率，单位是bytes/second，0表示无限制；</p>
</li>
<li><p>limit_except method … {…}<br>限制对指定的请求方法之外的其他方法的使用客户端</p>
<blockquote>
<p>limit_except GET {<br>  allow 192.168.1.0/24;<br>  deny all;<br>}</p>
</blockquote>
</li>
</ul>
<p><strong>文件操作优化的配置</strong></p>
<ul>
<li><p>aio on|off|threads[=pool];<br>是否启用aio功能，异步io功能，开启会大幅提升nginx性能。</p>
</li>
<li><p>directio size | off;<br>在linux主机启用O_DIRECT标记，此处意味着文件大于等于给定的大小时使用，例如directio 4m;</p>
</li>
<li><p>open_file_cache off;<br>open_file_cache max=N [incative=time];</p>
<blockquote>
<p>max=N:可缓存的缓存项上限；达到上线后会使用LRU算法实现缓存管理；<br>inactive=time:缓存项的非活动时长，在此处指定的市场内未被命中的或命中的次数少于open_file_cache_min_uses指令所指定的次数的缓存项即为非活动项。</p>
</blockquote>
</li>
</ul>
<p>nginx可以缓存以下三种信息：</p>
<blockquote>
<p>文件的描述符、文件大小和最近一次的修改时间；<br>打开的目录结构<br>没有找到的或者没有权限访问的文件的相关信息；</p>
</blockquote>
<ul>
<li><p>open_file_cache_min_uses number;<br>在open_file_cache指令的inactive参数指定的时长内，至少应该被命中多少次方可被归类为活动项；</p>
</li>
<li><p>open_file_cache_errors on | off;<br>是否缓存查找时发生错误的文件一类的信息；</p>
</li>
</ul>
<h3 id="Nginx模块"><a href="#Nginx模块" class="headerlink" title="Nginx模块"></a>Nginx模块</h3><p><strong>ngx_http_access_module模块</strong><br>实现基于ip的访问控制功能<br>可应用于http,server,location,limit_except语句块</p>
<blockquote>
<p>allow address | CIDR | unix: | all;<br>deny address | CIDR | unix: |all;</p>
</blockquote>
<p><strong>ngx_http_auth_basic_module模块</strong><br>实现基于用户的访问控制权限，使用basic机制进行用户认证。</p>
<ul>
<li>auth_basic string | off;</li>
<li>auth_basic_user_file file;<blockquote>
<p>location /admin/ {<br>  alias /webapps/app1/data/;<br>  auth_basic “Admin Area”;<br>  auth_basic_user_file /etc/nginx/.ngxpasswd;<br>}<br>注意：htpasswd命令由httpd-tools包提供。</p>
</blockquote>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-4 ~]<span class="comment">#vi /etc/nginx/nginx.conf</span></span><br><span class="line">	serevr &#123;</span><br><span class="line">		...</span><br><span class="line">		auth_basic <span class="string">"Admin Area"</span>;</span><br><span class="line">		auth_basic_user_file /etc/nginx/.ngxpasswd;</span><br><span class="line">	&#125;</span><br><span class="line">[root@host-10-10-10-4 ~]<span class="comment">#htpasswd -b -m -c /etc/nginx/.ngxpasswd tom 123456</span></span><br></pre></td></tr></table></figure>
<p>此时就需要在客户端先登录才能查看网站内容。</p>
<p><strong>ngx_http_stub_status_module模块</strong><br>用于输出nginx的基本状态信息；<br>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@host-10-10-10-4 ~]<span class="comment">#vi /etc/nginx/nginx.conf</span></span><br><span class="line">location /status &#123;</span><br><span class="line">            stub_status;</span><br><span class="line">        &#125;</span><br><span class="line">[root@host-10-10-10-4 ~]<span class="comment">#nginx -s reload</span></span><br><span class="line">[root@host-10-10-10-11 ~]<span class="comment">#curl 10.10.10.4:8080/status</span></span><br><span class="line">Active connections: 1 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 65 65 76 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 0</span><br></pre></td></tr></table></figure>
<p>输出信息详解：</p>
<blockquote>
<p>Active connections: 活动状态的连接数；<br>accepts：已经接受的客户端请求的总数；<br>handled：已经处理完成的客户端请求的总数；<br>requests：客户端发来的总的请求数；<br>Reading：处于读取客户端请求报文首部的连接的连接数；<br>Writing：处于向客户端发送响应报文过程中的连接数；<br>Waiting：处于等待客户端发出请求的空闲连接数；</p>
</blockquote>
<p><strong>ngx_http_log_module模块</strong><br>控制用户请求的记录格式<br>log_format name string …;<br>    string可以使用nginx核心模块及其他模块内嵌的变量；<br>access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; access_log off; #访问日志文件路径，格式及相关的缓冲配置；<br>buffer=size<br>flush=time<br>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">log_format  main  <span class="string">'$remote_addr(远程地址) - $remote_user(远程用户) [$time_local](访问时间) "$request"(请求方式) '</span></span><br><span class="line">                      <span class="string">'$status(处理状态) $body_bytes_sent(响应报文大小) "$http_referer"(从哪跳转过来的) '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent"(客户端浏览器) "$http_x_forwarded_for"(远程用户真实地址)'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log(日志存放位置)  main(日志格式);</span><br></pre></td></tr></table></figure>

<p>open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];<br>open_log_file_cache off;<br>    缓存各日志文件相关的元数据信息；<br>max：缓存的最大文件描述符数量；<br>min_uses：在inactive指定的时长内访问大于等于此值方可被当作活动项；<br>inactive：非活动时长；<br>valid：验正缓存中各缓存项是否为活动项的时间间隔；</p>
<p><strong>ngx_http_gzip_module模块</strong></p>
<ul>
<li><p>gzip on | off;<br>是否启用压缩功能</p>
</li>
<li><p>gzip_comp_level level;<br>设置压缩级别；</p>
</li>
<li><p>gzip_disable regex …;<br>对匹配到的客户端浏览器不启用压缩功能；</p>
</li>
<li><p>gzip_min_length length;<br>启用压缩功能的响应报文大小阈值；大于该值的响应报文才进行压缩；</p>
</li>
<li><p>gzip_buffers number size;<br>支持实现压缩功能时为其配置的缓冲区数量及每个缓冲区的大小；</p>
</li>
<li><p>gzip_proxied off | expired | no-cache | bo-store | private | no_last_modified | no_etag | auth | any …;<br>nginx作为代理服务器接收到从被代理服务器发送的响应报文后，在何种条件下启用压缩功能的；</p>
<blockquote>
<p>off:对代理的请求不启用<br>no-cache, no-store，private：表示从被代理服务器收到的响应报文首部的Cache-Control的值为此三者中任何一个，则启用压缩功能；</p>
</blockquote>
</li>
<li><p>gzip_types mime-type …;<br>压缩过滤器，进队此处设定的MIME类型的内容启用压缩功能；</p>
</li>
</ul>
<p>示例</p>
<pre><code>gzip  on;
gzip_comp_level 6;
gzip_min_length 64;
gzip_proxied any;
gzip_types text/xml text/css  application/javascript;</code></pre><p><strong>ngz_http_ssl_module模块</strong><br>实现https功能的模块<br>实现https模板</p>
<pre><code>server {
    listen 443 ssl; #监听443端口并强制使用ssl连接
    server_name www.magedu.com;
    root /vhosts/ssl/htdocs;
    ssl on; #开启ssl功能
    ssl_certificate /etc/nginx/ssl/nginx.crt; #当前虚拟主机使用PEM格式的证书文件
    ssl_certificate_key /etc/nginx/ssl/nginx.key; #当前虚拟主机与其证书匹配的私钥文件
    ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]; #支持ssl协议版本，默认为后三个；
    ssl_session_cache shared:sslcache:20m; #使用openssl内建的缓存，此缓存为每worker进程私有。
    ssl_session_timeout 5m; #客户端一侧的连接可以服用ssl session cache中缓存的ssl参数的有效时长；
}    </code></pre><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-4 ssl]<span class="comment">#vi /etc/nginx/nginx.conf</span></span><br><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">	...</span><br><span class="line">	server &#123;</span><br><span class="line">	listen 443 ssl;</span><br><span class="line">	server_name www.msq.com;</span><br><span class="line">	root <span class="string">"/data/ssl/html"</span>;</span><br><span class="line">	ssl on;</span><br><span class="line">	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;</span><br><span class="line">	ssl_certificate /etc/nginx/ssl/nginx.crt;</span><br><span class="line">	ssl_certificate_key /etc/nginx/ssl/nginx.key;</span><br><span class="line">	ssl_session_cache shared:sslcache:20m;</span><br><span class="line">	ssl_session_timeout 10m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@10-10-10-4 ssl]<span class="comment">#[root@10-10-10-4 ssl]#pwd</span></span><br><span class="line">/etc/nginx/ssl</span><br><span class="line">[root@10-10-10-4 ssl]<span class="comment">#[root@10-10-10-4 ssl]#openssl genrsa -out nginx.key 2048</span></span><br><span class="line">[root@10-10-10-4 ssl]<span class="comment">#openssl req -new -x509 -key nginx.key -out nginx.crt -days 3650 -subj "/CN=www.msq.io"</span></span><br></pre></td></tr></table></figure>

<p><strong>ngx_http_rewrite_module模块</strong><br>将用户请求的URI基于regex所描述的模式进行检查，而后完成替换，可用在server，location，if语句块内。</p>
<ul>
<li>rewrite regex replacement [flag]<br>将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为replacement指定的新的URI；<br>注意：如果在同一级配置块中存在多个rewrite规则，name会自上而下逐个检查，被某条规则替换完成后，会开始新一轮的替换检查，因此，隐含有循环机制；[flag]所表示的标志位用于控制此循环机制；</li>
</ul>
<p>如果replacement是以http://或https://开头，则替换结果会直接以重定向方式返回给客户端；</p>
<p>[flag]<br><strong>last</strong>：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后对新的URI启动新一轮重写检查；提前重启新一轮循环；<br><strong>break</strong>：重写完成后停止对当前URI在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置；结束循环；<br><strong>redirect</strong>：重写完成后以临时重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；<br><strong>permanent</strong>:重写完成后以永久重定向方式直接返回重写后生成的新URI给客户端，由客户端重新发起请求；</p>
<p>URL重定向示例:将所有以/bbs/开始的请求都将/bbs/重写为/forum/开头的请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># vi /etc/nginx/nginx.conf</span></span><br><span class="line">http &#123;</span><br><span class="line">	server &#123;</span><br><span class="line">		...</span><br><span class="line">		location /bbs/ &#123;</span><br><span class="line">            rewrite ^/bbs/(.*)$ /forum/<span class="variable">$1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将对<a href="http://www.msq.com/bbs/和www.msq.com/forum/的请求重写到forum.msq.com上" target="_blank" rel="noopener">www.msq.com/bbs/和www.msq.com/forum/的请求重写到forum.msq.com上</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># vi /etc/nginx/nginx.conf</span></span><br><span class="line">http &#123;</span><br><span class="line">	server &#123;</span><br><span class="line">		server_name www.msq.com ;</span><br><span class="line">		...</span><br><span class="line">		location /(bbs|forum)/ &#123;</span><br><span class="line">			rewrite ^/(bbs|forum)/(.*)$ http://forum.msq.com/<span class="variable">$2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>return</p>
<blockquote>
<p>return code [text];<br>return code URL;<br>return URL;<br>Stops processing and returns the specified code to a client. </p>
</blockquote>
</li>
<li><p>rewrite_log on | off;<br>是否开启重写日志；</p>
</li>
<li><p>if (condition) { … }<br>引入一个新的配置上下文 ；条件满足时，执行配置块中的配置指令；server, location；</p>
<blockquote>
<p>condition：<br>  比较操作符：</p>
<pre><code>==
!=
~：模式匹配，区分字符大小写；
~\*：模式匹配，不区分字符大小写；
!~：模式不匹配，区分字符大小写；
!~\*：模式不匹配，不区分字符大小写；</code></pre><p>  文件及目录存在性判断：</p>
<pre><code>-e, !-e
-f, !-f
-d, !-d
-x, !-x</code></pre></blockquote>
</li>
<li><p>set $variable value;<br>用户自定义变量；</p>
</li>
</ul>
<p><strong>ngx_http_referer_module模块</strong><br>The ngx_http_referer_module module is used to block access to a site for requests with invalid values in the “Referer” header field.</p>
<ul>
<li>valid_referers none|blocked|server_names|string…;<br>定义referer首部的合法可用值可配置在server，location上下文。<blockquote>
<p>none：请求报文首部没有referer首部；<br>blocked：请求报文的referer首部没有值；<br>server_names：参数，其可以有值作为主机名或主机名模式；<br>  arbitrary_string：直接字符串，但可使用<em>作通配符；<br>  regular expression：被指定的正则表达式模式匹配到的字符串；要使用~打头，例如 ~.</em>.magedu.com；</p>
</blockquote>
</li>
</ul>
<p>示例：</p>
<pre><code>valid_referers none blocked server_names
           *.example.com example.* www.example.org/galleries/
           ~\.google\.;
if ($invalid_referer) {
    return 403;
}</code></pre><h2 id="Nginx作为代理服务器"><a href="#Nginx作为代理服务器" class="headerlink" title="Nginx作为代理服务器"></a>Nginx作为代理服务器</h2><h3 id="ngx-http-proxy-module模块"><a href="#ngx-http-proxy-module模块" class="headerlink" title="ngx_http_proxy_module模块"></a>ngx_http_proxy_module模块</h3><p>与代理相关的模块,nginx作为代理服务器时,支持多种协议,在面向客户端时,支持http,mail等协议；<br><strong>正向代理</strong>：代表的是客户端，去请求服务器，需要客户端配置，客户端请求的是真实服务器地址，但是通过代理服务器发出。类似于SNAT的作用，但是DNAT是工作在3、4层，而Nginx作为代理服务器是工作在应用层。<br><strong>反向服务器</strong>：代表的是服务器端，客户端无需配置，客户端访问的是代理服务器，由代理服务器去后端查找到资源并返回给客户端，而客户端对此无所感知。就像DNAT一样。</p>
<ul>
<li>proxy_pass URL;<br>可用于location，if in location,limit_except上下文<br>注意：proxy_pass后面的路径不带URI时，其会将location到的URI传递给后端主机；<br>proxy_pass后面的路径是一个URI时，其会将location到的URI替换为proxy_pass的URI。<br>示例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	...</span><br><span class="line">	server_name HOSTNAME;</span><br><span class="line">	location /uri/ &#123;</span><br><span class="line">		proxy_pass http://hos[:port];</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	...</span><br><span class="line">	server_name HOSTNAME;</span><br><span class="line">	location /uri/ &#123;</span><br><span class="line">		proxy_pass http://host/new_uri/;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如果location定义其URI时使用了正则表达式的模式，或在if语句或limit_except中使用proxy_pass指令，则proxy_pass之后必须不能使用URI；此时用户请求时传递的URI将直接附加在代理到服务之后</strong><br>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	...</span><br><span class="line">	server_name HOSTNAME;</span><br><span class="line">	location ~|~* /uri/ &#123;</span><br><span class="line">		proxy_pass http://host;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>proxy_set_header field value;<br>设定发往后端主机的请求报文的请求首部的值；<br>可配置在http,server,location上下文。</p>
<blockquote>
<p>proxy_set_header X-Real-IP  $remote_addr;<br>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>在代理服务器使用proxy_set_header X-Real-IP  $remote_addr;然后被代理服务器设置LogFormat时加上X-Real-IP变量就可以记录客户端的真实ip。<br>LogFormat “%{X-Real-IP}i %l %u %t &quot;%r&quot; %&gt;s %b” common</p>
</blockquote>
</li>
<li><p>proxy_cache_path;<br>定义可用于proxy功能的缓存，<br>只可配置在http上下文</p>
<blockquote>
<p>proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</p>
</blockquote>
</li>
<li><p>proxy_cache zone|off;<br>指明要调用的缓存，或关闭缓存机制；<br>可配置在server,location上下文</p>
</li>
<li><p>proxy_cache_key string;<br>缓存中用于”键”的内容<br>默认值为:<br>proxy_cache_key $csheme$proxy_host$request_uri;</p>
</li>
<li><p>proxy_cache_valid [code…] time;<br>定义对特定响应码的响应内容的缓存时长。可配置在http,server,location中。</p>
<blockquote>
<p>定义带http{…}中<br>proxy_cache_path /var/cache/nginx/proxy_cache levels=1:1:1 keys_zone=pxycache:20m max_size=1g;</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>定义在需要调用缓存功能的配置段，例如server{…};<br>proxy_cache pxycache;<br>proxy_cache_key $request_uri;<br>proxy_cache_valid 200 302 301 1h;<br>proxy_cache_valid any 1m;</p>
</blockquote>
<ul>
<li><p>proxy_cache_use_stale<br>proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off …;<br>Determines in which cases a stale cached response can be used when an error occurs during communication with the proxied server.<br>对哪些类型的过期的资源可以使用缓存应答，off为不是用过期缓存应答。</p>
</li>
<li><p>proxy_cache_methods GET | HEAD | POST …;<br>If the client request method is listed in this directive then the response will be cached. “GET” and “HEAD” methods are always added to the list, though it is recommended to specify them explicitly.</p>
</li>
<li><p>proxy_hide_header field;<br>By default, nginx does not pass the header fields “Date”, “Server”, “X-Pad”, and “X-Accel-…” from the response of a proxied server to a client. The proxy_hide_header directive sets additional fields that will not be passed.</p>
</li>
<li><p>proxy_connect_timeout time;<br>Defines a timeout for establishing a connection with a proxied server. It should be noted that this timeout cannot usually exceed 75 seconds.<br>默认60s，最长为75s；</p>
</li>
<li><p>proxy_read_timeout time;<br>Defines a timeout for reading a response from the proxied server. The timeout is set only between two successive read operations, not for the transmission of the whole response.</p>
</li>
<li><p>proxy_send_timeout time;<br>Sets a timeout for transmitting a request to the proxied server. he timeout is set only between two successive write operations, not for the transmission of the whole request. If the proxied server does not receive anything within this time, the connection is closed.</p>
</li>
</ul>
<p>nginx代理服务器配置示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/nginx/nginx.conf</span></span><br><span class="line">http &#123;</span><br><span class="line">proxy_cache_path /var/cache/nginx levels=1:1:2 keys_zone=webc</span><br><span class="line">ache:10m max_size=2G;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name www.msq.com;</span><br><span class="line">        root /ngxdata/html;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://172.17.0.2;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_cache webcache;</span><br><span class="line">            proxy_cache_key <span class="variable">$request_uri</span>;</span><br><span class="line">            proxy_cache_valid 200 302 301 1h;</span><br><span class="line">            proxy_cache_valid any 1m;</span><br><span class="line">            proxy_cache_methods GET HEAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nginx的缓存在负载均衡器意外宕机后，如果修复故障，则缓存依然有效。</p>
<h3 id="ngx-http-headers-module模块"><a href="#ngx-http-headers-module模块" class="headerlink" title="ngx_http_headers_module模块"></a>ngx_http_headers_module模块</h3><p>The ngx_http_headers_module module allows adding the “Expires” and “Cache-Control” header fields, and arbitrary fields, to a response header.<br>向由代理服务器响应给客户端的响应报文添加自定义首部，或修改指定首部的值。<br>可配置于http, server, location, if in location语句块</p>
<ul>
<li><p>add_header name value [always];<br>添加自定义首部</p>
<blockquote>
<p>add_header X-Via  $server_addr;<br>add_header X-Accel $server_name;</p>
</blockquote>
</li>
<li><p>expires [modified] time;<br>用于定义Expire或Cache-Control首部的值；<br>expires epoch | max | off;</p>
</li>
</ul>
<h3 id="ngx-http-fastcgi-module模块"><a href="#ngx-http-fastcgi-module模块" class="headerlink" title="ngx_http_fastcgi_module模块"></a>ngx_http_fastcgi_module模块</h3><p>fpm：fastcgi process manager fastcgi协议进程管理<br>The ngx_http_fastcgi_module module allows passing requests to a FastCGI server.此模块允许将请求转发给fastcgi服务器。</p>
<ul>
<li>fastcgi_pass address;<br>address为fastcgi server的地址:端口，但是不能加协议；可配置于location,if in location;</li>
<li>fastcgi_index name;<br>fastcgi默认的主页资源</li>
<li>fastcgi_param parameter value [if_not_empty];<br>Sets a parameter that should be passed to the FastCGI server. The value can contain text, variables, and their combination.</li>
</ul>
<p>配置示例1：(前提：配置好fpm server和mariadb-server服务；)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/nginx/nginx.conf</span></span><br><span class="line">location ~* \.php$ &#123;</span><br><span class="line">            fastcgi_pass 172.17.0.3:9000;</span><br><span class="line">            fastcgi_index php.index;</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME /appdata<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>web</tag>
        <tag>Nginx</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从级联、半同步复制和加密</title>
    <url>/2018/03/27/mysql%E5%8D%8A%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="Mysql主从级联复制"><a href="#Mysql主从级联复制" class="headerlink" title="Mysql主从级联复制"></a>Mysql主从级联复制</h3><p>配置主从级联复制时，作为中间节点的那个服务器需要额外做如下配置，以确保从服务器从主服务器哪里复制来的数据能记录二进制日志。<br>[mysqld]<br>log_bin<br>log_slave_updates</p>
<p>余下的从服务器需要指定该中间节点为主服务器。</p>
<h3 id="复制架构中应该注意的问题"><a href="#复制架构中应该注意的问题" class="headerlink" title="复制架构中应该注意的问题"></a>复制架构中应该注意的问题</h3><p><strong>限制从服务器为只读</strong></p>
<ul>
<li>在从服务器上设置read-only=ON<br>注意：此限制对拥有super权限的用户均无效。</li>
<li>阻止所有用户，包括主服务器复制的更新<br>mysql&gt; flush tables with read lock;</li>
</ul>
<p><strong>RESET SLAVE</strong><br>在从服务器清除master.info，relay-log.info,relay log,开始新的relaylog，注意，需要先stop slave;<br>reset slave all 清除所有从服务器上设置的主服务器同步信息如：port,host,user,password等</p>
<p><strong>sql_slave_skip_counter=N</strong><br>从服务器忽略几个主服务器的复制时间，global变量。</p>
<p><strong>如何保证主从复制的事务安全</strong><br>在master节点启用参数</p>
<ul>
<li>sync_binlog=1 每次写后立即同步二进制日知道磁盘，性能差<br>如果用到的是innodb存储引擎</li>
<li>innodb_fush_log_at_trx_commit=1 每次事务提交立即同步日志写磁盘</li>
<li>innodb_support_xa=ON 默认值，分布式事务mariadb10.3.0废除</li>
<li>sync_master_info=# #次事件后master.info同步到磁盘</li>
</ul>
<p>在slave节点启用服务器选项</p>
<ul>
<li>skip_slave_start=ON 不自动启动slave</li>
</ul>
<p>在slave节点启用参数</p>
<ul>
<li>sync_relay_log=# #次写后同步relay log到磁盘</li>
<li>sync_relay_log_info=# #次事务后同步relay-log.info到磁盘</li>
</ul>
<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>默认情况下，MySQL的复制功能是异步的，异步复制可以提供最佳的性能，主<br>库把binlog日志发送给从库即结束，并不验证从库是否接收完毕。这意味着当<br>主服务器或从服务器端发生故障时，有可能从服务器没有接收到主服务器发送<br>过来的binlog日志，这就会造成主服务器和从服务器的数据不一致，甚至在恢<br>复时造成数据的丢失</p>
<h4 id="半同步复制的实现"><a href="#半同步复制的实现" class="headerlink" title="半同步复制的实现"></a>半同步复制的实现</h4><p>主服务器配置:<br>mysql&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME ‘semisync_master.so’; #安装插件<br>mysql&gt;SET GLOBAL rpl_semi_sync_master_enabled=1; #启用插件<br>mysql&gt;SET GLOBAL rpl_semi_sync_master_timeout = 1000;超时长为1s<br>mysql&gt;SHOW GLOBAL VARIABLES LIKE ‘%semi%’;<br>mysql&gt;SHOW GLOBAL STATUS LIKE ‘%semi%‘;</p>
<p>从服务器配置:<br>mysql&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME ‘semisync_slave.so’;<br>mysql&gt; SET GLOBAL rpl_semi_sync_slave_enabled=1;</p>
<p>如果要永久使用半同步复制功能，需要将启用插件写入配置文件<br>主服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/my.cnf.d/server.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">rpl_semi_sync_master_enabled</span><br></pre></td></tr></table></figure>
<p>从服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/my.cnf.d/server.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">rpl_semi_sync_slave_enabled</span><br></pre></td></tr></table></figure>

<p>配置好主从服务器后，需要重启从服务器的线程</p>
<ul>
<li>stop slave </li>
<li>start slave</li>
</ul>
<h3 id="复制过滤器"><a href="#复制过滤器" class="headerlink" title="复制过滤器"></a>复制过滤器</h3><p>让从节点仅复制指定的数据库，或指定数据库的指定表。<br>实现方式有两种：<br><strong>第一种实现方式</strong><br>服务器选项：主服务器仅向二进制日志中记录与特定数据库相关的事件<br>注意：此项和binlog_format相关<br>参看：<a href="https://mariadb.com/kb/en/library/mysqld-options/#-binlogignore-db" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/mysqld-options/#-binlogignore-db</a></p>
<ul>
<li>binlog_do_db = 数据库白名单列表，多个数据库需多行实现</li>
<li>binlog_ignore_db = 数据库黑名单列表<br>问题：基于二进制还原将无法实现；不建议使用</li>
</ul>
<p><strong>第二种是实现方式</strong><br>从服务器SQL_THREAD在replay中继日志中的事件时，仅读取与特定数<br>据库(特定表)相关的事件并应用于本地<br>问题：会造成网络及磁盘IO浪费<br>从服务器上的复制过滤器相关变量</p>
<ul>
<li>replicate_do_db= 指定复制库的白名单</li>
<li>replicate_ignore_db= 指定复制库黑名单</li>
<li>replicate_do_table= 指定复制表的白名单</li>
<li>replicate_ignore_table= 指定复制表的黑名单</li>
<li>replicate_wild_do_table= foo%.bar% 支持通配符</li>
<li>replicate_wild_ignore_table=</li>
</ul>
<p>写入配置文件永久生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/my.cnf.d/server.cnf</span></span><br><span class="line">replicate_do_db=db1</span><br><span class="line">replicate_do_db=db2</span><br><span class="line">replicate_do_db=db3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Mysql复制加密"><a href="#Mysql复制加密" class="headerlink" title="Mysql复制加密"></a>Mysql复制加密</h3><p>基于SSL复制：<br>在默认的主从复制过程或远程连接到MySQL/MariaDB所有的链接通信中的数据都是明文的，外网里访问数据或则复制，存在安全隐患。通过SSL/TLS加密的方式进行复制的方法，来进一步提高数据的安全性<br>配置实现：<br>参看：<a href="https://mariadb.com/kb/en/library/replication-with-secureconnections/" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/replication-with-secureconnections/</a></p>
<ul>
<li>主服务器开启SSL：[mysqld] 加一行ssl</li>
<li>主服务器配置证书和私钥；并且创建一个要求必须使用SSL连接的复制账号</li>
<li>从服务器使用CHANGER MASTER TO 命令时指明ssl相关选项</li>
</ul>
<p>主服务器配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#vi /etc/my.cnf.d/server.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span>-bin</span><br><span class="line">server_id=1</span><br><span class="line">ssl</span><br><span class="line">ssl-ca=/etc/my.cnf.d/ssl/cacert.pem</span><br><span class="line">ssl-cert=/etc/my.cnf.d/ssl/master.crt</span><br><span class="line">ssl-key=/etc/my.cnf.d/ssl/master.key</span><br></pre></td></tr></table></figure>

<p>从服务器配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt;</span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST=<span class="string">'MASTERIP'</span>,</span><br><span class="line">MASTER_USER=<span class="string">'rep'</span>,</span><br><span class="line">MASTER_PASSWORD=<span class="string">'centos'</span>,</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mariadb-bin.000001'</span>,</span><br><span class="line">MASTER_LOG_POS=<span class="number">245</span>,</span><br><span class="line">MASTER_SSL=<span class="number">1</span>,</span><br><span class="line">MASTER_SSL_CA = <span class="string">'/etc/my.cnf.d/ssl/cacert.pem'</span>,</span><br><span class="line">MASTER_SSL_CERT = <span class="string">'/etc/my.cnf.d/ssl/slave.crt'</span>,</span><br><span class="line">MASTER_SSL_KEY = <span class="string">'/etc/my.cnf.d/ssl/slave.key'</span>;</span><br></pre></td></tr></table></figure>

<p>证书申请过程<br>(umask 066;openssl genrsa 2048 &gt; cakey.pem)<br>openssl req -new -x509 -key cakey.pem -out cacert.pem -days 3650<br>openssl req -newkey rsa:2048 -days 365 -nodes -keyout master.key &gt; master.csr<br>openssl req -newkey rsa:2048 -days 365 -nodes -keyout slave.key &gt; slave.csr<br>openssl x509 -req -in master.csr  -CA cacert.pem -CAkey cakey.pem -set_serial 01 &gt; master.crt<br>openssl x509 -in master.crt -noout -text<br>openssl x509 -req -in slave.csr  -CA cacert.pem -CAkey cakey.pem -set_serial 02 &gt; slave.crt</p>
<h3 id="复制的监控和维护"><a href="#复制的监控和维护" class="headerlink" title="复制的监控和维护"></a>复制的监控和维护</h3>]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>主从级联</tag>
        <tag>半同步</tag>
        <tag>Mysql加密</tag>
      </tags>
  </entry>
  <entry>
    <title>LAMP搭建</title>
    <url>/2018/03/20/lamp/</url>
    <content><![CDATA[<p>实现lamp框架有两种方案，一是将php作为Apache的一个模块使用，另一个是将php作为一个单独的守护进程，请求静态资源时，由Apache提供服务，请求动态资源时，由Apache通过fastcgi转发给php处理。这两种方式在centos7默认都支持，在不能同时使用，只能使用其中一种方式。</p>
<h2 id="使用yum安装的方式搭建lamp"><a href="#使用yum安装的方式搭建lamp" class="headerlink" title="使用yum安装的方式搭建lamp"></a>使用yum安装的方式搭建lamp</h2><h3 id="使用php模块化方式搭建lamp"><a href="#使用php模块化方式搭建lamp" class="headerlink" title="使用php模块化方式搭建lamp"></a>使用php模块化方式搭建lamp</h3><h4 id="安装php-mariadb-httpd"><a href="#安装php-mariadb-httpd" class="headerlink" title="安装php,mariadb,httpd"></a>安装php,mariadb,httpd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install php mariadb httpd</span><br></pre></td></tr></table></figure>
<p><strong>php安装包携带文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache conf.d]<span class="comment">#rpm -ql php</span></span><br><span class="line">/etc/httpd/conf.d/php.conf <span class="comment">#php模块配置文件</span></span><br><span class="line">/etc/httpd/conf.modules.d/10-php.conf <span class="comment">#配置加载php模块</span></span><br><span class="line">/usr/lib64/httpd/modules/libphp5.so <span class="comment">#php模块存放位置</span></span><br><span class="line">/usr/share/httpd/icons/php.gif <span class="comment">#php图标存放位置</span></span><br><span class="line">/var/lib/php/session</span><br></pre></td></tr></table></figure>
<p><strong>配置php模块</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache conf.d]<span class="comment">#egrep -v "^#|^$" /etc/httpd/conf.d/php.conf  </span></span><br><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">    SetHandler application/x-httpd-php <span class="comment">#将以.php结尾的请求转发给x-httpd-php处理</span></span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">AddType text/html .php <span class="comment">#增加php文件的匹配</span></span><br><span class="line">DirectoryIndex index.php <span class="comment">#配置默认主页，可重复使用</span></span><br><span class="line">php_value session.save_handler <span class="string">"files"</span> <span class="comment">#配置php保存会话</span></span><br><span class="line">php_value session.save_path    <span class="string">"/var/lib/php/session"</span> <span class="comment">#会话保存路径</span></span><br></pre></td></tr></table></figure>
<p><strong>php模块加载文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache conf.d]<span class="comment">#grep -v "^#" ../conf.modules.d/10-php.conf </span></span><br><span class="line">&lt;IfModule prefork.c&gt; <span class="comment">#当httpd运行在prefork模式下时才启用php模块</span></span><br><span class="line">  LoadModule php5_module modules/libphp5.so</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p><strong>重启httpd后就可以使用php模块了</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache conf.d]<span class="comment">#systemctl restart httpd</span></span><br></pre></td></tr></table></figure>
<p><strong>生成php测试文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache conf.d]<span class="comment">#cat /var/www/html/index.php</span></span><br><span class="line">&lt;?php</span><br><span class="line">	phpinfo() <span class="comment">#可以查看php的环境信息</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>此时，在浏览器访问该服务器，就可以看到php信息，说明php模块已经正常工作。<br><strong>安装php-mysql模块，以使php和mysql可以建立连接</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install php-mysql</span><br></pre></td></tr></table></figure>
<p><strong>生成php-mysql连接测试文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache html]<span class="comment">#cat conn.php </span></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$conn</span> = mysql_connect(<span class="string">'192.168.34.102'</span>,<span class="string">'test'</span>,<span class="string">'centos'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Failure"</span>;</span><br><span class="line"><span class="comment">#echo mysql_error();</span></span><br><span class="line">mysql_close();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>此时在浏览器中访问该文件，如果出现OK，则表明php已经可以和mariadb正常连接。</p>
<h2 id="lamp结合第三方工具的应用"><a href="#lamp结合第三方工具的应用" class="headerlink" title="lamp结合第三方工具的应用"></a>lamp结合第三方工具的应用</h2><h3 id="lamp-wordpress搭建个人站点"><a href="#lamp-wordpress搭建个人站点" class="headerlink" title="lamp+wordpress搭建个人站点"></a>lamp+wordpress搭建个人站点</h3><p>本次实验以/data/blog/目录为站点根目录进行;以A(192.168.34.108)作为lap主机，以(192.168.34.102)作为数据库服务器。<br><strong>下载WordPress</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://wordpress.org/latest.tar.gz</span><br></pre></td></tr></table></figure>
<p><strong>解压文件并将解压后的文件夹放入httpd指定的站点主目录下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar xf latest.tar.gz</span><br></pre></td></tr></table></figure>
<p><strong>在B服务器创建专用数据库，并授权专有用户进行管理</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; create database wpdb;</span><br><span class="line">MariaDB [(none)]&gt; grant all on wpdb.* to 'wpuser'@'192.168.34.%' identified by 'centos';</span><br></pre></td></tr></table></figure>
<p><strong>编辑WordPress配置文件指向数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache htdocs]<span class="comment">#vi wp-config.php</span></span><br><span class="line">define(<span class="string">'DB_NAME'</span>, <span class="string">'wpdb'</span>);</span><br><span class="line">define(<span class="string">'DB_USER'</span>, <span class="string">'wpuser'</span>);</span><br><span class="line">define(<span class="string">'DB_PASSWORD'</span>, <span class="string">'centos'</span>);</span><br><span class="line">define(<span class="string">'DB_HOST'</span>, <span class="string">'192.168.34.102'</span>);</span><br></pre></td></tr></table></figure>
<p>之后按步骤创建站点，就可以拥有自己的个人网站了。</p>
<h3 id="php-fpm模式搭建web应用"><a href="#php-fpm模式搭建web应用" class="headerlink" title="php-fpm模式搭建web应用"></a>php-fpm模式搭建web应用</h3><h4 id="安装php-fpm、mariadb-server、httpd"><a href="#安装php-fpm、mariadb-server、httpd" class="headerlink" title="安装php-fpm、mariadb-server、httpd"></a>安装php-fpm、mariadb-server、httpd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install php-fpm mariadb-server httpd</span><br></pre></td></tr></table></figure>
<p><strong>php-fpm相关配置文件</strong><br>/etc/php-fpm.conf<br>/etc/php-fpm.d/* .conf</p>
<h4 id="配置php"><a href="#配置php" class="headerlink" title="配置php"></a>配置php</h4><p>修改php-fpm配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ~]<span class="comment">#vi /etc/php-fpm.d/www.conf</span></span><br><span class="line">listen = 127.0.0.1:9000 <span class="comment">#监听主机的哪个网卡的9000端口，可按需修改</span></span><br><span class="line">listen.allowed_clients = 127.0.0.1 <span class="comment">#允许哪些主机进行访问，默认只允许本机访问，可按处修改，可修改为网段，如172.18.0.0/16或0.0.0.0</span></span><br><span class="line">user = apache <span class="comment">#程序运行的用户</span></span><br><span class="line">group = apache <span class="comment">#程序运行的用户组</span></span><br><span class="line">pm = dynamic <span class="comment">#程序以什么方式运行，dynamic表示以动态方式运行；static表示以静态方式运行</span></span><br><span class="line">pm.max_children = 50 <span class="comment">#最大子进程数</span></span><br><span class="line">pm.start_servers = 5 <span class="comment">#初始生成的子进程数</span></span><br><span class="line">pm.min_spare_servers = 5 <span class="comment">#最小空闲进程 仅dynamic模式有效</span></span><br><span class="line">pm.max_spare_serevrs = 35 <span class="comment">#最大空闲进程树 仅dynamic模式有效</span></span><br><span class="line">pm.max_requwsts = 500 <span class="comment">#每个子进程最大服务的请求书，在此数值到达时，该子进程将关闭</span></span><br><span class="line">ping.path = /ping <span class="comment">#存活性探测</span></span><br><span class="line">ping.response = pong <span class="comment">#存活性探测时期望得到的恢复</span></span><br><span class="line">php_admin_value[error_log] = /var/<span class="built_in">log</span>/php-fpm/www-error.log <span class="comment">#错误日志存放位置</span></span><br><span class="line">php_value[session.save_handler] = files <span class="comment">#php会话管理方式</span></span><br><span class="line">php_value[session.save_path] = /var/lib/php/session <span class="comment">#php会话存放目录，默认没有需手动创建</span></span><br></pre></td></tr></table></figure>

<p>创建php会话存放目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ~]<span class="comment">#mkdir /var/lib/php/session</span></span><br><span class="line">[root@apache ~]<span class="comment">#chown apache.apache /var/lib/php/session/</span></span><br></pre></td></tr></table></figure>

<p>启动php服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ~]<span class="comment">#systemctl start php-fpm.service</span></span><br></pre></td></tr></table></figure>
<h4 id="配置apache"><a href="#配置apache" class="headerlink" title="配置apache"></a>配置apache</h4><p>这里以虚拟主机的方式配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache /data/blog/htdocs]<span class="comment">#vi /etc/httpd/conf.d/blog.conf</span></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        DocumentRoot <span class="string">"/data/blog/htdocs"</span></span><br><span class="line">        ServerName blog.msq.com</span><br><span class="line">        DirectoryIndex index.php                                 </span><br><span class="line">        ProxyRequests off</span><br><span class="line">        ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/data/blog/htdocs/<span class="variable">$1</span></span><br><span class="line">        &lt;Directory <span class="string">"/data/blog/htdocs"</span>&gt;</span><br><span class="line">                Options followsymlinks</span><br><span class="line">                AllowOverride none</span><br><span class="line">                require all granted</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>此时，以fastcgi方式运行的lamp架构已经搭建完成</p>
<h4 id="phpMyadmin使用"><a href="#phpMyadmin使用" class="headerlink" title="phpMyadmin使用"></a>phpMyadmin使用</h4><p>下载phpMyadmin并解压到站点主目录下。<br>配置phpMyadmin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache htdocs]<span class="comment">#cp config.sample.inc.php config.inc.php</span></span><br><span class="line"><span class="variable">$cfg</span>[<span class="string">'blowfish_secret'</span>] = <span class="string">'a8bsajcnsjkdbc7c6d'</span>; <span class="comment">#将此行的随机数换一个，不要使用默认的，其余的设置可保持不变</span></span><br></pre></td></tr></table></figure>
<p>安装php-mbstring,php-mysql模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache htdocs]<span class="comment">#yum -y install php-mbstring php-mysql</span></span><br></pre></td></tr></table></figure>

<h2 id="使用编译安装的方式搭建lamp架构"><a href="#使用编译安装的方式搭建lamp架构" class="headerlink" title="使用编译安装的方式搭建lamp架构"></a>使用编译安装的方式搭建lamp架构</h2><h3 id="编译安装httpd"><a href="#编译安装httpd" class="headerlink" title="编译安装httpd"></a>编译安装httpd</h3><p><strong>安装相关包组</strong><br>Development Tools #开发相关包组<br>Server Platform Development #老版本需要安装，7.5已经集成到Development Tools中<br>pcre-devel #purl扩展的正则表达式<br>apr-devel #apache portable runtime Apache的可移植环境<br>apr-util-devel #apr工具<br>openssl-devel #实现http加密</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache htdocs]<span class="comment">#yum -y install  pcre-devel apr-devel apr-util-devel openssl-devel</span></span><br><span class="line">[root@apache htdocs]<span class="comment">#yum groupinstall "development tools"</span></span><br></pre></td></tr></table></figure>
<p><strong>开始安装httpd,请自行下载如下所示相关软件包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache tools]<span class="comment">#ls</span></span><br><span class="line">apr-1.5.0              httpd-2.4.37</span><br><span class="line">apr-1.5.0.tar.bz2      httpd-2.4.37.tar.bz2</span><br><span class="line">apr-util-1.6.1         phpMyAdmin-4.0.10.20-all-languages.tar.gz</span><br><span class="line">apr-util-1.6.1.tar.gz  phpMyAdmin-4.7.1-all-languages.zip</span><br><span class="line">[root@apache tools]<span class="comment">#mv apr-1.5.0 httpd-2.4.37/srclib/apr</span></span><br><span class="line">[root@apache tools]<span class="comment">#mv apr-util-1.6.1 httpd-2.4.37/srclib/apr-util</span></span><br><span class="line">[root@apache tools]<span class="comment">#cd httpd-2.4.37/</span></span><br><span class="line">[root@apache httpd-2.4.37]<span class="comment"># ./configure --prefix=/app/httpd24 \ #指定默认安装目录</span></span><br><span class="line">--<span class="built_in">enable</span>-so \ <span class="comment">#启用模块功能</span></span><br><span class="line">--<span class="built_in">enable</span>-ssl \</span><br><span class="line">--<span class="built_in">enable</span>-cgi \</span><br><span class="line">--<span class="built_in">enable</span>-rewrite \</span><br><span class="line">--with-zlib \ <span class="comment">#结合zlib库，在传输过程中压缩</span></span><br><span class="line">--with-pcre \</span><br><span class="line">--<span class="built_in">enable</span>-modules=most \</span><br><span class="line">--<span class="built_in">enable</span>-mpms-shared=all \ <span class="comment">#把所有的mpm编译进来</span></span><br><span class="line">--with-mpm=prefork \ <span class="comment">#默认启用prefork</span></span><br><span class="line">--with-included-apr</span><br><span class="line">$ make <span class="comment">#make是一个项目管理工具，解决项目件的依赖关系。gcc是编译器</span></span><br><span class="line"><span class="variable">$make</span> install</span><br></pre></td></tr></table></figure>
<p><strong>如果想开启本地帮助页面需要修改配置文件,打开以下两项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /app/httpd/conf/httpd.conf </span><br><span class="line">Include conf/extra/httpd-manual.conf</span><br><span class="line">LoadModule negotiation_module modules/mod_negotiation.so</span><br></pre></td></tr></table></figure>

<h3 id="编译安装php-php-7-1-7"><a href="#编译安装php-php-7-1-7" class="headerlink" title="编译安装php(php-7.1.7)"></a>编译安装php(php-7.1.7)</h3><p><strong>安装相关依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache php-7.1.18]<span class="comment">#yum install libxml2-devel bzip2-devel libmcrypt-devel</span></span><br></pre></td></tr></table></figure>
<p>到官方站点下载php源码包之后解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar tar xf php-7.1.18.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> php-7.1.18</span><br></pre></td></tr></table></figure>
<p><strong>编译安装php</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/app/php \ <span class="comment">#安装目录</span></span><br><span class="line">--<span class="built_in">enable</span>-mysqlnd \ <span class="comment">#启用MySQL</span></span><br><span class="line">--with-mysqli=mysqlnd \ <span class="comment">#连接mysql的方式</span></span><br><span class="line">--with-openssl \ <span class="comment">#开启openssl加密</span></span><br><span class="line">--with-pdo-mysql=mysqlnd \ <span class="comment">#</span></span><br><span class="line">--<span class="built_in">enable</span>-mbstring \ <span class="comment">#支持中文字符集</span></span><br><span class="line">--withfreetype-dir \ <span class="comment">#字体相关库</span></span><br><span class="line">--with-jpeg-dir \ <span class="comment">#图形相关库</span></span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \ <span class="comment">#压缩和解压缩相关库</span></span><br><span class="line">--with-libxmldir=/usr \ <span class="comment">#</span></span><br><span class="line">--<span class="built_in">enable</span>-xml \</span><br><span class="line">--<span class="built_in">enable</span>-sockets \</span><br><span class="line">--withapxs2=/app/httpd24/bin/apxs \ <span class="comment">#使用该扩展编译httpd</span></span><br><span class="line">--with-config-file-path=/etc \</span><br><span class="line">--withconfig-file-scan-dir=/etc/php.d \</span><br><span class="line">--<span class="built_in">enable</span>-maintainer-zts \ <span class="comment">#如果mpm为prefork不能启用该选项，如果是worker或event则必须启用该选项</span></span><br><span class="line">--<span class="built_in">disable</span>-fileinfo <span class="comment">#禁止显示file信息</span></span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>注意：php-7.0以上版本使用–enable-mysqlnd –with-mysqli=mysqlnd ，<br>原–with-mysql不再支持</p>
<p><strong>配置php</strong><br>编译安装php后，默认不生成配置文件，需要手动copy一个配置文件到指定位置(/etc)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache php-7.1.18]<span class="comment">#cp php.ini-production /etc/php.ini</span></span><br></pre></td></tr></table></figure>
<p>修改httpd配置文件使其支持php,需更改如下三项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /app/httpd/conf/httpd.conf </span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line">AddType application/x-httpd-php-source .phps</span><br><span class="line">为DirectoryIndex index.php index.html</span><br></pre></td></tr></table></figure>
<p>此时httpd和php已经可以正常工作。</p>
<p>生成如下测试文件,在浏览器输入服务器地址，如果出现php信息页面内，说明安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache httpd]<span class="comment">#cat /app/httpd/htdocs/index.php </span></span><br><span class="line">&lt;?php</span><br><span class="line">	phpinfo()</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编译安装mariadb"><a href="#编译安装mariadb" class="headerlink" title="编译安装mariadb"></a>编译安装mariadb</h3><p><strong>先安装mariadb的相关依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#yum install bison bison-devel zlib-devel libcurl-devel libarchive-devel boostdeve</span></span><br></pre></td></tr></table></figure>

<p><strong>创建相关用户和数据目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#uaeradd -r -s /sbin/nologin -d /data/mysql mysql</span></span><br><span class="line">[root@ansible ~]<span class="comment">#mkdir /data/mysql</span></span><br><span class="line">[root@ansible ~]<span class="comment">#chown mysql.mysql /data/mysql</span></span><br></pre></td></tr></table></figure>


<p><strong>到官方网站下载mariadb源码包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#wget -p tools/ https://downloads.mariadb.org/interstitial/mariadb-10.3.11/source/mariadb-10.3.11.tar.gz/from/http%3A//mirrors.neusoft.edu.cn/mariadb/mariadb-10.2.19.tar.gz</span></span><br></pre></td></tr></table></figure>

<p><strong>解压源码包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cd tools/</span></span><br><span class="line">[root@ansible ~]<span class="comment">#tar xf mariadb-10.2.19.tar.gz</span></span><br><span class="line">[root@ansible ~]<span class="comment">#cd mariadb-10.2.19</span></span><br></pre></td></tr></table></figure>

<p><strong>执行编译安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mriadb-10.2.19]<span class="comment">#cmake . \</span></span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/app/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/data/mysql/ \</span><br><span class="line">-DSYSCONFDIR=/etc \</span><br><span class="line">-DMYSQL_USER=mysql \</span><br><span class="line">-DWITH_INNOBASE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_ARCHIVE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_PARTITION_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITHOUT_MROONGA_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_DEBUG=0 \</span><br><span class="line">-DWITH_READLINE=1 \</span><br><span class="line">-DWITH_SSL=system \</span><br><span class="line">-DWITH_ZLIB=system \</span><br><span class="line">-DWITH_LIBWRAP=0 \</span><br><span class="line">-DENABLED_LOCAL_INFILE=1 \</span><br><span class="line">-DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mriadb-10.2.19]<span class="comment">#make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p><strong>准备环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'PATH=/app/mysql/bin:$PATH'</span> &gt; /etc/profile.d/mysql.sh</span><br></pre></td></tr></table></figure>

<p><strong>生成数据库文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cd /app/mysql</span></span><br><span class="line">[root@ansible mysql]<span class="comment">#./scripts/mysql_install_db --datadir=/data/mysql/ --user=mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>准备配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#cp /app/mysql/support-files/my-huge.cnf /etc/my.cnf</span></span><br></pre></td></tr></table></figure>

<p><strong>准备启动脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#cp /app/mysql/support-files/mysql.server /etc/init.d/mysqld</span></span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#chkconfig --add mysqld ;service mysqld start</span></span><br></pre></td></tr></table></figure>
<p>此时，mariadb编译安装已经完成。</p>
<p><strong>生成php-mysql连接测试文件并测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /app/httpd/htdocs/conn.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$mysql</span> = new mysqli();</span><br><span class="line"><span class="variable">$mysql</span>-&gt;connect(<span class="string">'192.168.34.102'</span>,<span class="string">'root'</span>,<span class="string">'centos'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$mysql</span>)&#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"连接成功了!"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"连接挂掉了"</span>;</span><br><span class="line">&#125;</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器输入服务器ip/conn.php即可测试。</p>
<h3 id="以fpm的方式编译安装php"><a href="#以fpm的方式编译安装php" class="headerlink" title="以fpm的方式编译安装php"></a>以fpm的方式编译安装php</h3><p>使用fpm编译安装pph时，需要加上–enable-fpm选项，并去掉–enable-maintainer-zts和–with-apxs2=/app/httpd24/bin/apxs。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache tools]<span class="comment">#tar xf php-7.1.18.tar.bz2 </span></span><br><span class="line">[root@apache tools]<span class="comment">#cd php-7.1.18/</span></span><br><span class="line">[root@apache php-7.1.18]<span class="comment">#./configure --prefix=/app/php-fpm-7.1.18 \</span></span><br><span class="line">--<span class="built_in">enable</span>-mysqlnd \</span><br><span class="line">--with-mysqli=mysqlnd \</span><br><span class="line">--with-openssl \</span><br><span class="line">--with-pdo-mysql=mysqlnd \</span><br><span class="line">--<span class="built_in">enable</span>-mbstring \</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--with-jpeg-dir \</span><br><span class="line">--with-png-dir \</span><br><span class="line">--with-zlib \</span><br><span class="line">--with-libxml-dir=/usr \</span><br><span class="line">--<span class="built_in">enable</span>-xml \</span><br><span class="line">--<span class="built_in">enable</span>-sockets \</span><br><span class="line">--<span class="built_in">enable</span>-fpm \</span><br><span class="line">--with-config-file-path=/etc \</span><br><span class="line">--with-config-file-scan-dir=/etc/php.d \</span><br><span class="line">--<span class="built_in">enable</span>-maintainer-zts \</span><br><span class="line">--<span class="built_in">disable</span>-fileinfo</span><br></pre></td></tr></table></figure>
<p>配置php-fpm(注意：以下路径php代表php的安装路径，php-7.1.18代表php源码包解压后的路径)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache php]<span class="comment">#cd /app/php/etc/</span></span><br><span class="line">[root@apache etc]<span class="comment">#cp php-fpm.conf&#123;.default,&#125;</span></span><br><span class="line">[root@apache etc]<span class="comment">#vi php-fpm.conf </span></span><br><span class="line">pid = run/php-fpm.pid</span><br><span class="line">error_log = <span class="built_in">log</span>/php-fpm.log</span><br><span class="line">[root@apache php]<span class="comment">#cp /root/tools/php-7.1.18/php.ini-production /etc/php.ini</span></span><br><span class="line">[root@apache php-7.1.18]<span class="comment">#cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm</span></span><br><span class="line">[root@apache php-7.1.18]<span class="comment">#cp sapi/fpm/php-fpm.service /usr/lib/systemd/system/</span></span><br></pre></td></tr></table></figure>
<p>采用php-fpm方式结合httpd时，httpd的配置有一定变化，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /app/httpd/conf/httpd.conf </span><br><span class="line">LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so</span><br><span class="line">LoadModule proxy_http_module modules/mod_proxy_http.so</span><br><span class="line">LoadModule proxy_module modules/mod_proxy.so </span><br><span class="line">ProxyRequests off</span><br><span class="line">ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/app/httpd/htdocs/<span class="variable">$1</span> </span><br><span class="line">&lt;IfModule dir_module&gt;</span><br><span class="line"> DirectoryIndex index.php index.html</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line">AddType application/x-httpd-php-source .phps</span><br></pre></td></tr></table></figure>

<h4 id="对编译安装的php使用xcache加速-php7不可用"><a href="#对编译安装的php使用xcache加速-php7不可用" class="headerlink" title="对编译安装的php使用xcache加速,php7不可用"></a>对编译安装的php使用xcache加速,php7不可用</h4><p>到官方网站下载xcache源码包，之后解压进入该目录，以上面安装的php-fpm为例演示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache xcache-3.2.0]<span class="comment">#/app/php/bin/phpize</span></span><br><span class="line">[root@apache xcache-3.2.0]<span class="comment">#./configure --enable-xcache --with-php-config=/app/php/bin/php-config</span></span><br><span class="line">[root@apache xcache-3.2.0]<span class="comment">#make &amp;&amp; make install</span></span><br><span class="line">[root@apache xcache-3.2.0]<span class="comment">#cp xcache.ini /app/php/php.d/</span></span><br><span class="line">[root@apache xcache-3.2.0]<span class="comment">#vi /app/php/php.d/xcache.ini</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>lamp</tag>
        <tag>web框架</tag>
      </tags>
  </entry>
  <entry>
    <title>使用loganalyzer展示数据库中的日志</title>
    <url>/2018/03/16/loganalyze/</url>
    <content><![CDATA[<p>rsyslog可以通过im模块将自己设置成rsyslog服务器，接收客户端发来的日志，也可以通过om模块将日志存储到mysql server等服务器，而loganalyzer则可以提供直观的展示日志方案，通过php提供的绘图模块还可以输出各种柱状图，条形图等展示方案。</p>
<h2 id="实现loganalyzer"><a href="#实现loganalyzer" class="headerlink" title="实现loganalyzer"></a>实现loganalyzer</h2><p>首先搭载好lamp架构，httpd的根目录位置为/data/vhost/htdocs,在此基础上进行如下实验<br><strong>下载loganalyzer</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache htdocs]<span class="comment">#wget http://download.adiscon.com/loganalyzer/loganalyzer-4.1.7.tar.gz</span></span><br><span class="line">[root@apache htdocs]<span class="comment">#tar xf loganalyzer-4.1.7.tar.gz</span></span><br><span class="line">[root@apache htdocs]<span class="comment">#cd loganalyzer</span></span><br></pre></td></tr></table></figure>
<p><strong>将loganalyzer目录下的src文件夹拷贝到httpd站点主目录下，我这里的主站点目录为/data/blog/htdocs</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp -r src/ /data/vhost</span><br><span class="line">$ ln -s src/ htdocs</span><br></pre></td></tr></table></figure>
<p><strong>创建配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /data/vhost/htdocs</span><br><span class="line">$ touch config.php</span><br><span class="line">$ chmod 666 config.php</span><br></pre></td></tr></table></figure>
<p>在浏览器访问该主页，按步骤配置完成后就可以使用loganalyzer。<br>安装php-gd模块还可以图形化显示各项信息。</p>
]]></content>
      <tags>
        <tag>loganalyzer</tag>
        <tag>日志管理</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议和apache入门</title>
    <url>/2018/03/06/http%E6%9C%8D%E5%8A%A1%E5%92%8Capache/</url>
    <content><![CDATA[<h2 id="http协议概览"><a href="#http协议概览" class="headerlink" title="http协议概览"></a>http协议概览</h2><p>htpp(Hyper Text Transfer Protocol,80/tcp)协议工作在应用层，基于tcp/ip协议。</p>
<h3 id="http协议个版本介绍"><a href="#http协议个版本介绍" class="headerlink" title="http协议个版本介绍"></a>http协议个版本介绍</h3><ul>
<li><p>http/0.9:1991，原型版本，功能简陋，只有一个命令GET。GET /index.html，服务器只能回应HTML格式字符串，不能回应别的格式</p>
</li>
<li><p>http/1.0：1996年5月，支持cache，MIME,method</p>
<blockquote>
<p>每个TCP链接只能发送一个请求，发送数据完毕，链接就关闭，如果还要请求其他资源，就必须再建立一个连接<br>  引入了POST命令和HEAD命令<br>  头信息是ASCII码，后面的数据可为任何格式，服务器回应是会告诉客户端，数据是什么格式，即Content-Type字段的作用。这些数据类型总称为MIME即多用途互联网邮件扩展，每个值包括一级类型和二级类型，预定义类型，也可以自定义类型，常见Content-Type值：text/xml image/jpeg audio/mp3</p>
</blockquote>
</li>
<li><p>http/1.1：1997年1月，http/1.1效率不高</p>
<blockquote>
<p>引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求服用，不用声明Connection:keep-alive。对于同一个域名，大多数浏览器允许同时建立6个持久连接<br>  引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率<br>  新增方法：PUT、PATCH、OPTIONS、DELETE<br>  同一个TCP连接里，所有的数据通信是按次序进行的。服务器只能顺序处理回应，前面的回应慢，会有许多请求排队，造成”队头堵塞”（Head-of-line blocking）<br>  为避免上述问题，两种方法：一是减少请求数，二是同时多开持久连接。网页优化技巧，如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等<br>  HTTP 协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度</p>
</blockquote>
</li>
<li><p>http/2.0:2015年</p>
<blockquote>
<p>头信息和数据体都是二进制，称为头信息和数据帧<br>  复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免你了”对头堵塞”，此双向的实时通信同为多工(Multiplexing)<br>  引入头信息压缩机制(header compression)，头信息使用gzip或compress压缩后再发送，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送字段，只发送引号，提高速度<br>  http/2允许服务器未经请求，主动向客户端发送资源，即服务器推送(server push)</p>
</blockquote>
</li>
</ul>
<h3 id="一次完整的http请求处理的过程"><a href="#一次完整的http请求处理的过程" class="headerlink" title="一次完整的http请求处理的过程"></a>一次完整的http请求处理的过程</h3><p><strong>建立连接</strong>：接受或拒绝连接请求<br><strong>接受请求</strong>：接受客户端请求报文中对某资源的一次请求的过程<br>web访问响应模型(Web I/O)</p>
<ul>
<li><p>单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，多个请求被串行响应</p>
</li>
<li><p>多进程I/O模型：并行启动多个进程,每个进程响应一个连接请求</p>
</li>
<li><p>复用I/O结构：启动一个进程，同时响应N个连接请求</p>
<blockquote>
<p>实现方法：多线程模型和事件驱动</p>
<pre><code>多线程模型：一个进程生成N个线程，每线程响应一个连接请求
事件驱动：一个进程处理N个请求</code></pre></blockquote>
</li>
<li><p>复用的多进程I/O模型：启动M个进程，每个进程响应N个连接请求，同时接收M* N个请求</p>
</li>
</ul>
<p><strong>处理请求</strong>：服务器队请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主题部分队请求进行处理</p>
<pre><code>元数据：请求报文首部
&lt;method&gt; &lt;url&gt; &lt;version&gt;
headers 格式name:value
&lt;request body&gt;
示例
    Host:www.msq.com 请求主机的名称
    server:Apache/2.4.7
http常用的请求方法 method
    GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS</code></pre><p><strong>访问资源</strong>：服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责详情求者提供对方请求的静态资源，或动态运行后生成的资源</p>
<pre><code>资源放置于本地文件系统特定的路径：DcoRoot
DocRoot --&gt; /var/www/html
/var/www/html/images/logo.jpg

web服务器资源路径映射方式
docroot
alias
虚拟主机docroot
用户家目录docroot</code></pre><p><strong>构建响应报文</strong>：一旦服务器识别出了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中包含响应状态码，响应首部，如果生成了响应主题的话，还包括响应主体。</p>
<ul>
<li><p>响应实体：如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。响应报文中通常包括</p>
<blockquote>
<p>描述了响应主体MIME类型的Content-Type首部<br>  描述了响应主体长度的Content-Length<br>  实际报文的主体内容</p>
</blockquote>
</li>
<li><p>URL重定向：web服务器构建的响应并非客户端请求的资源，而是资源另外一个访问路径</p>
<blockquote>
<p>永久重定向：<a href="http://www.360buy.com" target="_blank" rel="noopener">http://www.360buy.com</a><br>  临时重定向：<a href="http://www.taobao.com" target="_blank" rel="noopener">http://www.taobao.com</a></p>
</blockquote>
</li>
<li><p>MIME类型：web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型与资源管理起来</p>
<blockquote>
<p>魔法分类：</p>
<pre><code>Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名时</code></pre></blockquote>
<blockquote>
<p>显式分类：</p>
<pre><code>可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型</code></pre></blockquote>
<blockquote>
<p>类型协商： </p>
<pre><code>有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)&quot;最好&quot;</code></pre></blockquote>
</li>
</ul>
<p><strong>发送响应报文</strong>：Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了 </p>
<p><strong>记录日志</strong>：最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务</p>
<h3 id="有状态和无状态"><a href="#有状态和无状态" class="headerlink" title="有状态和无状态"></a>有状态和无状态</h3><p>客户端发出的响应和得到的请求会受到之前的请求和响应的影响（即请求和请求之间有关联）的连接称为有状态的连接，反之称为无状态的连接。http协议是无状态的连接。</p>
<h3 id="http报文语法格式"><a href="#http报文语法格式" class="headerlink" title="http报文语法格式"></a>http报文语法格式</h3><p>request报文</p>
<pre><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;
&lt;entity-body&gt;</code></pre><p>response报文</p>
<pre><code>&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;
&lt;headers&gt;
&lt;entity-body&gt;</code></pre><p>method: 请求方法，标明客户端希望服务器对资源执行的动作GET、HEAD、POST等</p>
<h2 id="httpd介绍"><a href="#httpd介绍" class="headerlink" title="httpd介绍"></a>httpd介绍</h2><p>20世纪90年代初，国家超级计算机应用中心NCSA开发<br>1995年开源社区发布apache（a patchy server）<br>ASF: apache software foundation<br>FSF：Free Software Foundation<br>特性</p>
<ul>
<li>高度模块化：core + modules</li>
<li>DSO: Dynamic Shared Object 动态加/卸载</li>
</ul>
<ul>
<li>MPM：multi-processing module多路处理模块</li>
</ul>
<h3 id="MPM工作模式"><a href="#MPM工作模式" class="headerlink" title="MPM工作模式"></a>MPM工作模式</h3><p><strong>prefork</strong>：多进程I/O模型，每个进程响应一个请求，默认模型</p>
<ul>
<li>一个主进程：生成和回收n个子进程，创建套接字，不响应请求</li>
<li>多个子进程：工作work进程，每个子进程处理一个请求；系统初始时，预先生成多个空闲进程，等待请求，最大不超过1024个</li>
</ul>
<p><strong>worker</strong>：复用的多进程I/O模型,多进程多线程，IIS使用此模型</p>
<ul>
<li>一个主进程：生成m个子进程，每个子进程负责生成n个线程，每个线程响应一个请求，并发响应请求：m* n</li>
</ul>
<p><strong>event</strong>：事件驱动模型（worker模型的变种）</p>
<ul>
<li>一个主进程：生成m个子进程，每个进程直接响应n个请求，并发响应请求：m* n，有专门的线程来管理这些keep-alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放。这样增强了高并发场景下的请求处理能力</li>
</ul>
<h3 id="httpd功能特性"><a href="#httpd功能特性" class="headerlink" title="httpd功能特性"></a>httpd功能特性</h3><p>虚拟主机</p>
<ul>
<li>IP、Port、FQDN</li>
</ul>
<p>CGI：Common Gateway Interface，通用网关接口</p>
<ul>
<li><p>反向代理</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>路径别名</p>
</li>
<li><p>丰富的用户认证机制</p>
<blockquote>
<p>basic<br>  digest</p>
</blockquote>
</li>
<li><p>支持第三方模块</p>
</li>
</ul>
<h4 id="httpd-2-4新特性"><a href="#httpd-2-4新特性" class="headerlink" title="httpd-2.4新特性"></a>httpd-2.4新特性</h4><ul>
<li>MPM支持运行为DSO机制；以模块形式按需加载</li>
<li>event MPM生产环境可用</li>
<li>异步读写机制</li>
<li>支持没模块及每目录的单独日志界别定义</li>
<li>每请求相关的专用配置</li>
<li>增强型的表达分析式</li>
<li>毫秒级持久连接时长定义</li>
<li>基于FQDN的虚拟主机不需要NameVirutalHost指令</li>
<li>新指令，AllowOverrideList</li>
<li>支持用户自定义变量</li>
<li>更低的内存消耗</li>
</ul>
<h3 id="httpd安装"><a href="#httpd安装" class="headerlink" title="httpd安装"></a>httpd安装</h3><p>yum安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install httpd</span><br></pre></td></tr></table></figure>

<p>编译安装：定制或特殊需求</p>
<p>centos7程序环境：httpd-2.4<br>配置文件</p>
<ul>
<li>/etc/httpd/conf/httpd.conf</li>
<li>/etc/httpd/conf.d/* .conf</li>
</ul>
<p>检查配置语法<br>-httpd -t</p>
<h3 id="httpd程序环境"><a href="#httpd程序环境" class="headerlink" title="httpd程序环境"></a>httpd程序环境</h3><p>服务单元文件</p>
<ul>
<li><p>/usr/lib/systemd/system/httpd.service</p>
<blockquote>
<p>配置文件</p>
<pre><code>/etc/sysconfig/httpd</code></pre></blockquote>
</li>
<li><p>模块文件路径</p>
<blockquote>
<p>/etc/httpd/modules<br>  /usr/lib64/httpd/modules</p>
</blockquote>
</li>
<li><p>主程序文件：</p>
<blockquote>
<p>/usr/sbin/httpd</p>
</blockquote>
</li>
<li><p>主进程文件：</p>
<blockquote>
<p>/etc/httpd/run/httpd.pid</p>
</blockquote>
</li>
<li><p>日志文件目录：</p>
<blockquote>
<p>/var/log/httpd</p>
<pre><code>access_log: 访问日志
error_log：错误日志</code></pre></blockquote>
</li>
<li><p>帮助文档包：</p>
<blockquote>
<p>httpd-manual</p>
</blockquote>
</li>
<li><p>httpd配置文件的组成：</p>
<blockquote>
<p>主要组成</p>
<pre><code>Global Environment
Main server configuration
virtual host</code></pre></blockquote>
</li>
<li><p>配置格式：directive value</p>
<blockquote>
<p>directive 不区分字符大小写<br>  value 为路径时，是否区分大小写，取决于文件系统</p>
</blockquote>
</li>
<li><p>官方帮助</p>
<blockquote>
<p><a href="http://httpd.apache.org/docs/2.4/" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/</a></p>
</blockquote>
</li>
</ul>
<h3 id="httpd配置实战"><a href="#httpd配置实战" class="headerlink" title="httpd配置实战"></a>httpd配置实战</h3><h4 id="httpd的条件式应用标签"><a href="#httpd的条件式应用标签" class="headerlink" title="httpd的条件式应用标签"></a>httpd的条件式应用标签</h4><ul>
<li>DocumentRoot 网页url的根<blockquote>
<p>&lt; Directory “”&gt;<br>  control-condition<br>  &lt; /Drectory&gt;<br>  &lt; file “”&gt;<br>  &lt; /file&gt;<br>  &lt; DirectoryMatch&gt;<br>  &lt; /DirectoryMatch&gt;<br>  默认文件夹/文件不允许访问，必许增加控制语句才可以访问</p>
</blockquote>
</li>
</ul>
<h4 id="基于用户的访问控制"><a href="#基于用户的访问控制" class="headerlink" title="基于用户的访问控制"></a>基于用户的访问控制</h4><ul>
<li><p>认证质询：WWW-Authenticate：响应码401，拒绝客户请求，并说明要求客户端提供账号和密码。</p>
</li>
<li><p>认证：Authorization：客户端用户填入账号和密码后再次发送请求报文；认证通过时，则服务器发送响应的资源。</p>
</li>
<li><p>认证方式</p>
<blockquote>
<p>basic：明文<br>  digest：消息摘要认证，兼容性差</p>
</blockquote>
</li>
<li><p>安全域：需要用户认证后方能访问的路径；应该通过名称对其进行标识，以便于高速用户认证的原因</p>
</li>
<li><p>用户的账号和密码</p>
<blockquote>
<p>虚拟账号：仅用于访问某服务时用到的认证标识<br>  存储：文本文件，SQL数据库，ldap(轻量目录访问协议)目录存储，nis等</p>
</blockquote>
</li>
<li><p>示例：使用用户认证</p>
<blockquote>
<p>&lt; Drectory “/path”&gt;<br>  options +indexes #指明的URL路径不存在与定义的页面主页资源相符的资源文件时，返回索引列表给用户<br>  AllowOverride None #是否允许指定目录下的.htaccess中的指令覆盖之前的配置指令<br>  AuthType basic #认证方式<br>  AuthName “string” #认证对话框提示信息<br>  AuthUserFile “/path/to/httpd_user_passwd_file” #存放认证用户的文件<br>  Require user user1 user2… #允许那些用户认证登录，require valid-user表示.htaccess中的用户均可登录<br>  &lt; /Direcroty&gt;</p>
</blockquote>
<blockquote>
<p>生成用于认证的用户</p>
<pre><code>[root@apache conf.d]#htpasswd -b  /etc/httpd/conf/.htpasswd jerry centos</code></pre></blockquote>
</li>
<li><p>示例：使用用户组认证</p>
<blockquote>
<p>&lt; Drectory “/path”&gt;<br>  options +indexes #指明的URL路径不存在与定义的页面主页资源相符的资源文件时，返回索引列表给用户<br>  AllowOverride None #是否允许指定目录下的.htaccess中的指令覆盖之前的配置指令<br>  AuthType basic #认证方式<br>  AuthName “string” #认证对话框提示信息<br>  AuthgroupFile “/path/to/httpd_group_passwd_file” #存放认证用户的文件<br>  Require group group1 group2 group3… #允许那些用户组认证登录，require<br>  &lt; /Direcroty&gt;</p>
</blockquote>
<blockquote>
<p>创建用于认证的用户组文件，并将生成的用户加入组</p>
<pre><code>[root@apache conf]#vi .htgroup
disny : tom jerry</code></pre></blockquote>
<blockquote>
<p>htpasswd命令介绍</p>
<pre><code>htpasswd用于管理httpd认证的用户并自动成相关文件
htpasswd [options] /PATH/HTTPD_PASSWD_FILE username
-c 自动创建文件，仅应该在文件不存在时使用
-p 明文密码
-d CRYPT格式加密，默认
-m md5格式加密
-s sha格式加密
-D 删除指定用户</code></pre></blockquote>
</li>
</ul>
<h4 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h4><p>通过定义路径别名，可以让用户访问不在DcumentRoot定义的根目录下的其他路径</p>
<ul>
<li>示例<blockquote>
<p>如下配置表示，当用户访问192.168.34.108/bbs/时，实际是在访问服务器上的/var/www/html/文件夹下的文件</p>
<pre><code>DocumentRoot /data/www/html/
&lt;Directory &quot;/data/www/html&quot;&gt;
        options none
        allowoverride none
        require all granted                
&lt;/Directory&gt;
Alias /bbs/ /var/www/html/
&lt;Directory &quot;/var/www/html/&quot;&gt;
        options none
        AllowOverride none
        Require all granted
&lt;/Directory&gt;</code></pre></blockquote>
</li>
</ul>
<h4 id="httpd日志"><a href="#httpd日志" class="headerlink" title="httpd日志"></a>httpd日志</h4><p>httpd访问使用LogFormat format logformat_name定义日志格式<br>使用Cuetomlog logs/access_log format_name来启用某种格式的日志</p>
<ul>
<li>format的常用选项<blockquote>
<p> %h 客户端IP地址<br>  %l 远程用户,启用mod_ident才有效，通常为减号“-”<br>  %u 验证（basic，digest）远程用户,非登录访问时，为一个减号“-”<br>  %t 服务器收到请求时的时间<br>  %r First line of request，即表示请求报文的首行；记录了此次请求的“方法”，“URL”以及协议版本<br>  %&gt;s 响应状态码<br>  %b 响应报文的大小，单位是字节；不包括响应报文http首部<br>  %{Referer}i 请求报文中首部“referer”的值；即从哪个页面中的超链接跳转至当前页面的<br>  %{User-Agent}i 请求报文中首部“User-Agent”的值；即发出请求的应用程序</p>
</blockquote>
</li>
</ul>
<p>httpd错误日志有两部分组成，</p>
<ul>
<li>Errorlog “logs/error_log” #错误日志存放位置<br>LogLevel warn #报警级别，此配置代表warn及以上的报警都会记录</li>
</ul>
<h4 id="虚拟主机配置"><a href="#虚拟主机配置" class="headerlink" title="虚拟主机配置"></a>虚拟主机配置</h4><p>通过虚拟主机的配置，可以实现一台服务器提供多个web站点的功能，提高了资源利用率，并且每个主机都可以使用自己专用的日志，别名，等等资源。</p>
<ul>
<li><p>基于ip地址的虚拟主机配置</p>
<blockquote>
<p>如下配置，当访问192.168.34.108时，实际访问的是主机上/data/vhost1文件夹下的文件，当访问172.18.132.240时，实际访问的是主机上/data/vhst2文件夹下的内容</p>
<pre><code>&lt;VirtualHost 192.168.34.108:80&gt;                               
ServerName www.msq.com
DocumentRoot &quot;/data/vhost1&quot;
&lt;Directory &quot;/data/vhost1&quot;&gt;
        Options None
        AllowOverride None
        Require all granted
&lt;/Directory&gt;
&lt;/Virtualhost&gt;
&lt;VirtualHost 172.18.132.240:80&gt;
        ServerName bbs.msq.com
        DocumentRoot &quot;/data/vhost2&quot;
        &lt;Directory &quot;/data/vhost2&quot;&gt;
                Options None
                AllowOverride None
                Require all granted
        &lt;/Directory&gt;
&lt;/Virtualhost&gt;</code></pre></blockquote>
</li>
<li><p>基于端口的虚拟主机的配置，当访问192.168.34.108:8080时，实际访问的是/data/vhost1文件夹下的文件</p>
<blockquote>
<p>如下配置实现了基于端口的虚拟主机的配置</p>
<pre><code>Listen 8080
&lt;VirtualHost 192.168.34.108:8080&gt;
        ServerName www.msq.com
        DocumentRoot &quot;/data/vhost1&quot;
        &lt;Directory &quot;/data/vhost1&quot;&gt;
                Options None
                AllowOverride None
                Require all granted
        &lt;/Directory&gt;
&lt;/Virtualhost&gt;</code></pre></blockquote>
</li>
<li><p>基于主机名的虚拟主机配置,此模式下需要使用DNS解析，</p>
<blockquote>
<p>如下配置实现了基于主机名的虚拟主机的配置，当访问<a href="http://www.msq.com时，访问的是/data/vhost1文件夹下的资源，当访问bbs.msq.com时，访问的是/data/vhost2文件夹下的资源。" target="_blank" rel="noopener">www.msq.com时，访问的是/data/vhost1文件夹下的资源，当访问bbs.msq.com时，访问的是/data/vhost2文件夹下的资源。</a></p>
<pre><code>&lt;VirtualHost *:80&gt;                                           
ServerName www.msq.com
DocumentRoot &quot;/data/vhost1&quot;
&lt;Directory &quot;/data/vhost1&quot;&gt;
        Options None
        AllowOverride None
        Require all granted
&lt;/Directory&gt;
&lt;/Virtualhost&gt;
&lt;VirtualHost *:80&gt;
        ServerName bbs.msq.com
        DocumentRoot &quot;/data/vhost2&quot;
        &lt;Directory &quot;/data/vhost2&quot;&gt;
                Options None
                AllowOverride None
                Require all granted
        &lt;/Directory&gt;
&lt;/Virtualhost&gt;</code></pre></blockquote>
</li>
</ul>
<h4 id="持久连接配置"><a href="#持久连接配置" class="headerlink" title="持久连接配置"></a>持久连接配置</h4><p>httpd-2.4支持毫秒级持久连接时长定义，全局配置；打开保持连接可以提高请求和响应的效率，但是当并发量较大时，会降低并发能力，需要在这之间寻找平衡。<br>KeepAlive on #开启持久连接<br>KeepAlive Timeout #ms #持久连接时长<br>MaxKeepAliveRequests 100 #最大持久链接数</p>
<h4 id="mod-deflate模块"><a href="#mod-deflate模块" class="headerlink" title="mod_deflate模块"></a>mod_deflate模块</h4><p>使用mod_deflate模块可以压缩页面优化传输速度<br>使用场景</p>
<ul>
<li><p>节约带宽，额外消耗CPU；同时，可能有些叫老浏览器不支持</p>
</li>
<li><p>压缩适于压缩的资源，例如文本文件</p>
</li>
<li><p>使用mod_deflate模块方法</p>
<blockquote>
<p>加载模块,可以在/etc/httpd/conf.moduels.d/文件夹下新建一个配置文件用于配置(htttpd-2.4默认已经加载该模块)</p>
<blockquote>
<p>LoadModule deflate_module modules/mod_deflate.so </p>
</blockquote>
</blockquote>
<blockquote>
<p>配置对哪些资源进行压缩，可以创建一个/etc/httpd/conf.d/deflate.conf的文件写入以下配置</p>
<blockquote>
<p>SetOutputFilter DEFLATE</p>
</blockquote>
</blockquote>
<h1 id="Restrict-compression-to-these-MIME-types"><a href="#Restrict-compression-to-these-MIME-types" class="headerlink" title="Restrict compression to these MIME types"></a>Restrict compression to these MIME types</h1><p>  AddOutputFilterByType DEFLATE text/plain<br>  AddOutputFilterByType DEFLATE text/html<br>  AddOutputFilterByType DEFLATE application/xhtml+xml<br>  AddOutputFilterByType DEFLATE text/xml<br>  AddOutputFilterByType DEFLATE application/xml<br>  AddOutputFilterByType DEFLATE application/x-javascript<br>  AddOutputFilterByType DEFLATE text/javascript<br>  AddOutputFilterByType DEFLATE text/css</p>
<blockquote>
<p>设置压缩比，压缩比越大，消耗CPU越严重,压缩后的页面更小</p>
<blockquote>
<p>Level of compression (Highest 9 - Lowest 1)<br>  DeflateCompressionLevel 9</p>
</blockquote>
</blockquote>
<blockquote>
<p>排除特定旧版本的浏览器，不支持压缩</p>
<blockquote>
<p>Netscape 4.x 只压缩text/html<br>  BrowserMatch ^Mozilla/4 gzip-only-text/html<br>  Netscape 4.06-08三个版本 不压缩<br>  BrowserMatch ^Mozilla/4.0[678] no-gzip<br>  Internet Explorer标识本身为“Mozilla / 4”，但实际上是能够处理请求的压<br>  缩。如果用户代理首部匹配字符串“MSIE”（“B”为单词边界”），就关闭<br>  之前定义的限制<br>  BrowserMatch \bMSI[E] !no-gzip !gzip-only-text/html</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="status页面"><a href="#status页面" class="headerlink" title="status页面"></a>status页面</h4><p>status页面是由http内建模块提供的一项功能，允许用户查看服务器状态，这是个比较危险的设置，应该做访问控制，只允许内部ip进行浏览，或者通过认证才能访问。</p>
<ul>
<li><p>配置</p>
<blockquote>
<p>查看当前httpd是否加载了status模块（默认加载）</p>
<pre><code>[root@apache ~]#httpd -M|grep status
 status_module (shared)</code></pre></blockquote>
<blockquote>
<p>如果未加载，可在/etc/httpd/conf.moduels.d/目录下添加配置文件，写入如下配置</p>
<pre><code>LoadModule status_module modules/mod_status.so</code></pre></blockquote>
<blockquote>
<p>添加配置以启动status功能，可以增加全局设置或者只对某个虚拟主机进行配置（以在虚拟主机中配置为例）</p>
<pre><code> &lt;VirtualHost *:80&gt;
ServerName blog.msq.com
DocumentRoot &quot;/data/vhost3&quot;
&lt;Directory &quot;/data/vhost3&quot;&gt;
        Options None
        AllowOverride None
        Require all granted
        &lt;/Directory&gt;
        &lt;Location &quot;/status&quot;&gt;
                SetHandler server-status
                require ip 192.168.34                            
        &lt;/Location&gt;
&lt;/Virtualhost&gt;</code></pre></blockquote>
</li>
</ul>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https: http over ssl<br>SSL会话的简化过程</p>
<ul>
<li><p>客户端发送可供选择的加密方式，并向服务器请求证书</p>
</li>
<li><p>服务器端发送证书以及选定的加密方式给客户端</p>
</li>
<li><p>客户端取得证书并进行证书验证</p>
<blockquote>
<p>如果信任给其发证书的CA</p>
<pre><code>验证证书来源的合法性；用CA的公钥解密证书上数字签名
验证证书的内容的合法性：完整性验证
检查证书的有效期限
检查证书是否被吊销
证书中拥有者的名字，与访问的目标主机要一致</code></pre></blockquote>
</li>
<li><p>客户端生成临时会话密钥（对称密钥），并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换</p>
</li>
<li><p>服务用此密钥加密用户请求的资源，响应给客户端</p>
</li>
<li><p>注意：SSL是基于IP地址实现，单IP的主机仅可以使用一个https虚拟主机</p>
</li>
</ul>
<h3 id="https的实现"><a href="#https的实现" class="headerlink" title="https的实现"></a>https的实现</h3><p><strong>为服务器申请数字证书</strong></p>
<ul>
<li>测试：通过实践CA发证书<blockquote>
<p>创建私有CA<br>  在服务器创建证书件数请求<br>  CA签证</p>
</blockquote>
</li>
</ul>
<p><strong>配置httpd支持使用ssl，及使用的证书</strong></p>
<ul>
<li>yum -y install mod-ssl<blockquote>
<p>配置文件：/etc/httpd/conf.d/ssl.conf</p>
<blockquote>
<p>DocumentRoot<br>  ServerName<br>  SSLCertificateFile<br>  SSLCertificateKeyFile</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><strong>测试基于httpd访问响应的主机</strong><br>可以使用浏览器或openssl客户端测试</p>
<ul>
<li>openssl s_client [-connect host:port] [-cert filename] [-CApath directory] [-CAfile filename]</li>
</ul>
<h4 id="https实战"><a href="#https实战" class="headerlink" title="https实战"></a>https实战</h4><p>生成私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ssl]<span class="comment">#(umask 066;openssl genrsa -out cakey.pem 2048)</span></span><br></pre></td></tr></table></figure>
<p>生成自签名证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ssl]<span class="comment">#openssl req -new -x509 -key cakey.pem -out cacert.crt -subj "/CN=blog.msq.com/O=devops" -days 3650</span></span><br></pre></td></tr></table></figure>
<p>安装mod-ssl模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ssl]<span class="comment">#yum -y install mod_ssl</span></span><br></pre></td></tr></table></figure>
<p>修改/etc/httpd/conf.d/ssl.conf配置文件，将以下内容更改</p>
<pre><code>SSLCertificateFile /etc/httpd/ssl/httpd.crt
SSLCertificateKeyFile /etc/httpd/ssl/httpd.crt</code></pre><p>重启httpd后，就实现了https连接。</p>
<h4 id="http重定向到https"><a href="#http重定向到https" class="headerlink" title="http重定向到https"></a>http重定向到https</h4><p>将http请求转发至https的URL上</p>
<ul>
<li><p>在配置文件加上下述语句</p>
<blockquote>
<p>Redirect [status] URL -path URL</p>
</blockquote>
</li>
<li><p>status状态</p>
<blockquote>
<p>Permanent: 返回永久重定向状态码301<br>  Temp：返回临时重定向状态码302，此为默认值</p>
</blockquote>
</li>
<li><p>示例</p>
<blockquote>
<p>Redirect temp / <a href="http://blog.msq.com" target="_blank" rel="noopener">http://blog.msq.com</a></p>
</blockquote>
</li>
</ul>
<p>配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache ~]<span class="comment">#ll /var/www/html/</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 1 root root 8435 Dec 14 18:59 access_log</span><br><span class="line">drwxr-xr-x 4 root root   24 Oct 20 09:43 centos</span><br></pre></td></tr></table></figure>

<h2 id="http相关工具"><a href="#http相关工具" class="headerlink" title="http相关工具"></a>http相关工具</h2><h3 id="curl工具"><a href="#curl工具" class="headerlink" title="curl工具"></a>curl工具</h3><p>curl是基于URL语法在命令行方式下工作的文件传输工具，它支持FTP, FTPS,<br>HTTP, HTTPS, GOPHER, TELNET, DICT, FILE及LDAP等协议。curl支持HTTPS认<br>证，并且支持HTTP的POST、PUT等方法， FTP上传， kerberos认证，HTTP上<br>传，代理服务器，cookies，用户名/密码认证， 下载文件断点续传，上载文件断<br>点续传, http代理服务器管道（ proxy tunneling），还支持IPv6，socks5代理服<br>务器，通过http代理服务器上传文件到FTP服务器等，功能十分强大</p>
<p><strong>用法</strong></p>
<ul>
<li>curl [options] [URL…]</li>
</ul>
<p>常用options如下</p>
<pre><code>-A/--user-agent &lt;string&gt; 设置用户代理发送给服务器
-e/--referer &lt;URL&gt; 来源网址
--cacert &lt;file&gt; CA证书 (SSL)
-k/--insecure 允许忽略证书进行 SSL 连接
--compressed 要求返回是压缩的格式
-H/--header &lt;line&gt;自定义首部信息传递给服务器
-i 显示页面内容，包括报文首部信息
-I/--head 只显示响应报文首部信息
-D/--dump-header &lt;file&gt;将url的header信息存放在指定文件中
--basic 使用HTTP基本认证
-u/--user &lt;user[:password]&gt;设置服务器的用户和密码
-L 如果有3xx响应码，重新发请求到新位置
-O 使用URL中默认的文件名保存文件到本地
-o &lt;file&gt; 将网络文件保存为指定的文件中
--limit-rate &lt;rate&gt; 设置传输速度
-0/--http1.0 数字0，使用HTTP 1.0
-v/--verbose 更详细
-C 选项可对文件使用断点续传功能
-c/--cookie-jar &lt;file name&gt; 将url中cookie存放在指定文件中
-x/--proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址
-X/--request &lt;command&gt; 向服务器发送指定请求方法
-U/--proxy-user &lt;user:password&gt; 代理服务器用户和密码
-T 选项可将指定的本地文件上传到FTP服务器上
--data/-d 方式指定使用POST方式传递数据
-b name=data 从服务器响应set-cookie得到值，返回给服务器</code></pre><h3 id="elinks工具"><a href="#elinks工具" class="headerlink" title="elinks工具"></a>elinks工具</h3><p><strong>用法</strong></p>
<ul>
<li>elinks [OPTION]… [URL]…</li>
</ul>
<p>常用options</p>
<pre><code>-dump: 非交互式模式，将URL的内容输出至标准输出
-source:打印源码</code></pre><h3 id="httpd自带的工具程序"><a href="#httpd自带的工具程序" class="headerlink" title="httpd自带的工具程序"></a>httpd自带的工具程序</h3><p>htpasswd：basic认证基于文件实现时，用到的账号密码文件生成工具<br>apachectl：httpd自带的服务控制脚本，支持start和stop<br>rotatelogs：日志滚动工具,如果单个日志太大会影响服务器性能，日志滚动可以在日志文件达到一定大小或规定时间时进行日志滚动。</p>
<ul>
<li>access.log –&gt; access.log,access.1.log –&gt; access.log,access.1.log,access.2.log</li>
</ul>
<h4 id="httpd的压力测试工具"><a href="#httpd的压力测试工具" class="headerlink" title="httpd的压力测试工具"></a>httpd的压力测试工具</h4><p>ab,webbench,http_load,seige</p>
<ul>
<li>ab,webbench,http_load,seige</li>
<li>jmeter 开源</li>
<li>loaddrunner 商业，有相关认证</li>
<li>tcpcopy 网易，复制生产环境中的真是请求，并将之保存</li>
</ul>
<p><strong>ab介绍</strong><br>ab时httpd自带的一个压力测试工具，来自httpd-tools包</p>
<p><strong>用法</strong></p>
<ul>
<li>ab [options] url</li>
</ul>
<p>常用options</p>
<pre><code>-n:请求总数
-c:模拟的并行数
-k:以持久连接模式测试</code></pre><p>ulimit -n # 调整能打开的文件数</p>
]]></content>
      <tags>
        <tag>httpd</tag>
        <tag>web服务</tag>
      </tags>
  </entry>
  <entry>
    <title>keepalived</title>
    <url>/2018/01/28/keepalived/</url>
    <content><![CDATA[<h2 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h2><p>VRRP通过一种竞选(election)协议来动态的将路由任务交给LAN中虚拟路由器中的某台VRRP路由器。</p>
<p><strong>VRRP路由器</strong><br>VRRP路由器是一台路由器，只不过上面运行了VRRPD这样的程序来实现VRRP协议，这是一台物理的路由器，一台VRRP路由器可以位于多个虚拟路由器。</p>
<h3 id="keepalived配置"><a href="#keepalived配置" class="headerlink" title="keepalived配置"></a>keepalived配置</h3><p>配置文件组件部分：</p>
<pre><code>TOP HIERACHY
    GLOBAL CONFIGURATION
        Global definitions    
    VRRPD CONFIGURATION
        VRRP synchronization group(s)：vrrp同步组
        VRRP instance(s)：即一个vrrp虚拟路由器
    LVS CONFIGURATION
        Virtual server group(s)
        Virtual server(s)：ipvs集群的vs和rs</code></pre><p>Mater配置示例,backup配置只需将state状态改为BACKUP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># vi /etc/keepalived/keepalived.conf</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     root@localhost</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from keepalived@localhost</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id ha1.example.com</span><br><span class="line">   vrrp_skip_check_adv_addr <span class="comment">#如果收到的报文和上一个报文是同一个路由器则跳过检查报文中的源地址</span></span><br><span class="line">   vrrp_strict <span class="comment">#严格遵守VRRP协议,不允许状况:1,没有VIP地址,2.单播邻居,3.在VRRP版本2中有IPv6地址.</span></span><br><span class="line">   vrrp_garp_interval 0 <span class="comment">#ARP报文发送延迟</span></span><br><span class="line">   vrrp_gna_interval 0 <span class="comment">#消息发送延迟</span></span><br><span class="line">   vrrp_mcast_group4 224.0.0.18 <span class="comment">#默认组播IP地址，224.0.0.0到239.255.255.255</span></span><br><span class="line">   <span class="comment">#vrrp_iptables</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 80</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111qwer</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.7.248 dev eth0 label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master</span><br><span class="line">    notify_backup</span><br><span class="line">    notify_fault</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keepalived通知脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost keepalived]<span class="comment"># cat /etc/keepalived/notify.sh </span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">contact=<span class="string">'2973707860@qq.com'</span></span><br><span class="line"><span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">  mailsubject=<span class="string">"<span class="variable">$(hostname)</span> to be <span class="variable">$1</span>, vip 转移"</span></span><br><span class="line">  mailbody=<span class="string">"<span class="variable">$(date +'%F %T')</span>: vrrp transition, <span class="variable">$(hostname)</span> changed to be <span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$mailbody</span>"</span> | mail -s <span class="string">"<span class="variable">$mailsubject</span>"</span> <span class="variable">$contact</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">master)</span><br><span class="line">  notify master</span><br><span class="line">  ;;</span><br><span class="line">backup)</span><br><span class="line">  notify backup</span><br><span class="line">  ;;</span><br><span class="line">fault)</span><br><span class="line">  notify fault</span><br><span class="line">  ;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$(basename $0)</span> &#123;master|backup|fault&#125;"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p><strong>keepalived配置多vip</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens34</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.34.248/24 dev ens34 label ens34:1</span><br><span class="line">        192.168.34.249/24 dev ens34 label ens34:2</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">"/etc/keepalived/notify.sh master"</span></span><br><span class="line">    notify_backup <span class="string">"/etc/keepalived/notify.sh backup"</span></span><br><span class="line">    notify_fault  <span class="string">"/etc/keepalived/notify.sh fault"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>keepalived双主配置</strong><br>配置方式如下，两台keepalive的主机的priority值需相反</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens34</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">	192.168.34.248/24 dev ens34 label ens34:1</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">"/etc/keepalived/notify.sh master"</span></span><br><span class="line">    notify_backup <span class="string">"/etc/keepalived/notify.sh backup"</span></span><br><span class="line">    notify_fault  <span class="string">"/etc/keepalived/notify.sh fault"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens34</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.34.249/24 dev ens34 label ens34:2</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master <span class="string">"/etc/keepalived/notify.sh master"</span></span><br><span class="line">    notify_backup <span class="string">"/etc/keepalived/notify.sh backup"</span></span><br><span class="line">    notify_fault  <span class="string">"/etc/keepalived/notify.sh fault"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启内核参数，允许haproxy绑定本机没有的ip地址的端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@master keepalived]<span class="comment"># cat /etc/sysctl.d/keepalived.conf </span></span><br><span class="line">net.ipv4.ip_nonlocal_bind = 1</span><br></pre></td></tr></table></figure>
<p>配置haproxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frontend main </span><br><span class="line">  <span class="built_in">bind</span> 192.168.34.248:80</span><br><span class="line">  <span class="comment">#acl ip_range_test src 192.168.34.0/24</span></span><br><span class="line">  <span class="comment">#use_backend test_host if ip_range_test</span></span><br><span class="line">  default_backend default_web</span><br><span class="line"></span><br><span class="line">frontend test_host</span><br><span class="line">  <span class="built_in">bind</span> 192.168.34.249:80</span><br><span class="line">  default_backend test_host</span><br><span class="line"></span><br><span class="line">backend test_host</span><br><span class="line">  mode http</span><br><span class="line">  server web1 192.168.34.102:80 check inter 2000 fall 3 rise 5</span><br><span class="line"></span><br><span class="line">backend default_web</span><br><span class="line">  mode http</span><br><span class="line">  server web2 192.168.34.103:80 check inter 2000 fall 3 rise 5</span><br></pre></td></tr></table></figure>
<p><strong>keepalived单播配置及示例</strong></p>
<pre><code>unicast_src_ip  本机源IP
    unicast_peer {
        目标主机IP
    }</code></pre><p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">	unicast_src_ip 192.168.34.100 </span><br><span class="line">	unicast_peer &#123;</span><br><span class="line">		192.168.34.101</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>keepalived</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh和sudo管理</title>
    <url>/2017/12/12/ssh/</url>
    <content><![CDATA[<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>sh：secure shell,protocol.22/tcp,安全的远程连接<br>    具体的软件实现：<br>        openssh：ssh协议的开源实现，centos默认安装<br>        dropbear：另一个开源实现</p>
<p>ssh客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端组件：</span><br><span class="line">ssh配置文件:&#x2F;etc&#x2F;ssh&#x2F;ssh_config</span><br><span class="line">host PATTERN</span><br><span class="line">StrictHostKeyChecking no 首次登陆不显示检查提示</span><br><span class="line">格式：</span><br><span class="line">ssh [user@]host[COMMAND]</span><br><span class="line">ssh [-I user]host[COMMAND]</span><br><span class="line">常见选项：</span><br><span class="line">-p port：远程服务器监听的端口</span><br><span class="line">-b :指定连接的源ip</span><br><span class="line">-v：调试模式</span><br><span class="line">-C：压缩方式</span><br><span class="line">-X：支持x11转发</span><br><span class="line">-t：强制伪tty分配</span><br><span class="line">ssh -t remoteserver1 ssh -t remoteserver2 ssh remoteserver3</span><br></pre></td></tr></table></figure>
<p>一、ssh基于秘钥验证的原理:<br>a、首先在C(客户端)生成一对秘钥，并将公钥拷贝给S(服务器)一份并重命名为authorized_keys</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ssh-keygen -t rsa -b 2048 </span></span><br><span class="line">[root@node01 ~]<span class="comment">#ssh-copy-id server-ip</span></span><br></pre></td></tr></table></figure>
<p>b、C想S发送一个连接请求，信息包括ip、用户名<br>c、S得到C的信息后，会到authorized_keys中查找，如果有响应的ip和用户名，S会随机生成一个字符串，例如：qwer<br>d、S将使用公钥对字符串qwer进行加密，发送给C<br>e、C得到S发来的消息后，C会使用私钥进行解密，然后将解密后的字符串发送给S<br>f、S接收到字符串会跟先前声称的字符串对比，如果一致，就允许免密码登录。</p>
<p>二、在xshell实现基于可以的验证登录<br>1、在xshell创建公钥–&gt;生成identity.pub文件，并复制到需要登录的主机上相应文件authorized_keys文件中，注意权限必须为600，在需要登录的ssh主机上执行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -i -f identity.pub &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="pssh工具"><a href="#pssh工具" class="headerlink" title="pssh工具"></a>pssh工具</h3><p>pssh是一个python编写的可以在多台服务器上执行命令的工具，也可以实现文件复制</p>
<pre><code>选项：
    --version:查看版本
    -h：主机文件列表，内容格式&quot;[user@]host[:port]&quot;
    -H：主机字符串，内容格式&quot;[user@]host[:port]&quot;
    -A：手动输入密码模式，默认基于key验证
    -i：每个服务器内部处理信息输出
    -l：登陆使用的用户名
    -p：并发的线程数[可选]
    -t：超时时间
    -v：详细模式
    -O：SSH的选项
    -p：打印出服务器的返回信息</code></pre><p>使用案例：<br>1、在多台主机执行相同命令：<br>    pssh -h ip_file -i COMMAND</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#pssh -h iplist.txt -i ifconfig</span></span><br></pre></td></tr></table></figure>
<p>2、实现将本地文本批量复制到远程主机的功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#pscp.pssh -h iplist.txt -r /data/test/ /data/f1.gpg /data/</span></span><br></pre></td></tr></table></figure>
<h2 id="telnet通过ssh隧道实现安全的本地端口转发"><a href="#telnet通过ssh隧道实现安全的本地端口转发" class="headerlink" title="telnet通过ssh隧道实现安全的本地端口转发"></a>telnet通过ssh隧道实现安全的本地端口转发</h2><p>实验：准备三台主机A(192.168.34.101)、B(192.168.34.105)、C(192.168.34.108)；A充当ssh客户端，B充当ssh服务端和Telnet客户端，C充当Telnet服务端。<br>    步骤：<br>    1、centos系统默认不安装telnet-server包，需要先安装telnet-server包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#yum -y install telnet-server</span></span><br><span class="line">[root@node01 ~/.ssh]<span class="comment">#service xinetd start</span></span><br><span class="line">[root@node01 ~/.ssh]<span class="comment">#service xinetd start</span></span><br></pre></td></tr></table></figure>
<p>此时查看端口23是否打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#ss -ntl</span></span><br></pre></td></tr></table></figure>
<p>如果打开了说明Telnet服务可以正常使用，此时用Telnet连接B机器做测试。<br>2、在C机器设置防火墙拒绝A机器的直接连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#iptables -A INPUT -s 192.168.34.101 -j REJECT</span></span><br></pre></td></tr></table></figure>
<p>3、在主机A开启一没被占用的端口，例如9527，用来接收发往远程的Telnet流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#ssh -L 9527:192.168.34.108:23 192.168.34.105 -fN</span></span><br></pre></td></tr></table></figure>
<pre><code>此条命令的意思是在本地开启9527端口，通过shh通道连接到192.168.34.105，再通过192.168.34.105转发给192.168.34.108的23端口。</code></pre><p>4、通过Telnet连接本机的9527端口，此时还自动通过刚才建立的ssh通道连接到C机器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#telnet 127.0.0.1 9527</span></span><br></pre></td></tr></table></figure>
<p>实验结束，本实验模仿A与C之间无法通信，但是B与A,C之间均可通信的情况下，利用B主机做跳板，实现A与C之间的Telnet通信.<br>数据传输流程为：<br>        data–&gt;本地(A)9527端口–&gt;本地随机端口–&gt;ssh server(B)–&gt;ssh server随机端口–&gt;telnet server(C)</p>
<h2 id="Telnet利用ssh通道实现安全的本地端口转发之从企业内部发起shh通道"><a href="#Telnet利用ssh通道实现安全的本地端口转发之从企业内部发起shh通道" class="headerlink" title="Telnet利用ssh通道实现安全的本地端口转发之从企业内部发起shh通道"></a>Telnet利用ssh通道实现安全的本地端口转发之从企业内部发起shh通道</h2><p>实验：同样A(192.168.34.101),B(192.168.34.105),C(192.168.34.108)三个主机<br>1、2两步同上个实验相同<br>3、在B机器上以本机作为客户端，A作为服务器端打开一个ssh通道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#ssh -R 9527:192.168.34.108:23 -fN 192.168.34.101</span></span><br></pre></td></tr></table></figure>
<pre><code>此条命令的意思是，以本机为ssh客户端，A机器为ssh服务端建立通道，将来A机器的9527端口的数据都通过此通道，传到本机，并以本机为Telnet客户端转发给C机器的23端口</code></pre><p>4、在A上Telnet本机的9527端口即可连接到C主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#telnet 127.0.0.1 9527</span></span><br></pre></td></tr></table></figure>
<pre><code>实验结束，本实验从企业内部发起ssh连接，不用修改防火墙策略即可实现，更加具有实用性。</code></pre><h3 id="上述实验有一个缺陷，就是A主机监听的知识127-0-0-1的9527端口，只能A本机实现端口转发功能，那么如果再有一台机器希望连接C该如何做呢？"><a href="#上述实验有一个缺陷，就是A主机监听的知识127-0-0-1的9527端口，只能A本机实现端口转发功能，那么如果再有一台机器希望连接C该如何做呢？" class="headerlink" title="上述实验有一个缺陷，就是A主机监听的知识127.0.0.1的9527端口，只能A本机实现端口转发功能，那么如果再有一台机器希望连接C该如何做呢？"></a>上述实验有一个缺陷，就是A主机监听的知识127.0.0.1的9527端口，只能A本机实现端口转发功能，那么如果再有一台机器希望连接C该如何做呢？</h3><p>很简单，在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#ssh -R 9527:192.168.34.108:23 -fN 192.168.34.101</span></span><br></pre></td></tr></table></figure>
<p>这条命令中增加一个g选项，开启网关功能，即可实现监听A机器的所有网卡的9527端口，实现远程转发功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~/.ssh]<span class="comment">#ssh -R 9527:192.168.34.108:23 -fNg 192.168.34.101</span></span><br></pre></td></tr></table></figure>
<p>实现此步骤，需要在ssh配置文件中打开网关端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#sed -nr '/^Gate/p' /etc/ssh/sshd_config </span></span><br><span class="line">GatewayPorts yes</span><br></pre></td></tr></table></figure>
<h2 id="ssh实现动态端口转发"><a href="#ssh实现动态端口转发" class="headerlink" title="ssh实现动态端口转发"></a>ssh实现动态端口转发</h2><p>实验：准备三台主机A(192.168.34.101)、B(192.168.34.105)、C(192.168.34.108)；A为本地主机，B为购买的国外虚拟机（可访问），C为国外无法访问的互联网主机。本实验实现A通过跳板机B访问C；即在A主机打开一个可用端口作为代理服务器，A对C的访问请求被转发到sshserver（B）上，由B代替A访问C。<br>方法一：<br>1、在A主机执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#ssh -D 1080 192.168.34.105 -fNg</span></span><br></pre></td></tr></table></figure>
<p>2、设置代理：<br>windows：<br>    再浏览器设置代理192.168.34.101:1080即可访问C主机<br>linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#curl --socks5 127.0.0.1:1080 192.168.34.108</span></span><br></pre></td></tr></table></figure>
<p>方法二：<br>1、在B主机打开一个端口做代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#ssh -D 1080 192.168.34.101 -fNg</span></span><br></pre></td></tr></table></figure>
<p>2、设置代理：<br>    windows：<br>        再浏览器设置代理192.168.34.101:1080即可访问C主机<br>    linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#curl --socks5 127.0.0.1:1080 192.168.34.108</span></span><br></pre></td></tr></table></figure>

<h2 id="ssh服务器"><a href="#ssh服务器" class="headerlink" title="ssh服务器"></a>ssh服务器</h2><pre><code>服务器端配置文件
    /etc/ssh/sshd_config
常用参数
    port     监听端口，默认22
    ListenAddress ip     监听地址，设置监听哪块网卡
    LoginGraceTime 2m     宽限登录时长，等待时间
    PermitRootLogin yes     是否允许root账户登录
    StrictModes yes 检查.ssh/文件的所有者，权限等
    MaxAuthTries 6     最大错误尝试次数，当达到最大值的一半时，结束
    MaxSessions 10 同一个连接最大会话
    PubkeyAuthentication yes     允许使用秘钥登录
    PermitEmptyPasswords no     是否允许空密码登录
    PasswordAuthentication yes     是否允许使用密码登录
    GatewayPorts no     是否启用网关功能
    ClientAliveInterval 单位:秒；客户端活跃检查次数
    ClientAliveCountMax 默认3；客户端是否活跃检查次数
    UseDNS yes     是否开启DNS解析
    GSSAPIAuthentication yes 提高速度可改为no
    MaxStartups 未认证连接最大值，默认值10
    Banner /path/file  登录提示，类似/etc/motd的功能
    限制可登录用户的办法：
        AllowUsers user1 user2 user3
        DenyUsers
        AllowGroups
        DenyGroups</code></pre><h2 id="ssh最佳实践"><a href="#ssh最佳实践" class="headerlink" title="ssh最佳实践"></a>ssh最佳实践</h2><ul>
<li>建议使用非默认端口</li>
<li>禁止使用protocol version 1</li>
<li>限制可登陆用户</li>
<li>设定空闲会话超时时长</li>
<li>利用防火墙设置ssh访问策略</li>
<li>仅监听特定的IP地址</li>
<li>基于口令认证时使用强密码侧罗<br>  随机密码生成，例如：<pre><code>openssl rand -base64 8
tr -dc &quot;[[:alnum:]]&quot; &lt; /dev/urandom | head -c 8</code></pre></li>
<li>使用基于秘钥的认证</li>
<li>禁止使用空密码</li>
<li>禁止root用户直接登录</li>
<li>限制ssh的访问频度和并发在线数</li>
<li>经常分析日志</li>
</ul>
]]></content>
      <tags>
        <tag>ssh</tag>
        <tag>sudo</tag>
      </tags>
  </entry>
  <entry>
    <title>dropbear</title>
    <url>/2017/11/21/dropbear/</url>
    <content><![CDATA[<h2 id="dropbear入门"><a href="#dropbear入门" class="headerlink" title="dropbear入门"></a>dropbear入门</h2><h3 id="下载dropbear源码"><a href="#下载dropbear源码" class="headerlink" title="下载dropbear源码"></a>下载dropbear源码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 /app]<span class="comment">#wget https://matt.ucc.asn.au/dropbear/dropbear-18.76.tar.bz2</span></span><br></pre></td></tr></table></figure>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 /app]tar -xf dropbear-2018.76.tar.bz2</span><br><span class="line">[root@node01 /app]<span class="built_in">cd</span> dropbear-2018.76/</span><br><span class="line">[root@node01 /app/dropbear-2018.76]<span class="comment">#./configure --prefix=/app/dropbear-2018.76 --sysconfdir=/etc/dropbear</span></span><br><span class="line">[root@node01 /app/dropbear-2018.76]<span class="comment">#make PROGRAMS="dropbear dbclient dropbearkey dropbearconvert scp"</span></span><br><span class="line">[root@node01 /app/dropbear-2018.76]<span class="comment"># make PROGRAMS="dropbear dbclient dropbearkey dropbearconvert scp" install</span></span><br><span class="line">[root@node01 /app/dropbear-2018.76]<span class="comment">#ln -s /app/dropbear-2018.76/ /app/dropbear</span></span><br></pre></td></tr></table></figure>

<h3 id="启动ssh服务"><a href="#启动ssh服务" class="headerlink" title="启动ssh服务"></a>启动ssh服务</h3><p>由于默认不会生成配置文件目录，所以需要创建此目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir /etc/dropbear</span><br></pre></td></tr></table></figure>
<p>生成私钥并开启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /app/dropbear/sbin</span><br><span class="line">$ ./dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key</span><br><span class="line">$ ./dropbear -FE -p 22222 (以前台方式打开服务)</span><br></pre></td></tr></table></figure>
<p>此时，就可以在远程通过22222端口访问本主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -p 22222 192.168.34.108</span><br></pre></td></tr></table></figure>

<p>将dropbear相关命令加入环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'PATH=/app/dropbear/bin:/app/dropbear/sbin:$PATH'</span> &gt; /etc/profile.d/dropbear.sh</span><br></pre></td></tr></table></figure>
<p>以后再使用dropbear相关命令就不用再写绝对路径了，比较方便。<br>至此，实验演示结束，如果喜欢可以做成系统服务开机自启，不喜欢删掉即可。</p>
]]></content>
      <tags>
        <tag>dropbear</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议和管理</title>
    <url>/2017/10/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>物理拓扑分类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总线拓扑：所有设备均可接受信号</span><br><span class="line">环状拓扑：信号绕环传输，单一故障点</span><br><span class="line">双环拓扑：信号沿相反方向传输，比单环的复原能力更强</span><br><span class="line">星型拓扑：通过中心点传输，单一故障点</span><br><span class="line">扩展的星型拓扑：比星型拓扑的复原能力强***主流的拓扑结构</span><br><span class="line">全网状拓扑：容错能力强，实施成本高。</span><br><span class="line">部分网状拓扑：在容错能力与成本之间寻求平衡。</span><br></pre></td></tr></table></figure>

<p><strong>osi七层模型：降低复杂性、标准化接口、简化模块化设计、确保技术的互操作性、加快发展速度、简化教学</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7、应用层application</span><br><span class="line">	网络进程访问应用程序；为应用程序进程（例如，电子邮件、文件传输和终端仿真）提供网络服务；提供用户身份验证。</span><br><span class="line">6、表示层persention</span><br><span class="line">	数据表示；确保接收系统可以读出该数据；格式化数据；构建数据；协商用于应用层的数据传输语法；提供加密。</span><br><span class="line">5、会话层session</span><br><span class="line">	主机间通信；建立、管理和终止在应用程序之间的会话。</span><br><span class="line">4、传输层transport</span><br><span class="line">	传输问题；确保数据传输的可靠性，建立、维护和终止虚拟电路；通过错误检测和恢复；信息流控制来保障可靠性。</span><br><span class="line">3、网络层network</span><br><span class="line">	数据传输；路由数据包，选择传递数据的最佳路径，支持逻辑寻址和路径选择。路由器工作在网络层。</span><br><span class="line">2、数据链路层data link</span><br><span class="line">	访问介质；定义如何格式化数据以便进行传输以及如何控制对网络的访问，支持错误检查。交换机工作在数据链路层。</span><br><span class="line">1、物理层physical</span><br><span class="line">	二进制传输；为启动、维护、以及关闭物理链路定义了电气规范、机械规范、过程规范和功能规范。hub集线器工作在物理层</span><br></pre></td></tr></table></figure>
<p>osi七层模型中，下层为上层提供服务。</p>
<p>三种通讯模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单播unicast</span><br><span class="line">多播multicast</span><br><span class="line">广播btoadcast</span><br></pre></td></tr></table></figure>

<p>lan的组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computers</span><br><span class="line">	PCs</span><br><span class="line">	Servers</span><br><span class="line">Interconnections</span><br><span class="line">	NICs</span><br><span class="line">	Media</span><br><span class="line">Network devices</span><br><span class="line">	Hubs</span><br><span class="line">	Switches</span><br><span class="line">	Routers</span><br><span class="line">Protocols</span><br><span class="line">	Ethernet</span><br><span class="line">	IP</span><br><span class="line">	ARP</span><br><span class="line">	DHCP</span><br></pre></td></tr></table></figure>

<p>双绞线针脚定义：<br>     百兆以内：半双工，只发或只收<br>     千兆：全双工，即发又收</p>
<p> 单工：喇叭，广播，<br> 半双工：对讲机，微信语音<br> 全双工：打电话</p>
<p>光纤以及光电转换（把网线转换成光纤），光纤的传输距离能达到千米以上。<br>熔纤机，光纤的材质是玻璃纤维。</p>
<p>网络适配器（网卡）：工作在数据链路层</p>
<p>以太网：工作在数据链路层，规定数据帧的报文结构，分成有线以太网和无线以太网（WiFi）</p>
<p>马斯洛理论：<br>    自我实现<br>    尊重<br>    社会<br>    安全<br>    生理</p>
<p>hub集线器：<br>    多端口中继器<br>    hub并不记忆该信息包是由哪个MAC地址发出，哪个MAC地址在hub的哪个端口。<br>    特点：<br>        共享带宽<br>        半双工<br>        hub会产生flood泛洪现象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">冲突域：一台主机发送报文，另一台主机也发送报文，产生冲突，则两台设备在同一个冲突域；不产生冲突，则两台设备不在同一个冲突域。</span><br><span class="line">广播域：一个主机发送广播，另一个主机能收到，则两台主机在同一个广播域；否则不再同一个广播域。</span><br></pre></td></tr></table></figure>

<p>为了解决冲突域和广播域的问题，采取如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以太网桥：</span><br><span class="line">	优势：</span><br><span class="line">		扩展了网络带宽</span><br><span class="line">		分割了网络冲突域，使网络冲突被限制在最小的范围内</span><br><span class="line">		交换机作为更加智能的交换设备，能够提供更多用户所要求的功能：优先级，虚拟网，远程检测......</span><br><span class="line">	以太网桥的工作原理：</span><br><span class="line">		以太网桥监听数据帧中源MAC地址，学习MAC，建立MAC表</span><br><span class="line">		对于未知MAC地址，网桥将转发到除接收该帧的端口之外的所有端口</span><br><span class="line">		当网桥接到一个数据帧时，如果该帧的目的位于接收端口所在网段上，它就过滤掉该数据帧；如果目的MAC地址位于另外一个端口，网桥就将该帧转发到该端口</span><br><span class="line">		当网桥接到广播帧时，它立即转发到除接收端口之外的所有其他端口。</span><br></pre></td></tr></table></figure>

<p>路由器：<br>为了实现路由，路由器需要做以下事情：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分割广播域</span><br><span class="line">选择路由表中到达目标最好的路径</span><br><span class="line">维护和检查路由信息</span><br><span class="line">连接广域网</span><br></pre></td></tr></table></figure>

<p>路由：把一个数据包从一个设备发送到不同网络里的里一个设备上去。这些工作依靠路由器来完成。路由器只关心网络的状态和<br>    决定网络中的最佳路径。路由的实现依靠路由器中的路由表来完成。</p>
<p>VLAN：VLAN=广播域=逻辑网络（Subnet）<br>    分割广播域<br>    安全<br>    灵活管理<br>单臂路由：</p>
<p>分层的网络架构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">核心层Core Layer：</span><br><span class="line">	企业级应用快速转发</span><br><span class="line">分布层Distribution：</span><br><span class="line">	广播域，路由，安全，远程接入，访问层汇聚</span><br><span class="line">访问层AccessLayer：</span><br><span class="line">	终端接入</span><br></pre></td></tr></table></figure>

<p>以太网帧的最小长度为46个字节</p>
<p>TCP/IP协议：协议栈<br>    全称：Transmission Control Protocol/Internet Protocol<br>        传输控制协议/因特网互联协议<br>    共定义了4层<br>        4、应用层（包括osi模型的应用层，表示层，会话层）<br>            协议：http、ftp、tftp、nfs、telnet、smtp、dns<br>        3、传输层（相当于osi的传输层）<br>            协议：tcp（面向连接，）、udp（不面向连接，）<br>            功能：多路会话、分段（将大文件切割成小的段进行传输）、<br>        2、Internet层（相当于osi模型的网络层）<br>        1、网络访问层（相当于数据链路层和物理层的集合）<br>TCP协议的特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工作在传输层</span><br><span class="line">面向连接协议</span><br><span class="line">全双工协议</span><br><span class="line">半关闭</span><br><span class="line">错误检查</span><br><span class="line">将数据打包成段，排序</span><br><span class="line">确认机制</span><br><span class="line">数据恢复重传</span><br><span class="line">流量控制控制，滑动窗口</span><br><span class="line">拥塞控制，慢启动和拥塞避免算法</span><br></pre></td></tr></table></figure>

<p>TCP协议包头：<br>    前20个字节（160位）固定；前32位0-31为源端口和目标端口，之后32位为序号，在之后32位为确认号，</p>
<p>相关服务的固定端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http：80</span><br><span class="line">ssh：22</span><br><span class="line">ftp：21</span><br><span class="line">qq udp：8000</span><br><span class="line">telnet：23	</span><br><span class="line">dns：53</span><br><span class="line">tftp：69</span><br><span class="line">snmp：161</span><br><span class="line">https：443</span><br><span class="line">mysql：3306</span><br></pre></td></tr></table></figure>

<p>TCP/IP的三次握手：<br>    有限状态机FSM：Finite State Machine<br>    11种状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLSED 没有任何连接状态</span><br><span class="line">LISTEN 侦听状态，等待来自远方TCP端口的连接请求</span><br><span class="line"></span><br><span class="line">SYN-SENT 在发送连接请求之后，等待对方确认</span><br><span class="line">SYN-RECIVED 在收到和发送一个连接请求之后，等待对方确认</span><br><span class="line"></span><br><span class="line">ESTABLISHED 代表传输连接建立，双方进入数据传送状态</span><br><span class="line"></span><br><span class="line">FIN-WAIT1 主动关闭，主机已经发送关闭连接请求，等待对方确认</span><br><span class="line">FIN-WAIT2 主动关闭，主机已经收到对方关闭传输连接确认</span><br><span class="line"></span><br><span class="line">TIME-WAIT 完成双向传输连接关闭，等待所有分组消失</span><br><span class="line">CLOSE-WAIT 被动关闭，收到对方发来的关闭连接请求，并已确认</span><br><span class="line"></span><br><span class="line">LAST-ACK 被动关闭，等待最后一个关闭传输连接确认，并等待所有分组消失</span><br><span class="line">CLOSING 双方同时尝试关闭传输连接，等待对方确认</span><br></pre></td></tr></table></figure>

<p>UDP特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工作在传输层</span><br><span class="line">提供不可靠的网络访问</span><br><span class="line">非面向连接协议</span><br><span class="line">有限的错误检查</span><br><span class="line">传输性能高</span><br><span class="line">无数据恢复特性</span><br></pre></td></tr></table></figure>

<p>sync半连接和accept全连接队列<br>    未完成连接队列大小，建议调整大小为1024以上<br>    完成连接队列大小，建议调整大小为1024以上</p>
<p>ICMP协议详解：Internet层协议。<br>     /proc/sys/net/ipv4/icmp_echo_ignore_all<br>         该文件内容为0时，允许回应ICMP包，为1时不允许回应<br>     利用ICMP进行攻击<br>        ping -s 65507 Package_size -f ip 可以使目标主机的网卡利用率暴涨</p>
<p>ARP协议：Adress Resolution Protocol 地址解析协议<br>    A知道B的IP不但是知道位置，A在寻找B时会发ARP广播，B收到广播后，会将A的IP和A的Mac地址存到本机ARP列表，<br>        之后会向A发送返回包，包中包含自己的mac，A收到B发来的返回包后，会在机子的ARP列表中加入B的IP和Mac对应关系。</p>
<p>ARP寻址时如果夸路由器，则A和B必须配置网关，网关分别对应连接的路由器的端口，        </p>
<p><strong>IP报文</strong><br>    IP报头：20个字节（128位），<br>    报文头部格式：Package<br>        4位版本号；4位首部长度；8位分区服务；16位的总长度；16位的标识；<br>        3位的标志；13位的片偏移；8位生存时间；8位协议；16位首部检验和；<br>        32位源地址；32位目的地址；长度可变的可选字段；填充部分；</p>
<p>主机到主机的包传递过程：<br>    路由-&gt; ARP -&gt; 三次握手 -&gt;  </p>
<p>ip地址：<br>    标识每个主机所在的网段和在网络中的位置。<br>    组成：<br>        网络ID位：<br>            标识网络<br>            每个网段分配一个网络ID<br>        主机ID：<br>            标识单个主机<br>            有组织分配给各设备<br>网关：下一个路由器距离本机近的那个端口。<br>路由表：只负责往外发，把包发送到哪个位置。不负责接收。</p>
<p>主机和远程主机通信的过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拿到对方主机的ip</span><br><span class="line">判断本主机和对方主机是否在一个网段：对方ip和本机子网掩码与，再拿本机ip和子网掩码与，看结果是否相同。</span><br><span class="line">查找路由表，找到去往远程主机的路径。</span><br></pre></td></tr></table></figure>

<p>动态主机配置协议DHCP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端发送发现报文广播；discover</span><br><span class="line">DHCP服务器发送广播提供消息；offer</span><br><span class="line">客户端对请求消息做出响应。request；告诉网络中主机本机占用的ip</span><br><span class="line">DHCP服务器以确认消息结束交换过程。ACK确认报文；</span><br></pre></td></tr></table></figure>

<pre><code>DHCP采用UDP协议，服务器端口号为68；客户端端口号为67.</code></pre><p>基本网络配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将linux主机接入到网络中，需要配置网络相关配置。</span><br><span class="line">一般包括如下内容：</span><br><span class="line">	主机名</span><br><span class="line">	IP&#x2F;netmask</span><br><span class="line">	路由：默认网关</span><br><span class="line">	DNS服务器： 将域名解析成IP地址；hosts文件也可本地解析</span><br><span class="line">		主DNS服务器</span><br><span class="line">		次DNS服务器</span><br><span class="line">		第三DNS服务器</span><br></pre></td></tr></table></figure>
<pre><code>默认本地hosts文件的解析优先级高于DNS，但是可以通过/etc/nsswitch.conf控制两者优先级。</code></pre><p>###########################################################<br>centos6相关网络配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网络接口识别并命名相关的udev配置文件：</span><br><span class="line">	&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-net.rules</span><br><span class="line">主机名存放的文件： 修改完主机名后，建议将新的主机名加入hosts文件做解析</span><br><span class="line">	&#x2F;etc&#x2F;sysconfig&#x2F;network</span><br><span class="line">查看网卡信息：</span><br><span class="line">	dmesg | grep -i eth </span><br><span class="line">	ethtool -i eth0</span><br><span class="line">卸载网卡驱动：</span><br><span class="line">	modprobe -r e1000</span><br><span class="line">	rmmod e1000</span><br><span class="line">装载网卡驱动：</span><br><span class="line">	modprobe e1000</span><br></pre></td></tr></table></figure>

<p>centos7相关网络配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主机名存放文件：</span><br><span class="line">	&#x2F;etc&#x2F;hostname</span><br><span class="line">修改主机名： 修改完主机名后，建议将新的主机名加入hosts文件做解析</span><br><span class="line">	hostnamectl set-hostname new-hostname</span><br></pre></td></tr></table></figure>

<p>##########################################################</p>
<p>arping -I 网卡名 ip ：通过该网卡发送ARP广播查找该网段中有几个主机的ip相同。</p>
<p>ip地址配置方式:<br>静态指定：<br>    ifconfig route netstat<br>    ip:object {link,addr,route} , ss , tc<br>    system-config-network-tui,setup<br>    配置文件<br>动态分配：<br>    DHCP:Dynamic Host Configuration Protocol </p>
<p>网络配置相关命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig命令：</span><br><span class="line">	ifconfig [interface] </span><br><span class="line">		ifconfig -a  查看所有网卡信息</span><br><span class="line">		ifconfig IFACE [up|down] 启用|禁用网卡（从链路层down掉，拔网线从物理层down掉）；等价于 ifup|ifdown DEVICE</span><br><span class="line">	ifconfig interface [aftype] options | address ...</span><br><span class="line">		ifconfig IFACE IP&#x2F;netmask [up] 使用ifconfig命令配置ip地址，临时配置ip地址，将网卡down掉或重启网络后丢失。</span><br><span class="line">		ifconfig IFACE IP netmask NETMASK </span><br><span class="line">	注意：ifconfig命令修改后立即生效</span><br><span class="line">	启用混杂模式：[-]promisc</span><br><span class="line">	配置网卡别名，实现一个网卡绑定多个ip：</span><br><span class="line">		ifconfig eth1:2 ip </span><br><span class="line">		如果不想要了，使用ifdown eth1:2 即可删掉该ip</span><br></pre></td></tr></table></figure>

<p>route命令：路由管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看路由表：</span><br><span class="line">		route -n</span><br><span class="line">	添加路由：</span><br><span class="line">		route add </span><br><span class="line">			route add [-net|-host] target [netmask Nm] [gw Gw] [[dev] if]</span><br><span class="line">				网关必须和主机ip在同一网段才可行。</span><br><span class="line">			for example:</span><br><span class="line">				目标： 192.168.1.3 网关：172.16.0.1</span><br><span class="line">					route add -host 192.168.1.3 gw 172.16.0.1 dev eth0</span><br><span class="line">				目标：192.168.0.0 网关：172.16.0.1</span><br><span class="line">					route add -net 192.168.0.0&#x2F;24 gw 172.16.0.1 dev eth0</span><br><span class="line">			添加默认路由，网关：172.16.0.1</span><br><span class="line">				route add default gw 172.16.0.1</span><br><span class="line">	删除路由：</span><br><span class="line">		route del </span><br><span class="line">			route del [-net|-host] target [gw Gw] [netmask Nm] [[dev] if]</span><br><span class="line">				for example:</span><br><span class="line">			 	目标：192.168.1.3 网关：172.16.0.1</span><br><span class="line">				 		route del -host 192.168.1.3</span><br><span class="line">				 	目标：192.168.0.0 网关：172.16.0.1</span><br><span class="line">				 		route del -net 192.168.0.0&#x2F;24		</span><br><span class="line">		配置动态路由：</span><br><span class="line">			通过安装守护进程获取动态路由：</span><br><span class="line">				安装quagga包</span><br><span class="line">				支持多种路由协议：RIP OSPF BGP</span><br><span class="line">				命令vtysh配置</span><br></pre></td></tr></table></figure>

<p>网络连接管理及查看相关命令：<br>显示网络连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat [--tcp|-t] [--udp|-u] [--raw|-w] [--listening|-l] [--all|-a] [--numeric|-n] [--extend|-e] [--progam|-p]</span><br><span class="line">	-t:tcp相关协议</span><br><span class="line">	-u:udp相关协议</span><br><span class="line">	-w：raw socket相关</span><br><span class="line">	-l：处于坚挺状态</span><br><span class="line">	-a：所有状态</span><br><span class="line">	-n：以数字显示IP和端口</span><br><span class="line">	-e：扩展格式</span><br><span class="line">	-p：显示相关进程及PID</span><br><span class="line">	常用组合：</span><br><span class="line">		-tan， -uan， -tnl， -unl </span><br><span class="line">	显示路由表：</span><br><span class="line">		netstat -rn </span><br><span class="line">			-r:显示内核路由表</span><br><span class="line">			-n：以数字格式显示IP和端口</span><br><span class="line">	显示接口统计数据：</span><br><span class="line">		netstat &#123;--interface|-i|-I&#125; [iface] [--all|-a] [--extend|-e] [--program|-p] [--numeric|-n]</span><br><span class="line">		netstat -i</span><br><span class="line">		netstat -I&#x3D;IFACE</span><br><span class="line">		ifconfig -s eth0</span><br></pre></td></tr></table></figure>

<p>配置linux网络属性：ip命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip - show &#x2F; manipulate routing,devices,policy routing and tunnels</span><br><span class="line">	ip [options] OBJECT &#123;COMMAND|HELP&#125;</span><br><span class="line">		OBJECT:&#x3D;&#123;link|addr|route&#125;</span><br><span class="line">	ip link - network device configration </span><br><span class="line">		set dev IFACE</span><br><span class="line">			可设置属性：</span><br><span class="line">				up and down:激活或禁用指定接口</span><br><span class="line">					ifup&#x2F;ifdown</span><br><span class="line">		show [dev IFACE] : 指定接口</span><br><span class="line">				[up]:仅显示处于激活状态的接口</span><br><span class="line">	ip addr &#123;add|del&#125; IFADDR dev STRING</span><br><span class="line">		[label LABEL]:添加地址时指明网卡别名</span><br><span class="line">		[scope &#123;global|link|host&#125;]:指明作用域</span><br><span class="line">			global:全局可用</span><br><span class="line">			link:仅链接可用</span><br><span class="line">			host:本机可用</span><br><span class="line">		[broadcast ADDRESS]:指明广播地址</span><br><span class="line">	ip address show - look at protocal addresses</span><br><span class="line">		[dev DEVICE]</span><br><span class="line">		[label PATTERN]</span><br><span class="line">		[primary and secondary]</span><br><span class="line">	ip address flush - 使用格式同show</span><br><span class="line">	例如：</span><br><span class="line">		ip addr add 172.16.100.100&#x2F;16 dev ens33 label ens33:0</span><br><span class="line">		ip addr del 172.16.100.100&#x2F;16 dev ens33 label ens33:0</span><br><span class="line">		ip addr flush dev ens33 label ens33:0</span><br><span class="line">ip route - routing table management</span><br><span class="line">	添加路由：ip route add </span><br><span class="line">	ip route add TARGET via GW dev IFACE src SOURCE_IP</span><br><span class="line">		TARGET:</span><br><span class="line">			主机路由：IP</span><br><span class="line">			网络路由：NETWORK&#x2F;MASK</span><br><span class="line">		例如：</span><br><span class="line">			ip route add 192.168.0.0&#x2F;24 via 172.16.0.1</span><br><span class="line">			ip route add 192.168.1.13 via 172.16.0.1</span><br><span class="line">	添加网关： ip route add default via GW dev IFACE</span><br><span class="line">		例如：</span><br><span class="line">			ip route add default via 172.16.0.1</span><br><span class="line">	删除路由：ip route del TARGET</span><br><span class="line">	显示路由：ip route show|list </span><br><span class="line">	清空路由表：ip route flush [dev IFACE] [via PREFIX]</span><br><span class="line">		例如：</span><br><span class="line">			ip route flush dev eth0</span><br></pre></td></tr></table></figure>

<p>ss命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ss [option]... [FILTER]</span><br><span class="line">netstat通过遍历proc来获取socket信息，ss使用netlink与内核tcp_diag模块通信获取socket信息。</span><br><span class="line">选项：</span><br><span class="line">	-t:tcp协议相关</span><br><span class="line">	-u：udp协议相关</span><br><span class="line">	-w：裸套接字相关</span><br><span class="line">	-x：unix sock相关</span><br><span class="line">	-l：listen状态的链接</span><br><span class="line">	-a：所有 </span><br><span class="line">	-n：数字格式 </span><br><span class="line">	-p：相关的程序及PID</span><br><span class="line">	-e：扩展的内存信息</span><br><span class="line">	-m：内存用量</span><br><span class="line">	-o：计时器信息</span><br><span class="line">FILTER：[state TCP-STATE] [EXPRESSION]</span><br><span class="line">	TCP常见的状态有：</span><br><span class="line">	tcp finite state machine:</span><br><span class="line">		LISTEN:监听</span><br><span class="line">		ESTABLISHED:已建立的连接</span><br><span class="line">		FIN_WAIT_1</span><br><span class="line">		FIN_WAIT_2</span><br><span class="line">		SYN-SENT</span><br><span class="line">		SYN-RECV</span><br><span class="line">		CLOSED</span><br><span class="line">	EXPRESSION：</span><br><span class="line">		dport&#x3D;</span><br><span class="line">		sport&#x3D;</span><br><span class="line">		示例：&#39;(dport&#x3D;:ssh or sport&#x3D;:ssh)&#39;</span><br><span class="line">	常见组合：</span><br><span class="line">		-tan -tanl -tanlp -uan </span><br><span class="line">常见用法：</span><br><span class="line">	ss -l 显示本地打开的所有端口</span><br><span class="line">	ss -pl 显示内个进程具体打开的socket</span><br><span class="line">	ss -t -a 显示所有tcp socket </span><br><span class="line">	ss -u -a 显示所有的UDP Socket </span><br><span class="line">	ss -o state established &#39;(dport&#x3D;:ssh or sport&#x3D;:ssh)&#39; 显示所有已建立的ssh连接</span><br><span class="line">	ss -o state established &#39;(dport&#x3D;:http or sport&#x3D;:http)&#39; 显示所有已建立的http连接</span><br><span class="line">	ss -s 列出当前socket详细信息</span><br></pre></td></tr></table></figure>

<p>网络配置文件： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP MASK GW DNS相关配置文件：</span><br><span class="line">	&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-IFACE</span><br><span class="line">		说明参考：&#x2F;usr&#x2F;share&#x2F;doc&#x2F;initscripts-9.49.30&#x2F;sysconfig.txt</span><br><span class="line">			DEVICE:此配置文件应用到的设备</span><br><span class="line">			HWADDR：对应的设备的MAC地址</span><br><span class="line">			BOOTPROTO：激活此设备时使用的地址配置协议，常用的有dhcp static none bootp</span><br><span class="line">			NM_CONTROLLED:NM是NetworkManager的简写，此网卡是否接受NM控制；建议centos6为“no”</span><br><span class="line">			ONBOOT:在系统引导时是否激活此设备</span><br><span class="line">			TYPE：接口类型，常见的有Ethernet,Bridge</span><br><span class="line">			UUID:设备的唯一标识</span><br><span class="line">			IPADDR：指明ip地址</span><br><span class="line">			NETMASK：子网掩码</span><br><span class="line">			GATEWAY：默认网关</span><br><span class="line">			DNS1：第一个DNS服务器指向</span><br><span class="line">			DNS2：第二个DNS服务器的指向</span><br><span class="line">			USERCTL：普通用户是否可控制此设备</span><br><span class="line">			PEERDNS：如果BOOTPROTO的值为dhcp，是否允许dhcp server分配的dns服务器指向信息直接覆盖至&#x2F;etc&#x2F;resolv.conf文件中</span><br></pre></td></tr></table></figure>

<p>网络配置文件模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		动态配置： </span><br><span class="line">			DEVICE&#x3D;ethX</span><br><span class="line">			HWADDR&#x3D;</span><br><span class="line">			BOOTPROTO&#x3D;dhcp </span><br><span class="line">			ONBOOT&#x3D;yes</span><br><span class="line">			TYPE&#x3D;Ethernet </span><br><span class="line">		静态配置：</span><br><span class="line">			DEVICE&#x3D;ethX</span><br><span class="line">			HWADDR&#x3D;</span><br><span class="line">			BOOTPROTO&#x3D;static </span><br><span class="line">			ONBOOT&#x3D;yes</span><br><span class="line">			TYPE&#x3D;Ethernet </span><br><span class="line">			IPADDR&#x3D;ip</span><br><span class="line">			NETMASK&#x3D;netmask</span><br><span class="line">			GATEWAY&#x3D;gw</span><br><span class="line">&#96;&#96;&#96;	</span><br><span class="line"></span><br><span class="line">路由相关配置文件：</span><br><span class="line">		&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;route-IFACE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主机名和本地解析器：</span><br><span class="line">	配置当前的主机名：</span><br><span class="line">		hstname HOSTNAME </span><br><span class="line">		&#x2F;etc&#x2F;sysconfig&#x2F;network </span><br><span class="line">			HOSTNAME&#x3D;</span><br><span class="line">	解析器执行正向和逆向查询</span><br><span class="line">	&#x2F;etc&#x2F;hosts</span><br><span class="line">		本地主机名数据库和IP地址的映像</span><br><span class="line">		对小型独立网络有用</span><br><span class="line">		通常，在使用DNS前检查</span><br><span class="line">		getent hosts 查看&#x2F;etc&#x2F;hosts内容</span><br><span class="line">DNS名字解析：</span><br><span class="line">	&#x2F;etc&#x2F;resolv.conf </span><br><span class="line">		namaserver DNS_SERVER_IP1</span><br><span class="line">		nameserver DNS_SERVER_IP2</span><br><span class="line">		nameserver DNS_SERVER_IP3</span><br><span class="line">		serch magedu.com </span><br><span class="line">	&#x2F;etc&#x2F;nsswitch.conf </span><br><span class="line">		与&#x2F;etc&#x2F;hosts相比优先于DNS</span><br><span class="line">	正向解析：FQDN--&gt;IP</span><br><span class="line">		dig -t A FQDN </span><br><span class="line">		host -t A FQDN </span><br><span class="line">	反向解析：IP--&gt;FQDN</span><br><span class="line">		dig -x IP</span><br><span class="line">		host -t FTR IP </span><br><span class="line">网络配置文件： </span><br><span class="line">	&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;route-IFACE</span><br><span class="line">		注意：需service network restart生效</span><br><span class="line">		两种配置风格：</span><br><span class="line">			1、TARGET via GW </span><br><span class="line">				如：10.0.0.0&#x2F;8 via 172.16.0.1</span><br><span class="line">			2、每三行定义一条路由</span><br><span class="line">				ADDRESS#&#x3D;TARGET</span><br><span class="line">				NETMASK#&#x3D;mask</span><br><span class="line">				GATEWAY#&#x3D;GW</span><br><span class="line">网卡别名：</span><br><span class="line">	对虚拟主机有用</span><br><span class="line">	将多个IP地址绑定到一个NIC上</span><br><span class="line">		eth0:1 eth0:2 eth0:3</span><br><span class="line">	ifconfig命令：</span><br><span class="line">		ifconfig eth0:0 192.168.1.100&#x2F;24 up </span><br><span class="line">		ifconfig eth0:0 down</span><br><span class="line">	ip命令：</span><br><span class="line">		ip addr add 172.16.1.2&#x2F;16 dev eth0</span><br><span class="line">		ip addr add 172.16.1.1&#x2F;16 dev eth0 label eth0:0</span><br><span class="line">		ip addr add 172.16.1.2&#x2F;16 dev eth0 label eth0:0</span><br><span class="line">		ip addr del 172.16.1.1&#x2F;16 dev eth0 label eth0:0</span><br><span class="line">		ip addr flush dev eth0 label eth0:0</span><br><span class="line">设备别名：</span><br><span class="line">	为每个设备别名生成独立的接口配置文件</span><br><span class="line">		关闭NetworkManager服务</span><br><span class="line">		ifcfg-ethX:xxx</span><br><span class="line">		必须使用静态联网</span><br><span class="line">			DEVICE&#x3D;eth0:0</span><br><span class="line">			IPADDR&#x3D;10.10.10.10</span><br><span class="line">			NETMASK&#x3D;255.0.0.0</span><br><span class="line">			ONPARENT&#x3D;yes</span><br><span class="line">		注意：service network restart生效</span><br><span class="line">		参考：&#x2F;usr&#x2F;share&#x2F;doc&#x2F;initscripts-* &#x2F;sysconfig.txt</span><br><span class="line">网络接口配置-bonding</span><br><span class="line">bonding</span><br></pre></td></tr></table></figure>
<pre><code>将多块网卡绑定同一IP地址对外提供服务，可以实现高可用或者负载均衡。直接给两块网卡设置同一IP地址是不可以的，
通过bonding，虚拟一块网卡对外提供链接，物理网卡被修改为相同的MAC地址。</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bonding的工作模式：</span><br></pre></td></tr></table></figure>
<pre><code>Mode0（balance-rr）
    轮转（Round-robin）策略：从头到尾顺序的在每个slave接口上面发送数据包。
    本模式提供负载均衡和容错能力。
Mode1（active-backup）
    活动-备份（主备）策略：只有一个slave被激活，当且仅当活动的slave接口失败时才会激活其他slave。
    为了避免交换机发生混乱此时绑定的MAC地址只有一个外部端口上可见。
Mode3(broadcast)
    广播策略：在所有的slave接口上传送所有的报文，提供容错能力
active-backup、balance-tlb 和 balance-alb 模式不需要交换机的任何特
殊配置。其他绑定模式需要配置交换机以便整合链接。如：Cisco 交换机需
要在模式 0、2 和 3 中使用 EtherChannel，但在模式4中需要 LACP和
EtherChannel</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bonding的配置：</span><br><span class="line">&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-bond0</span><br><span class="line">&#96;&#96;&#96;	</span><br><span class="line">	DEVICE&#x3D;bond0 </span><br><span class="line">	BOOTPROTO&#x3D;none</span><br><span class="line">	BONDING_OPTS&#x3D;&quot;miimon&#x3D;100 mode&#x3D;0&quot;</span><br></pre></td></tr></table></figure>

<p>/etc/sysconfig/network-scripts/ifcfg-eth0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEVICE&#x3D;eth0 </span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">MASTER&#x3D;bond0 </span><br><span class="line">SLAVE&#x3D;yes</span><br><span class="line">USERCTL&#x3D;no</span><br></pre></td></tr></table></figure>
<p>miimon 是用来进行链路检测的。如果miimon=100，name系统每100ms监测一次链路连接状态，如果有一条线路不通就转入另一条线路。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看bond0状态：</span><br><span class="line">	&#x2F;proc&#x2F;net&#x2F;bonding&#x2F;bond0 </span><br><span class="line">删除bond0：</span><br><span class="line">	ifconfig bond0 down</span><br><span class="line">	rmmod bonding</span><br><span class="line">详细帮助：</span><br><span class="line">	&#x2F;usr&#x2F;share&#x2F;doc&#x2F;kernel-doc- version&#x2F;Documentation&#x2F;networking&#x2F;bonding.txt</span><br><span class="line">	https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;networking&#x2F;bonding.txt</span><br></pre></td></tr></table></figure>
<p>centos7网络属性配置：<br>    centos6之前，网络接口使用连续号码命名：</p>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql入门之多实例实现和增删改查</title>
    <url>/2017/10/15/mysql%E5%85%A5%E9%97%A8%E4%B9%8B%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="mysql多实例实现"><a href="#mysql多实例实现" class="headerlink" title="mysql多实例实现"></a>mysql多实例实现</h2><p>此实验是在基于源码编译安装mariadb之后进行的，如果不知道如何安装，请移步<em>mysql入门之安装</em>篇<br><strong>数据库安装目录为/app/mysql/</strong></p>
<h4 id="创建多实例数据库的数据库目录和配置目录等相关目录"><a href="#创建多实例数据库的数据库目录和配置目录等相关目录" class="headerlink" title="创建多实例数据库的数据库目录和配置目录等相关目录"></a>创建多实例数据库的数据库目录和配置目录等相关目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible data]<span class="comment">#mkdir /mysql/330&#123;6,7,8&#125;/&#123;etc,data,log,socket,pid&#125; -p</span></span><br><span class="line">[root@ansible data]<span class="comment">#tree /mysql/</span></span><br><span class="line">/mysql/</span><br><span class="line">├── 3306</span><br><span class="line">│   ├── data</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── <span class="built_in">log</span></span><br><span class="line">│   ├── pid</span><br><span class="line">│   └── socket</span><br><span class="line">├── 3307</span><br><span class="line">│   ├── data</span><br><span class="line">│   ├── etc</span><br><span class="line">│   ├── <span class="built_in">log</span></span><br><span class="line">│   ├── pid</span><br><span class="line">│   └── socket</span><br><span class="line">└── 3308</span><br><span class="line">    ├── data</span><br><span class="line">    ├── etc</span><br><span class="line">    ├── <span class="built_in">log</span></span><br><span class="line">    ├── pid</span><br><span class="line">    └── socket</span><br></pre></td></tr></table></figure>

<h4 id="准备数据库文件"><a href="#准备数据库文件" class="headerlink" title="准备数据库文件"></a>准备数据库文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cd /app/mysql/</span></span><br><span class="line">[root@ansible mysql]<span class="comment">#./scripts/mysql_install_db --datadir=/mysql/3306/data/ --user=mysql</span></span><br><span class="line">[root@ansible mysql]<span class="comment">#./scripts/mysql_install_db --datadir=/mysql/3307/data/ --user=mysql</span></span><br><span class="line">[root@ansible mysql]<span class="comment">#./scripts/mysql_install_db --datadir=/mysql/3308/data/ --user=mysql</span></span><br></pre></td></tr></table></figure>

<h4 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h4><p><strong>将配置文件放到上述规划的etc目录下，并将端口分别改为相应的端口，将socket文件地址指向相应的socket</strong><br>以使用3307端口的实例配置为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#sed -n '/^[^#]/p' 3307/etc/my.cnf </span></span><br><span class="line">[mysqld]</span><br><span class="line">port=3307</span><br><span class="line">datadir=/mysql/3307/data/</span><br><span class="line">socket=/mysql/3307/socket/mysql.sock</span><br><span class="line">innodb_file_per_table</span><br><span class="line">symbolic-links=0</span><br><span class="line">[mysqld_safe]</span><br><span class="line"><span class="built_in">log</span>-error=/mysql/3307/<span class="built_in">log</span>/mariadb.log</span><br><span class="line">pid-file=/mysql/3307/pid/mariadb.pid</span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure>

<h4 id="将-mysql目录的所有者和所属组改为mysql"><a href="#将-mysql目录的所有者和所属组改为mysql" class="headerlink" title="将/mysql目录的所有者和所属组改为mysql"></a>将/mysql目录的所有者和所属组改为mysql</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#chown -R mysql.mysql /mysql</span></span><br></pre></td></tr></table></figure>

<h4 id="准备启动脚本"><a href="#准备启动脚本" class="headerlink" title="准备启动脚本"></a>准备启动脚本</h4><p>以使用3307端口的实例配置为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cat /mysql/3306/mysqld </span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#chkconfig: 345 80 2</span></span><br><span class="line">port=3307</span><br><span class="line">mysql_user=<span class="string">"root"</span></span><br><span class="line">mysql_pwd=<span class="string">"137226"</span></span><br><span class="line">cmd_path=<span class="string">"/app/mysql/bin"</span></span><br><span class="line">mysql_basedir=<span class="string">"/mysql"</span></span><br><span class="line">mysql_sock=<span class="string">"<span class="variable">$&#123;mysql_basedir&#125;</span>/<span class="variable">$&#123;port&#125;</span>/socket/mysql.sock"</span></span><br><span class="line"></span><br><span class="line">function_start_mysql()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="string">"<span class="variable">$mysql_sock</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">      <span class="built_in">printf</span> <span class="string">"Starting MySQL...\n"</span></span><br><span class="line">      <span class="variable">$&#123;cmd_path&#125;</span>/mysqld_safe --defaults-file=<span class="variable">$&#123;mysql_basedir&#125;</span>/<span class="variable">$&#123;port&#125;</span>/etc/my.cnf  &amp;&gt; /dev/null  &amp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span> <span class="string">"MySQL is running...\n"</span></span><br><span class="line">      <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_stop_mysql()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ ! -e <span class="string">"<span class="variable">$mysql_sock</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">       <span class="built_in">printf</span> <span class="string">"MySQL is stopped...\n"</span></span><br><span class="line">       <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">printf</span> <span class="string">"Stoping MySQL...\n"</span></span><br><span class="line">       <span class="variable">$&#123;cmd_path&#125;</span>/mysqladmin -u <span class="variable">$&#123;mysql_user&#125;</span> -p<span class="variable">$&#123;mysql_pwd&#125;</span> -S <span class="variable">$&#123;mysql_sock&#125;</span> shutdown</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_restart_mysql()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"Restarting MySQL...\n"</span></span><br><span class="line">    function_stop_mysql</span><br><span class="line">    sleep 2</span><br><span class="line">    function_start_mysql</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    function_start_mysql</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">    function_stop_mysql</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">    function_restart_mysql</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"Usage: <span class="variable">$&#123;mysql_basedir&#125;</span>/<span class="variable">$&#123;port&#125;</span>/bin/mysqld &#123;start|stop|restart&#125;\n"</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h4 id="将服务脚本加入系统管理服务"><a href="#将服务脚本加入系统管理服务" class="headerlink" title="将服务脚本加入系统管理服务"></a>将服务脚本加入系统管理服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cp /mysql/3306/mysqld /etc/init.d/mysqld3306</span></span><br><span class="line">[root@ansible ~]<span class="comment">#cp /mysql/3307/mysqld /etc/init.d/mysqld3307</span></span><br><span class="line">[root@ansible ~]<span class="comment">#cp /mysql/3308/mysqld /etc/init.d/mysqld3308</span></span><br><span class="line">[root@ansible ~]<span class="comment">#chkconfig --add mysqld3306</span></span><br><span class="line">[root@ansible ~]<span class="comment">#chkconfig --add mysqld3307</span></span><br><span class="line">[root@ansible ~]<span class="comment">#chkconfig --add mysqld3308</span></span><br><span class="line">[root@ansible ~]<span class="comment">#chkconfig --list</span></span><br><span class="line"></span><br><span class="line">Note: This output shows SysV services only and does not include native</span><br><span class="line">      systemd services. SysV configuration data might be overridden by native</span><br><span class="line">      systemd configuration.</span><br><span class="line"></span><br><span class="line">      If you want to list systemd services use <span class="string">'systemctl list-unit-files'</span>.</span><br><span class="line">      To see services enabled on particular target use</span><br><span class="line">      <span class="string">'systemctl list-dependencies [target]'</span>.</span><br><span class="line"></span><br><span class="line">mysqld         	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br><span class="line">mysqld3306     	0:off	1:off	2:off	3:on	4:on	5:on	6:off</span><br><span class="line">mysqld3307     	0:off	1:off	2:off	3:on	4:on	5:on	6:off</span><br><span class="line">mysqld3308     	0:off	1:off	2:off	3:on	4:on	5:on	6:off</span><br><span class="line">netconsole     	0:off	1:off	2:off	3:off	4:off	5:off	6:off</span><br><span class="line">network        	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br></pre></td></tr></table></figure>

<h4 id="开启服务并连接"><a href="#开启服务并连接" class="headerlink" title="开启服务并连接"></a>开启服务并连接</h4><p>以3307端口实例演示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#service mysqld3307 start</span></span><br><span class="line">Starting MySQL...</span><br><span class="line">[root@ansible ~]<span class="comment">#mysql -S /mysql/3307/socket/mysql.sock </span></span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 8</span><br><span class="line">Server version: 10.2.19-MariaDB Source distribution</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure>

<h4 id="mysql安全加固"><a href="#mysql安全加固" class="headerlink" title="mysql安全加固"></a>mysql安全加固</h4><p>以3307端口实例为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#mysql_secure_installation -S /mysql/3307/socket/mysql.sock</span></span><br></pre></td></tr></table></figure>
<p>此时，mysql数据库的多实例已经完成。</p>
<h2 id="mysql数据库之增删改查"><a href="#mysql数据库之增删改查" class="headerlink" title="mysql数据库之增删改查"></a>mysql数据库之增删改查</h2><p><strong>以下内容只展示命令，不展示执行结果，不然显得太过臃肿，结果可以在测试机自行测试</strong></p>
<h3 id="数据库和表管理"><a href="#数据库和表管理" class="headerlink" title="数据库和表管理"></a>数据库和表管理</h3><p><strong>关于字符集，强烈推荐使用utf8mb4字符集</strong><br>修改数据库实例的字符集方法为：在配置文件mysqld语句块中添加character-set-server=utf8mb4<br>修改客户端字符集的方法为：在配置文件mysql语句块添加default-character-set=utf8mb4<br>建议在配置文件中mysqld语句块中写入innodb_file_per_table语句，将每个表的数据单独存放，降低风险。</p>
<h4 id="创建数据库create-database"><a href="#创建数据库create-database" class="headerlink" title="创建数据库create database"></a>创建数据库create database</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name</span><br><span class="line">    [create_specification] ...</span><br><span class="line"></span><br><span class="line">create_specification:</span><br><span class="line">    [DEFAULT] CHARACTER SET [&#x3D;] charset_name</span><br><span class="line">  | [DEFAULT] COLLATE [&#x3D;] collation_name</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; create database db_utf8mb4 character <span class="built_in">set</span> utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>查看mariadb支持的字符集</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show character <span class="built_in">set</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; drop database testdb;</span><br></pre></td></tr></table></figure>

<h4 id="创建表-CREATE-TABLE"><a href="#创建表-CREATE-TABLE" class="headerlink" title="创建表 CREATE TABLE"></a>创建表 CREATE TABLE</h4><p>(1) 直接创建<br>(2) 通过查询现存表创建；新表会被直接插入查询而来的数据<br>  CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,…)] [table_options] [partition_options] select_statement<br>(3) 通过复制现存的表的表结构创建，但不复制数据<br>  CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name { LIKE old_tbl_name | (LIKE old_tbl_name) }<br>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Storage Engine是指表类型，也即在表创建时指明其使用的存储引擎，同一库中不同表可以使用不同的存储引擎</span><br><span class="line">同一个库中表建议要使用同一种存储引擎类型</span><br></pre></td></tr></table></figure>

<p><strong>字段的数据类型</strong><br>1、整型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tinyint(m) 1个字节 范围(-128~127)</span><br><span class="line">smallint(m) 2个字节 范围(-32768~32767)</span><br><span class="line">mediumint(m) 3个字节 范围(-8388608~8388607)</span><br><span class="line">int(m) 4个字节 范围(-2147483648~2147483647)</span><br><span class="line">bigint(m) 8个字节 范围(+-9.22x10的18次方)</span><br></pre></td></tr></table></figure>

<p>2、浮点型(float和double)，近似值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位</span><br><span class="line">double(m,d) 双精度浮点型16位精度(8字节) m总个数，d小数位</span><br><span class="line">设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位</span><br></pre></td></tr></table></figure>

<p>3、定点数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在数据库中存放的是精确值,存为十进制</span><br><span class="line">decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位</span><br><span class="line">MySQL5.0和更高版本将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。例如，decimal(18,9)小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节</span><br><span class="line">浮点类型在存储同样范围的值时，通常比decimal使用更少的空间。float使用4个字节存储。double占用8个字节</span><br><span class="line">因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用decimal——例如存储财务数据。但在数据量比较大的时候，可以考虑使用bigint代替decimal</span><br></pre></td></tr></table></figure>

<p><em>4、字符串(char,varchar,_text)</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char(n) 固定长度，最多255个字符</span><br><span class="line">varchar(n) 可变长度，最多65535个字符</span><br><span class="line">tinytext 可变长度，最多255个字符</span><br><span class="line">text 可变长度，最多65535个字符</span><br><span class="line">mediumtext 可变长度，最多2的24次方-1个字符</span><br><span class="line">longtext 可变长度，最多2的32次方-1个字符</span><br><span class="line">BINARY(M) 固定长度，可存二进制或字符，长度为0-M字节</span><br><span class="line">VARBINARY(M) 可变长度，可存二进制或字符，允许长度为0-M字节</span><br><span class="line">内建类型：ENUM枚举, SET集合</span><br></pre></td></tr></table></figure>

<p><strong>char和varchar：</strong><br>• 1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉，<br>所以char类型存储的字符串末尾不能有空格，varchar不限于此<br>• 2.char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar<br>是存入的实际字符数+1个字节（n&lt; n&gt;255)，所以varchar(4),存入3个字符将<br>占用4个字节<br>• 3.char类型的字符串检索速度要比varchar类型的快<br>varchar和text：<br>• 1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个<br>字节（n&lt; n&gt;255)，text是实际字符数+2个字节。<br>• 2.text类型不能有默认值<br>• 3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速<br>度快于text</p>
<p>5.二进制数据：BLOB<br>• BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，<br>而Blob是以二进制方式存储，不分大小写<br>• BLOB存储的数据只能整体读出<br>• TEXT可以指定字符集，BLOB不用指定字符集<br>6.日期时间类型<br>• date 日期 ‘2008-12-2’<br>• time 时间 ‘12:25:36’<br>• datetime 日期时间 ‘2008-12-2 22:06:44’<br>• timestamp 自动存储记录修改时间<br>• YEAR(2), YEAR(4)：年份<br> timestamp字段里的时间数据会随其他字段修改的时候自动刷新，这个数<br>据类型的字段可以存放这条记录最后被修改的时间</p>
<p><strong>修饰符</strong><br>所有类型：<br>• NULL 数据列可包含NULL值<br>• NOT NULL 数据列不允许包含NULL值<br>• DEFAULT 默认值<br>• PRIMARY KEY 主键<br>• UNIQUE KEY 唯一键<br>• CHARACTER SET name 指定一个字符集<br>数值型<br>• AUTO_INCREMENT 自动递增，适用于整数类型<br>• UNSIGNED 无符号</p>
<p><strong>创建表</strong><br>直接创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table student (id int unsigned auto_increment primary key ,name varchar(10),sex enum(<span class="string">'f'</span>,<span class="string">'m'</span>) default <span class="string">'m'</span>,age tinyint unsigned,mobile char(11),address varchar(50));</span><br></pre></td></tr></table></figure>

<p>克隆另一张表，并且会将模板表的数据一起克隆</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; create table employee select * from student;</span><br></pre></td></tr></table></figure>

<p>克隆另一张表的表结构，但不克隆表中数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; create table custom like student;</span><br></pre></td></tr></table></figure>

<p><strong>查看表结构</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; desc student;</span><br><span class="line">MariaDB [studentdb]&gt; show columns from student;</span><br></pre></td></tr></table></figure>

<p><strong>查看表定义</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; show create table student;</span><br></pre></td></tr></table></figure>

<p><strong>查看表的信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; show table status like <span class="string">'student'</span>\G;</span><br></pre></td></tr></table></figure>

<p><strong>查看某个数据库中的所有表的信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; show table status from database_name\G;</span><br></pre></td></tr></table></figure>

<p><strong>删除表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; drop table student;</span><br></pre></td></tr></table></figure>

<h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><h5 id="修改表结构alter"><a href="#修改表结构alter" class="headerlink" title="修改表结构alter"></a>修改表结构alter</h5><p>ALTER TABLE ‘tbl_name’<br>字段：<br>    添加字段：add<br>      ADD col1 data_type [FIRST|AFTER col_name]<br>    删除字段：drop<br>    修改字段：<br>      alter（默认值）, change（字段名）, modify（字段属性）<br>索引:<br>    添加索引：add index<br>    删除索引：drop index<br>表选项<br>    修改:<br>查看表上的索引：SHOW INDEXES FROM [db_name.]tbl_name;<br>查看帮助：Help ALTER TABLE</p>
<p><strong>更改字符集</strong><br>更改库/表字符集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [db_utf8mb4]&gt; alter database/table name character <span class="built_in">set</span> = utf8mb4;</span><br></pre></td></tr></table></figure>

<p>更改字段的字符集</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [db_utf8mb4]&gt; alter table table_name change column_name column_name_new character <span class="built_in">set</span> utf8mb4</span><br></pre></td></tr></table></figure>

<p><strong>查看表状态</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [db_utf8mb4]&gt; show table status like <span class="string">'student'</span>\G;</span><br></pre></td></tr></table></figure>
<h5 id="为表增加记录insert"><a href="#为表增加记录insert" class="headerlink" title="为表增加记录insert"></a>为表增加记录insert</h5><p><strong>语法</strong><br>第一种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name [(col_name,...)]</span><br><span class="line">    &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...),(...),...</span><br><span class="line">    [ ON DUPLICATE KEY UPDATE</span><br><span class="line">      col_name&#x3D;expr</span><br><span class="line">        [, col_name&#x3D;expr] ... ]</span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    SET col_name&#x3D;&#123;expr | DEFAULT&#125;, ...</span><br><span class="line">    [ ON DUPLICATE KEY UPDATE</span><br><span class="line">      col_name&#x3D;expr</span><br><span class="line">        [, col_name&#x3D;expr] ... ]</span><br></pre></td></tr></table></figure>
<p>第三种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name [(col_name,...)]</span><br><span class="line">    SELECT ...fffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">    [ ON DUPLICATE KEY UPDATE</span><br><span class="line">      col_name&#x3D;expr</span><br><span class="line">        [, col_name&#x3D;expr] ... ]</span><br></pre></td></tr></table></figure>
<p><strong>查看表中的记录数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; select count(*) from student;</span><br></pre></td></tr></table></figure>

<p><strong>向表中添加记录</strong><br>使用第一种方法添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; insert into student (name,age,mobile,adress)values(<span class="string">'msq'</span>,26,15244059931,<span class="string">'shandong'</span>),(<span class="string">'yfq'</span>,27,15065002205,<span class="string">'shandong'</span>);</span><br></pre></td></tr></table></figure>

<p>使用第二种方法添加（不常用）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; insert into student <span class="built_in">set</span> name=<span class="string">'mjc'</span>,age=1,address=<span class="string">'shandong'</span>;</span><br></pre></td></tr></table></figure>

<p>使用第三种方法添加，批量查询并将查询的结果插入另一个表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; insert into custom select * from student;</span><br></pre></td></tr></table></figure>
<h5 id="删除表中的记录-delete"><a href="#删除表中的记录-delete" class="headerlink" title="删除表中的记录 delete"></a>删除表中的记录 delete</h5><p><strong>删除表中的记录时，一定要加限定条件，否则会清空整个表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; delete from student <span class="built_in">where</span> id=4;</span><br></pre></td></tr></table></figure>

<p><strong>清空表中的数据，但保留表的结构</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; truncate table student;</span><br></pre></td></tr></table></figure>

<h5 id="更改表中的记录-update"><a href="#更改表中的记录-update" class="headerlink" title="更改表中的记录 update"></a>更改表中的记录 update</h5><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_reference</span><br><span class="line"> SET col_name1&#x3D;&#123;expr1|DEFAULT&#125; [, col_name2&#x3D;&#123;expr2|DEFAULT&#125;] ...</span><br><span class="line"> [WHERE where_condition]</span><br><span class="line"> [ORDER BY ...]</span><br><span class="line"> [LIMIT row_count]</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; update student(table_name) <span class="built_in">set</span> name=<span class="string">'zsf'</span> <span class="built_in">where</span> id=2;</span><br></pre></td></tr></table></figure>
<p><strong>由于更改表中的记录时，容易出错，建议在客户端连接时加上-U|–safe-updates|–i-am-a-dummy选项，或者直接在配置文件mysql语句块中机上safe-updates</strong></p>
<h2 id="查找数据库的内容"><a href="#查找数据库的内容" class="headerlink" title="查找数据库的内容"></a>查找数据库的内容</h2><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">[ALL | DISTINCT | DISTINCTROW ]</span><br><span class="line">[SQL_CACHE | SQL_NO_CACHE]</span><br><span class="line">select_expr [, select_expr ...]</span><br><span class="line"> [FROM table_references</span><br><span class="line"> [WHERE where_condition]</span><br><span class="line"> [GROUP BY &#123;col_name | expr | position&#125;</span><br><span class="line"> [ASC | DESC], ... [WITH ROLLUP]]</span><br><span class="line"> [HAVING where_condition]</span><br><span class="line"> [ORDER BY &#123;col_name | expr | position&#125;</span><br><span class="line"> [ASC | DESC], ...]</span><br><span class="line"> [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line"> [FOR UPDATE | LOCK IN SHARE MODE]</span><br></pre></td></tr></table></figure>

<p><strong>字段显示可以使用别名：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">col1 AS alias1, col2 AS alias2, ...</span><br></pre></td></tr></table></figure>

<p><strong>WHERE子句：指明过滤条件以实现“选择”的功能：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过滤条件：布尔型表达式</span><br><span class="line">算术操作符：+, -, **, &#x2F;, % </span><br><span class="line">比较操作符：&#x3D;,&lt;&#x3D;&gt;（相等或都为空）, &lt;&gt;, !&#x3D;(非标准SQL), &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</span><br><span class="line">BETWEEN min_num AND max_num ：在min_num与max_num之间的范围</span><br><span class="line">IN (element1, element2, ...)：单个散列值</span><br><span class="line">IS NULL：找出空值</span><br><span class="line">IS NOT NULL：找出非空值</span><br></pre></td></tr></table></figure>

<p><strong>模糊匹配：</strong><br>搜索名字列以m开头的记录，但是尽可能不要使用模糊匹配，会降低服务器性能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; select * from student <span class="built_in">where</span> name like <span class="string">'m%'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GROUP：根据指定的条件把查询结果进行“分组”以用于做“聚合”运算</span><br><span class="line">  avg(), max(), min(), count(), sum()</span><br><span class="line">HAVING: 对分组聚合运算后的结果指定过滤条件</span><br><span class="line">ORDER BY: 根据指定的字段对查询结果进行排序</span><br><span class="line">  升序：ASC</span><br><span class="line">  降序：DESC</span><br><span class="line">LIMIT [[offset,]row_count]：对查询的结果进行输出行数数量限制</span><br><span class="line">对查询结果中的数据请求施加“锁”</span><br><span class="line">  FOR UPDATE: 写锁，独占或排它锁，只有一个读和写</span><br><span class="line">  LOCK IN SHARE MODE: 读锁，共享锁，同时多个读</span><br></pre></td></tr></table></figure>

<h3 id="select单表查询"><a href="#select单表查询" class="headerlink" title="select单表查询"></a>select单表查询</h3><p><strong>使用distinct可以对查找到的结果进行去重，之后再显示。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [studentdb]&gt; select distinct sex  from student;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| sex  |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| m    |</span><br><span class="line">| f    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [studentdb]&gt; <span class="keyword">select</span>  sex  <span class="keyword">from</span> student;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| sex  |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| m    |</span><br><span class="line">| m    |</span><br><span class="line">| m    |</span><br><span class="line">| f    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>导入测试数据库用于练习</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#mysql -p -S /mysql/3307/socket/mysql.sock &lt; hellodb_innodb.sql</span></span><br></pre></td></tr></table></figure>

<p>用于测试的表格如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ariaDB [hellodb]&gt; select * from students;</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+</span></span><br><span class="line">| StuID | Name          | Age | Gender | ClassID | TeacherID |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+</span></span><br><span class="line">|     1 | Shi Zhongyu   |  22 | M      |       2 |         3 |</span><br><span class="line">|     2 | Shi Potian    |  22 | M      |       1 |         7 |</span><br><span class="line">|     3 | Xie Yanke     |  53 | M      |       2 |        16 |</span><br><span class="line">|     4 | Ding Dian     |  32 | M      |       4 |         4 |</span><br><span class="line">|     5 | Yu Yutong     |  26 | M      |       3 |         1 |</span><br><span class="line">|     6 | Shi Qing      |  46 | M      |       5 |      NULL |</span><br><span class="line">|     7 | Xi Ren        |  19 | F      |       3 |      NULL |</span><br><span class="line">|     8 | Lin Daiyu     |  17 | F      |       7 |      NULL |</span><br><span class="line">|     9 | Ren Yingying  |  20 | F      |       6 |      NULL |</span><br><span class="line">|    10 | Yue Lingshan  |  19 | F      |       3 |      NULL |</span><br><span class="line">|    11 | Yuan Chengzhi |  23 | M      |       6 |      NULL |</span><br><span class="line">|    12 | Wen Qingqing  |  19 | F      |       1 |      NULL |</span><br><span class="line">|    13 | Tian Boguang  |  33 | M      |       2 |      NULL |</span><br><span class="line">|    14 | Lu Wushuang   |  17 | F      |       3 |      NULL |</span><br><span class="line">|    15 | Duan Yu       |  19 | M      |       4 |      NULL |</span><br><span class="line">|    16 | Xu Zhu        |  21 | M      |       1 |      NULL |</span><br><span class="line">|    17 | Lin Chong     |  25 | M      |       4 |      NULL |</span><br><span class="line">|    18 | Hua Rong      |  23 | M      |       7 |      NULL |</span><br><span class="line">|    19 | Xue Baochai   |  18 | F      |       6 |      NULL |</span><br><span class="line">|    20 | Diao Chan     |  19 | F      |       7 |      NULL |</span><br><span class="line">|    21 | Huang Yueying |  22 | F      |       6 |      NULL |</span><br><span class="line">|    22 | Xiao Qiao     |  20 | F      |       1 |      NULL |</span><br><span class="line">|    23 | Ma Chao       |  23 | M      |       4 |      NULL |</span><br><span class="line">|    24 | Xu Xian       |  27 | M      |    NULL |      NULL |</span><br><span class="line">|    25 | Sun Dasheng   | 100 | M      |    NULL |      NULL |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>从中选出性别为女的人</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students where gender &lt;&gt; 'm'; #或者where gender = f;</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+</span></span><br><span class="line">| StuID | Name          | Age | Gender | ClassID | TeacherID |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+</span></span><br><span class="line">|     7 | Xi Ren        |  19 | F      |       3 |      NULL |</span><br><span class="line">|     8 | Lin Daiyu     |  17 | F      |       7 |      NULL |</span><br><span class="line">|     9 | Ren Yingying  |  20 | F      |       6 |      NULL |</span><br><span class="line">|    10 | Yue Lingshan  |  19 | F      |       3 |      NULL |</span><br><span class="line">|    12 | Wen Qingqing  |  19 | F      |       1 |      NULL |</span><br><span class="line">|    14 | Lu Wushuang   |  17 | F      |       3 |      NULL |</span><br><span class="line">|    19 | Xue Baochai   |  18 | F      |       6 |      NULL |</span><br><span class="line">|    20 | Diao Chan     |  19 | F      |       7 |      NULL |</span><br><span class="line">|    21 | Huang Yueying |  22 | F      |       6 |      NULL |</span><br><span class="line">|    22 | Xiao Qiao     |  20 | F      |       1 |      NULL |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>统计表中记录的总数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select gender,count(gender) from students;</span><br><span class="line">+<span class="comment">--------+---------------+</span></span><br><span class="line">| gender | count(gender) |</span><br><span class="line">+<span class="comment">--------+---------------+</span></span><br><span class="line">| M      |            25 |</span><br><span class="line">+<span class="comment">--------+---------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>分组：group by</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GROUP：根据指定的条件把查询结果进行“分组”以用于做“聚合”运算</span><br><span class="line">avg(), max(), min(), count(), sum()</span><br><span class="line">HAVING: 对分组聚合运算后的结果指定过滤条件</span><br></pre></td></tr></table></figure>

<p><strong>统计表中男性和女性人数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MMariaDB [hellodb]&gt; select gender 性别,count(*) 人数 from students group by gender;</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">| 性别   | 人数   |</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br><span class="line">| F      |     10 |</span><br><span class="line">| M      |     15 |</span><br><span class="line">+<span class="comment">--------+--------+</span></span><br></pre></td></tr></table></figure>

<p><strong>分组：统计每个班的人数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select classid,count(*) from students group by classid;</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">| classid | count(*) |</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">|    NULL |        2 |</span><br><span class="line">|       1 |        4 |</span><br><span class="line">|       2 |        3 |</span><br><span class="line">|       3 |        4 |</span><br><span class="line">|       4 |        4 |</span><br><span class="line">|       5 |        1 |</span><br><span class="line">|       6 |        4 |</span><br><span class="line">|       7 |        3 |</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>多次分组：统计每个班的男生和女生人数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select classid,gender,max(age) from students group by classid,gender;</span><br><span class="line">+<span class="comment">---------+--------+----------+</span></span><br><span class="line">| classid | gender | max(age) |</span><br><span class="line">+<span class="comment">---------+--------+----------+</span></span><br><span class="line">|    NULL | M      |      100 |</span><br><span class="line">|       1 | F      |       20 |</span><br><span class="line">|       1 | M      |       22 |</span><br><span class="line">|       2 | M      |       53 |</span><br><span class="line">|       3 | F      |       19 |</span><br><span class="line">|       3 | M      |       26 |</span><br><span class="line">|       4 | M      |       32 |</span><br><span class="line">|       5 | M      |       46 |</span><br><span class="line">|       6 | F      |       22 |</span><br><span class="line">|       6 | M      |       23 |</span><br><span class="line">|       7 | F      |       19 |</span><br><span class="line">|       7 | M      |       23 |</span><br><span class="line">+<span class="comment">---------+--------+----------+</span></span><br></pre></td></tr></table></figure>




<p><strong>分别统计男女平均年龄</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select gender 性别,avg(age) 平均年龄 from students group by gender;</span><br><span class="line">+<span class="comment">--------+--------------+</span></span><br><span class="line">| 性别   | 平均年龄     |</span><br><span class="line">+<span class="comment">--------+--------------+</span></span><br><span class="line">| F      |      19.0000 |</span><br><span class="line">| M      |      33.0000 |</span><br><span class="line">+<span class="comment">--------+--------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>只统计女生的平均年龄</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select gender,avg(gender) from students group by gender having gender = 'M';</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line">| gender | avg(gender) |</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line">| M      |      2.0000 |</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select gender,avg(gender) from students where gender = 'm' group by gender;</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line">| gender | avg(gender) |</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br><span class="line">| M      |      2.0000 |</span><br><span class="line">+<span class="comment">--------+-------------+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select gender,avg(age) from students where gender='M';</span><br><span class="line">+<span class="comment">--------+----------+</span></span><br><span class="line">| gender | avg(age) |</span><br><span class="line">+<span class="comment">--------+----------+</span></span><br><span class="line">| M      |  33.0000 |</span><br><span class="line">+<span class="comment">--------+----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>统计班级号大于3的班级每个班年龄大于30岁的学生的人数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select classid,count(*) from students where age &gt; 30 group by classid having classid &gt; 3;</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">| classid | count(*) |</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">|       4 |        1 |</span><br><span class="line">|       5 |        1 |</span><br><span class="line">+<span class="comment">---------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>ORDER BY: 根据指定的字段对查询结果进行排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">升序：ASC</span><br><span class="line">降序：DESC</span><br></pre></td></tr></table></figure>

<p><strong>对学生表中的学生排序,并显示年龄最小的前三个学生</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students order by age limit 3;</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+</span></span><br><span class="line">| StuID | Name        | Age | Gender | ClassID | TeacherID |</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+</span></span><br><span class="line">|    14 | Lu Wushuang |  17 | F      |       3 |      NULL |</span><br><span class="line">|     8 | Lin Daiyu   |  17 | F      |       7 |      NULL |</span><br><span class="line">|    19 | Xue Baochai |  18 | F      |       6 |      NULL |</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>对学生表中的学生排序,跳过年龄最小的前三个学生，并显示之后的四个学生</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students order by age limit 3,4;+-------+--------------+-----+--------+---------+-----------+</span><br><span class="line">| StuID | Name         | Age | Gender | ClassID | TeacherID |</span><br><span class="line">+<span class="comment">-------+--------------+-----+--------+---------+-----------+</span></span><br><span class="line">|    15 | Duan Yu      |  19 | M      |       4 |      NULL |</span><br><span class="line">|    12 | Wen Qingqing |  19 | F      |       1 |      NULL |</span><br><span class="line">|    10 | Yue Lingshan |  19 | F      |       3 |      NULL |</span><br><span class="line">|     7 | Xi Ren       |  19 | F      |       3 |      NULL |</span><br><span class="line">+<span class="comment">-------+--------------+-----+--------+---------+-----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>对表中班级排序后对年龄倒序</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students order by -classid desc,age desc;</span><br></pre></td></tr></table></figure>

<h3 id="select多表查询"><a href="#select多表查询" class="headerlink" title="select多表查询"></a>select多表查询</h3><h4 id="两个表交叉查询"><a href="#两个表交叉查询" class="headerlink" title="两个表交叉查询"></a>两个表交叉查询</h4><p><strong>新增一张表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from teachers;</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br><span class="line">| TID | Name          | Age | Gender |</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br><span class="line">|   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|   2 | Zhang Sanfeng |  94 | M      |</span><br><span class="line">|   3 | Miejue Shitai |  77 | F      |</span><br><span class="line">|   4 | Lin Chaoying  |  93 | F      |</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br></pre></td></tr></table></figure>

<p><strong>使用union将students表和teachers表纵向合并</strong><br>union具有自动去重的效果，类似distinct取唯一值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select stuid,name,age,gender from students union select * from teachers;</span><br></pre></td></tr></table></figure>

<p><strong>将s、t两张表交叉连接，cross join</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students cross join teachers;</span><br></pre></td></tr></table></figure>

<h5 id="取两个表的交集-内连接"><a href="#取两个表的交集-内连接" class="headerlink" title="取两个表的交集:内连接"></a><strong>取两个表的交集:内连接</strong></h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students s,teachers t where  s.teacherid=t.tid;</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br><span class="line">| StuID | Name        | Age | Gender | ClassID | TeacherID | TID | Name          | Age | Gender |</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br><span class="line">|     5 | Yu Yutong   |  26 | M      |       3 |         1 |   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|     1 | Shi Zhongyu |  22 | M      |       2 |         3 |   3 | Miejue Shitai |  77 | F      |</span><br><span class="line">|     4 | Ding Dian   |  32 | M      |       4 |         4 |   4 | Lin Chaoying  |  93 | F      |</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br></pre></td></tr></table></figure>

<p>较新的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students s inner join teachers t on s.teacherid=t.tid;</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br><span class="line">| StuID | Name        | Age | Gender | ClassID | TeacherID | TID | Name          | Age | Gender |</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br><span class="line">|     5 | Yu Yutong   |  26 | M      |       3 |         1 |   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|    25 | Sun Dasheng | 100 | M      |    NULL |         1 |   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|     1 | Shi Zhongyu |  22 | M      |       2 |         3 |   3 | Miejue Shitai |  77 | F      |</span><br><span class="line">|     4 | Ding Dian   |  32 | M      |       4 |         4 |   4 | Lin Chaoying  |  93 | F      |</span><br><span class="line">+<span class="comment">-------+-------------+-----+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br></pre></td></tr></table></figure>

<p><strong>取两个表的内连接的特定字段</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select classid,s.name,stuid,t.name,tid from students s inner join teachers t on t.tid=s.teacherid;</span><br><span class="line">+<span class="comment">---------+-------------+-------+---------------+-----+</span></span><br><span class="line">| classid | name        | stuid | name          | tid |</span><br><span class="line">+<span class="comment">---------+-------------+-------+---------------+-----+</span></span><br><span class="line">|       3 | Yu Yutong   |     5 | Song Jiang    |   1 |</span><br><span class="line">|    NULL | Sun Dasheng |    25 | Song Jiang    |   1 |</span><br><span class="line">|       2 | Shi Zhongyu |     1 | Miejue Shitai |   3 |</span><br><span class="line">|       4 | Ding Dian   |     4 | Lin Chaoying  |   4 |</span><br><span class="line">+<span class="comment">---------+-------------+-------+---------------+-----+</span></span><br></pre></td></tr></table></figure>

<h5 id="左外连接：取出A表的全部记录以及B表中符合条件的记录。"><a href="#左外连接：取出A表的全部记录以及B表中符合条件的记录。" class="headerlink" title="左外连接：取出A表的全部记录以及B表中符合条件的记录。"></a>左外连接：取出A表的全部记录以及B表中符合条件的记录。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students s left outer join teachers t on s.teacherid=t.tid;</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+------+---------------+------+--------+</span></span><br><span class="line">| StuID | Name          | Age | Gender | ClassID | TeacherID | TID  | Name          | Age  | Gender |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+------+---------------+------+--------+</span></span><br><span class="line">|     1 | Shi Zhongyu   |  22 | M      |       2 |         3 |    3 | Miejue Shitai |   77 | F      |</span><br><span class="line">|     2 | Shi Potian    |  22 | M      |       1 |         7 | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     3 | Xie Yanke     |  53 | M      |       2 |        16 | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     4 | Ding Dian     |  32 | M      |       4 |         4 |    4 | Lin Chaoying  |   93 | F      |</span><br><span class="line">|     5 | Yu Yutong     |  26 | M      |       3 |         1 |    1 | Song Jiang    |   45 | M      |</span><br><span class="line">|     6 | Shi Qing      |  46 | M      |       5 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     7 | Xi Ren        |  19 | F      |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     8 | Lin Daiyu     |  17 | F      |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     9 | Ren Yingying  |  20 | F      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    10 | Yue Lingshan  |  19 | F      |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    11 | Yuan Chengzhi |  23 | M      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    12 | Wen Qingqing  |  19 | F      |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    13 | Tian Boguang  |  33 | M      |       2 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    14 | Lu Wushuang   |  17 | F      |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    15 | Duan Yu       |  19 | M      |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    16 | Xu Zhu        |  21 | M      |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    17 | Lin Chong     |  25 | M      |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    18 | Hua Rong      |  23 | M      |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    19 | Xue Baochai   |  18 | F      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    20 | Diao Chan     |  19 | F      |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    21 | Huang Yueying |  22 | F      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    22 | Xiao Qiao     |  20 | F      |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    23 | Ma Chao       |  23 | M      |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    24 | Xu Xian       |  27 | M      |    NULL |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    25 | Sun Dasheng   | 100 | M      |    NULL |         1 |    1 | Song Jiang    |   45 | M      |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+------+---------------+------+--------+</span></span><br></pre></td></tr></table></figure>

<h5 id="右外连接：取出B表的全部记录以及A表中符合条件的记录。"><a href="#右外连接：取出B表的全部记录以及A表中符合条件的记录。" class="headerlink" title="右外连接：取出B表的全部记录以及A表中符合条件的记录。"></a>右外连接：取出B表的全部记录以及A表中符合条件的记录。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students s right outer join teachers t on s.teacherid=t.tid;</span><br><span class="line">+<span class="comment">-------+-------------+------+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br><span class="line">| StuID | Name        | Age  | Gender | ClassID | TeacherID | TID | Name          | Age | Gender |</span><br><span class="line">+<span class="comment">-------+-------------+------+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br><span class="line">|     1 | Shi Zhongyu |   22 | M      |       2 |         3 |   3 | Miejue Shitai |  77 | F      |</span><br><span class="line">|     4 | Ding Dian   |   32 | M      |       4 |         4 |   4 | Lin Chaoying  |  93 | F      |</span><br><span class="line">|     5 | Yu Yutong   |   26 | M      |       3 |         1 |   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|    25 | Sun Dasheng |  100 | M      |    NULL |         1 |   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|  NULL | NULL        | NULL | NULL   |    NULL |      NULL |   2 | Zhang Sanfeng |  94 | M      |</span><br><span class="line">+<span class="comment">-------+-------------+------+--------+---------+-----------+-----+---------------+-----+--------+</span></span><br></pre></td></tr></table></figure>

<h5 id="取出只在A表不在B表中的记录"><a href="#取出只在A表不在B表中的记录" class="headerlink" title="取出只在A表不在B表中的记录"></a>取出只在A表不在B表中的记录</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students s left join teachers t on s.teacherid=t.tid where tid is null;</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+------+------+------+--------+</span></span><br><span class="line">| StuID | Name          | Age | Gender | ClassID | TeacherID | TID  | Name | Age  | Gender |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+------+------+------+--------+</span></span><br><span class="line">|     2 | Shi Potian    |  22 | M      |       1 |         7 | NULL | NULL | NULL | NULL   |</span><br><span class="line">|     3 | Xie Yanke     |  53 | M      |       2 |        16 | NULL | NULL | NULL | NULL   |</span><br><span class="line">|     6 | Shi Qing      |  46 | M      |       5 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|     7 | Xi Ren        |  19 | F      |       3 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|     8 | Lin Daiyu     |  17 | F      |       7 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|     9 | Ren Yingying  |  20 | F      |       6 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    10 | Yue Lingshan  |  19 | F      |       3 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    11 | Yuan Chengzhi |  23 | M      |       6 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    12 | Wen Qingqing  |  19 | F      |       1 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    13 | Tian Boguang  |  33 | M      |       2 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    14 | Lu Wushuang   |  17 | F      |       3 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    15 | Duan Yu       |  19 | M      |       4 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    16 | Xu Zhu        |  21 | M      |       1 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    17 | Lin Chong     |  25 | M      |       4 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    18 | Hua Rong      |  23 | M      |       7 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    19 | Xue Baochai   |  18 | F      |       6 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    20 | Diao Chan     |  19 | F      |       7 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    21 | Huang Yueying |  22 | F      |       6 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    22 | Xiao Qiao     |  20 | F      |       1 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    23 | Ma Chao       |  23 | M      |       4 |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">|    24 | Xu Xian       |  27 | M      |    NULL |      NULL | NULL | NULL | NULL | NULL   |</span><br><span class="line">+<span class="comment">-------+---------------+-----+--------+---------+-----------+------+------+------+--------+</span></span><br></pre></td></tr></table></figure>

<h5 id="取出只在B中不在A中的记录"><a href="#取出只在B中不在A中的记录" class="headerlink" title="取出只在B中不在A中的记录"></a>取出只在B中不在A中的记录</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select t.* from students s right join teachers t on s.teacherid=t.tid where s.teacherid is null;</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br><span class="line">| TID | Name          | Age | Gender |</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br><span class="line">|   2 | Zhang Sanfeng |  94 | M      |</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br></pre></td></tr></table></figure>

<h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p><strong>选出年龄大于学生平均年龄的老师的记录</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from teachers where age &gt; (select avg(age) from students);</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br><span class="line">| TID | Name          | Age | Gender |</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br><span class="line">|   1 | Song Jiang    |  45 | M      |</span><br><span class="line">|   2 | Zhang Sanfeng |  94 | M      |</span><br><span class="line">|   3 | Miejue Shitai |  77 | F      |</span><br><span class="line">|   4 | Lin Chaoying  |  93 | F      |</span><br><span class="line">+<span class="comment">-----+---------------+-----+--------+</span></span><br></pre></td></tr></table></figure>

<h5 id="完全外连接-左外连接union右外连接"><a href="#完全外连接-左外连接union右外连接" class="headerlink" title="完全外连接:左外连接union右外连接"></a>完全外连接:左外连接union右外连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from students s left outer join teachers t  on s.teacherid=t.tid union select * from students s right outer join teachers t on s.teacherid=t.tid;</span><br><span class="line">+<span class="comment">-------+---------------+------+--------+---------+-----------+------+---------------+------+--------+</span></span><br><span class="line">| StuID | Name          | Age  | Gender | ClassID | TeacherID | TID  | Name          | Age  | Gender |</span><br><span class="line">+<span class="comment">-------+---------------+------+--------+---------+-----------+------+---------------+------+--------+</span></span><br><span class="line">|     1 | Shi Zhongyu   |   22 | M      |       2 |         3 |    3 | Miejue Shitai |   77 | F      |</span><br><span class="line">|     2 | Shi Potian    |   22 | M      |       1 |         7 | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     3 | Xie Yanke     |   53 | M      |       2 |        16 | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     4 | Ding Dian     |   32 | M      |       4 |         4 |    4 | Lin Chaoying  |   93 | F      |</span><br><span class="line">|     5 | Yu Yutong     |   26 | M      |       3 |         1 |    1 | Song Jiang    |   45 | M      |</span><br><span class="line">|     6 | Shi Qing      |   46 | M      |       5 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     7 | Xi Ren        |   19 | F      |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     8 | Lin Daiyu     |   17 | F      |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     9 | Ren Yingying  |   20 | F      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    10 | Yue Lingshan  |   19 | F      |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    11 | Yuan Chengzhi |   23 | M      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    12 | Wen Qingqing  |   19 | F      |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    13 | Tian Boguang  |   33 | M      |       2 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    14 | Lu Wushuang   |   17 | F      |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    15 | Duan Yu       |   19 | M      |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    16 | Xu Zhu        |   21 | M      |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    17 | Lin Chong     |   25 | M      |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    18 | Hua Rong      |   23 | M      |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    19 | Xue Baochai   |   18 | F      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    20 | Diao Chan     |   19 | F      |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    21 | Huang Yueying |   22 | F      |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    22 | Xiao Qiao     |   20 | F      |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    23 | Ma Chao       |   23 | M      |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    24 | Xu Xian       |   27 | M      |    NULL |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    25 | Sun Dasheng   |  100 | M      |    NULL |         1 |    1 | Song Jiang    |   45 | M      |</span><br><span class="line">|  NULL | NULL          | NULL | NULL   |    NULL |      NULL |    2 | Zhang Sanfeng |   94 | M      |</span><br><span class="line">+<span class="comment">-------+---------------+------+--------+---------+-----------+------+---------------+------+--------+</span></span><br></pre></td></tr></table></figure>

<h5 id="取A、B并集去除交集的部分"><a href="#取A、B并集去除交集的部分" class="headerlink" title="取A、B并集去除交集的部分"></a>取A、B并集去除交集的部分</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; select * from (select stuid,s.name student_name,s.age student_age,s.gender student_gender,classid,teacherid,tid,t.name,t.age,t.gender from students s left outer join teachers t on s.teacherid=t.tid union select * from students s right outer join teachers t on s.teacherid=t.tid) f where f.teacherid is null or f.tid is null;</span><br><span class="line">+<span class="comment">-------+---------------+-------------+----------------+---------+-----------+------+---------------+------+--------+</span></span><br><span class="line">| stuid | student_name  | student_age | student_gender | classid | teacherid | tid  | name          | age  | gender |</span><br><span class="line">+<span class="comment">-------+---------------+-------------+----------------+---------+-----------+------+---------------+------+--------+</span></span><br><span class="line">|     2 | Shi Potian    |          22 | M              |       1 |         7 | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     3 | Xie Yanke     |          53 | M              |       2 |        16 | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     6 | Shi Qing      |          46 | M              |       5 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     7 | Xi Ren        |          19 | F              |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     8 | Lin Daiyu     |          17 | F              |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|     9 | Ren Yingying  |          20 | F              |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    10 | Yue Lingshan  |          19 | F              |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    11 | Yuan Chengzhi |          23 | M              |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    12 | Wen Qingqing  |          19 | F              |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    13 | Tian Boguang  |          33 | M              |       2 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    14 | Lu Wushuang   |          17 | F              |       3 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    15 | Duan Yu       |          19 | M              |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    16 | Xu Zhu        |          21 | M              |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    17 | Lin Chong     |          25 | M              |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    18 | Hua Rong      |          23 | M              |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    19 | Xue Baochai   |          18 | F              |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    20 | Diao Chan     |          19 | F              |       7 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    21 | Huang Yueying |          22 | F              |       6 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    22 | Xiao Qiao     |          20 | F              |       1 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    23 | Ma Chao       |          23 | M              |       4 |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|    24 | Xu Xian       |          27 | M              |    NULL |      NULL | NULL | NULL          | NULL | NULL   |</span><br><span class="line">|  NULL | NULL          |        NULL | NULL           |    NULL |      NULL |    2 | Zhang Sanfeng |   94 | M      |</span><br><span class="line">+<span class="comment">-------+---------------+-------------+----------------+---------+-----------+------+---------------+------+--------+</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>基于proxysql实现mysql读写分离</title>
    <url>/2017/10/07/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>读写分离应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql-proxy：Oracle，https:&#x2F;&#x2F;downloads.mysql.com&#x2F;archives&#x2F;proxy&#x2F;</span><br><span class="line">Atlas：Qihoo，https:&#x2F;&#x2F;github.com&#x2F;Qihoo360&#x2F;Atlas&#x2F;blob&#x2F;master&#x2F;README_ZH.md</span><br><span class="line">dbproxy：美团，https:&#x2F;&#x2F;github.com&#x2F;Meituan-Dianping&#x2F;DBProxy</span><br><span class="line">Cetus：网易乐得，https:&#x2F;&#x2F;github.com&#x2F;Lede-Inc&#x2F;cetus</span><br><span class="line">Amoeba：https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;amoeba&#x2F;</span><br><span class="line">Cobar：阿里巴巴，Amoeba的升级版</span><br><span class="line">Mycat：基于Cobar， http:&#x2F;&#x2F;www.mycat.io&#x2F;</span><br><span class="line">ProxySQL：https:&#x2F;&#x2F;proxysql.com&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="ProxySQL"><a href="#ProxySQL" class="headerlink" title="ProxySQL"></a>ProxySQL</h2><p>ProxySQL：MySQL中间件，两个版本：官方版和percona版，percona版是基于官方版基础上修改，C++语言开发，轻量级但是性能优异（支持处理千亿级数据），具有中间件所需的绝大多数功能，包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多种方式的读&#x2F;写分离</span><br><span class="line">定制基于用户、基于schema、基于语句的规则对SQL语句进行路由</span><br><span class="line">缓存查询结果</span><br><span class="line">后端节点监控</span><br></pre></td></tr></table></figure>

<p>官方站点：<a href="https://proxysql.com/" target="_blank" rel="noopener">https://proxysql.com/</a><br>官方手册：<a href="https://github.com/sysown/proxysql/wiki" target="_blank" rel="noopener">https://github.com/sysown/proxysql/wiki</a></p>
<p><strong>proxysql安装方法</strong></p>
<ol>
<li><p>基于yum安装proxysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat &lt;&lt;EOF | tee /etc/yum.repos.d/proxysql.repo</span></span><br><span class="line">[proxysql_repo]</span><br><span class="line">name= ProxySQL YUM repository</span><br><span class="line">baseurl=http://repo.proxysql.com/ProxySQL/proxysql-1.4.x/centos/\<span class="variable">$releasever</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://repo.proxysql.com/ProxySQL/repo_pub_key</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于RPM下载安装<br><a href="https://github.com/sysown/proxysql/releases" target="_blank" rel="noopener">https://github.com/sysown/proxysql/releases</a></p>
</li>
</ol>
<p><strong>ProxySQL组成</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务脚本：&#x2F;etc&#x2F;init.d&#x2F;proxysql</span><br><span class="line">配置文件：&#x2F;etc&#x2F;proxysql.cnf</span><br><span class="line">主程序：&#x2F;usr&#x2F;bin&#x2F;proxysql</span><br></pre></td></tr></table></figure>

<h3 id="proxy实现读写分离"><a href="#proxy实现读写分离" class="headerlink" title="proxy实现读写分离"></a>proxy实现读写分离</h3><ol>
<li><p>实现读写分离之前，先实现主从复制<br> 注意：slave节点需要设置read_only=1</p>
</li>
<li><p>启动ProxySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#service proxysql start</span></span><br></pre></td></tr></table></figure>
<p>启动后，会默认监听两个端口<br> 6032：proxysql的管理端口<br> 6033：proxysql对外提供服务的端口</p>
</li>
<li><p>使用mysql客户端连接到proxysql的管理端口6032，默认管理员用户和密码都是admin：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mysql -uadmin -padmin -P6032 -h127.0.0.1</span></span><br></pre></td></tr></table></figure>
<p>说明：在main和monitor数据库中的表， runtime_开头的是运行时的配置，不能修改，只能修改非runtime_表，修改后必须执行LOAD … TO RUNTIME才能加载到RUNTIME生效，执行save … to disk将配置持久化保存到磁盘</p>
</li>
<li><p>向proxysql中添加所有mysql节点，以下操作不需要use main也可成功</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MySQL &gt; select * from mysql_servers;</span><br><span class="line">MySQL &gt; insert into mysql_servers(hostgroup_id,hostname,port)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">10</span>,<span class="string">'192.168.34.17'</span>,<span class="number">3306</span>);</span><br><span class="line">MySQL &gt; insert into mysql_servers(hostgroup_id,hostname,port)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">10</span>,<span class="string">'192.168.34.27'</span>,<span class="number">3306</span>);</span><br><span class="line">MySQL &gt; load mysql servers to runtime;</span><br><span class="line">MySQL &gt; save mysql servers to disk;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加监控后端节点的用户，proxysql通过每个节点的read_only值来自动调整它们是属于读组还是写组。</p>
</li>
</ol>
<p><strong>在master上添加监控用户</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MySQL &gt; grant replication client on *.* to monitor@'192.168.34.%' identified by 'centos';</span><br></pre></td></tr></table></figure>

<p><strong>在proxysql上配置监控用户</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt; set mysql-monitor_username='monitor';</span><br><span class="line">MySQL [(none)]&gt; set mysql-monitor_password='magedu';</span><br></pre></td></tr></table></figure>

<p><strong>加载到RUNTIME，并保存到disk</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt; load mysql variables to runtime;</span><br><span class="line">MySQL [(none)]&gt; save mysql variables to disk;</span><br></pre></td></tr></table></figure>

<p>此时，监控模块的指标保存在monitor库的log表中<br>查看监控连接是否正常（对connect指标的监控）：（如果connect_error的结果为NULL则表示正常）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from mysql_server_connect_log;</span><br></pre></td></tr></table></figure>

<p>查看监控心跳信息（对ping指标的监控）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from mysql_server_ping_log;</span><br></pre></td></tr></table></figure>

<p>查看read_only和replication_lag的监控日志：(此时应该为空)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from mysql_server_read_only_log;</span><br><span class="line">mysql&gt; select * from mysql_server_replication_lag_log;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>设置分组信息<br>需要修改的是main库中的mysql_replication_hostgroups表，该表有3个字段：<br>writer_hostgroup，reader_hostgroup，comment, 指定写组的id为10，读组的id为20<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; insert into mysql_replication_hostgroups values(10,20,"test");</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>将mysql_replication_hostgroups表的修改加载到RUNTIME生效</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; load mysql servers to runtime;</span><br><span class="line">mysql &gt; save mysql servers to disk;</span><br></pre></td></tr></table></figure>

<p>Monitor模块监控后端的read_only值，按照read_only的值将节点自动移动到读/写组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql &gt; select hostgroup_id,hostname,port,status,weight from mysql_servers;</span><br><span class="line">+<span class="comment">--------------+--------------+------+--------+--------+</span></span><br><span class="line">| hostgroup_id | hostname | port | status | weight |</span><br><span class="line">+<span class="comment">--------------+--------------+------+--------+--------+</span></span><br><span class="line">| 10 | 192.168.34.17 | 3306 | ONLINE | 1 |</span><br><span class="line">| 20 | 192.168.34.27 | 3306 | ONLINE | 1 |</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>配置发送sql语句的用户</li>
</ol>
<p><strong>在master节点上创建访问用户</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; grant all on *.* to sqluser@'192.168.8.%' identified by 'centos';</span><br></pre></td></tr></table></figure>

<p><strong>在ProxySQL配置，将用户sqluser添加到mysql_users表中， default_hostgroup默认组设置为写组10，当读写分离的路由规则不符合时，会访问默认组的数据库</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; insert into mysql_users(username,password,default_hostgroup) values('sqluser','magedu',10);</span><br><span class="line">mysql &gt; load mysql users to runtime;</span><br><span class="line">mysql &gt; save mysql users to disk;</span><br></pre></td></tr></table></figure>

<p><strong>使用sqluser用户测试是否能路由到默认的10写组实现读、写数据</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'select @@server_id'</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'create database testdb'</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'use testdb;create table t(id</span></span><br><span class="line">int)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>配置路由规则，实现读写分离<br>与规则有关的表：mysql_query_rules和mysql_query_rules_fast_routing，后者是前者的扩展表，1.4.7之后支持</li>
</ol>
<p>插入路由规则：将select语句分离到20的读组，select语句中有一个特殊语句SELECT…FOR UPDATE它会申请写锁，应路由到10的写组</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; insert into mysql_query_rules</span><br><span class="line">&gt; (rule_id,active,match_digest,destination_hostgroup,apply)VALUES</span><br><span class="line">&gt; (1,1,'^SELECT.*FOR UPDATE$',10,1),(2,1,'^SELECT',20,1);</span><br><span class="line">mysql &gt;load mysql query rules to runtime;</span><br><span class="line">mysql &gt;save mysql query rules to disk;</span><br></pre></td></tr></table></figure>
<p>注意：因proxysql根据rule_id顺序进行规则匹配，select … for update规则的rule_id必须要小于普通的select规则的rule_id</p>
<p>至此，已经实现mysql的读写分离</p>
<ol start="9">
<li>测试读写分离是否成功<br>测试读操作是否路由给20的读组<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'select @@server_id'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>测试写操作，以事务方式进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'start transaction;select @@server_id;commit;select @@server_id'</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'insert testdb.t values (1)'</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mysql -usqluser -pmagedu -P6033 -h127.0.0.1 -e 'select id from testdb.t'</span></span><br></pre></td></tr></table></figure>

<p>路由的信息：查询stats库中的stats_mysql_query_digest表</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql &gt; SELECT hostgroup hg,sum_time, count_star, digest_text FROM stats_mysql_query_digest ORDER BY sum_time DESC;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mariadb入门之安装</title>
    <url>/2017/09/20/mysql%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>由于mysql面临闭源风险，而且centos7默认预装mariadb，所以本次博客使用mariadb来做示范，且mariadb和mysql并无实质区别，都是同一个人写的</strong></p>
<h2 id="编译安装mariadb"><a href="#编译安装mariadb" class="headerlink" title="编译安装mariadb"></a>编译安装mariadb</h2><p><strong>先安装mariadb的相关依赖包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#yum install bison bison-devel zlib-devel libcurl-devel libarchive-devel boostdeve</span></span><br></pre></td></tr></table></figure>

<p><strong>创建相关用户和数据目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#uaeradd -r -s /sbin/nologin -d /data/mysql mysql</span></span><br><span class="line">[root@ansible ~]<span class="comment">#mkdir /data/mysql</span></span><br><span class="line">[root@ansible ~]<span class="comment">#chown mysql.mysql /data/mysql</span></span><br></pre></td></tr></table></figure>


<p><strong>到官方网站下载mariadb源码包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#wget -p tools/ https://downloads.mariadb.org/interstitial/mariadb-10.3.11/source/mariadb-10.3.11.tar.gz/from/http%3A//mirrors.neusoft.edu.cn/mariadb/mariadb-10.2.19.tar.gz</span></span><br></pre></td></tr></table></figure>

<p><strong>解压源码包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cd tools/</span></span><br><span class="line">[root@ansible ~]<span class="comment">#tar xf mariadb-10.2.19.tar.gz</span></span><br><span class="line">[root@ansible ~]<span class="comment">#cd mariadb-10.2.19</span></span><br></pre></td></tr></table></figure>

<p><strong>执行编译安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mriadb-10.2.19]<span class="comment">#cmake . \</span></span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/app/mysql \</span><br><span class="line">-DMYSQL_DATADIR=/data/mysql/ \</span><br><span class="line">-DSYSCONFDIR=/etc \</span><br><span class="line">-DMYSQL_USER=mysql \</span><br><span class="line">-DWITH_INNOBASE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_ARCHIVE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_PARTITION_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITHOUT_MROONGA_STORAGE_ENGINE=1 \</span><br><span class="line">-DWITH_DEBUG=0 \</span><br><span class="line">-DWITH_READLINE=1 \</span><br><span class="line">-DWITH_SSL=system \</span><br><span class="line">-DWITH_ZLIB=system \</span><br><span class="line">-DWITH_LIBWRAP=0 \</span><br><span class="line">-DENABLED_LOCAL_INFILE=1 \</span><br><span class="line">-DMYSQL_UNIX_ADDR=/data/mysql/mysql.sock \</span><br><span class="line">-DDEFAULT_CHARSET=utf8 \</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mriadb-10.2.19]<span class="comment">#make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>

<p><strong>准备环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'PATH=/app/mysql/bin:$PATH'</span> &gt; /etc/profile.d/mysql.sh</span><br></pre></td></tr></table></figure>

<p><strong>生成数据库文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cd /app/mysql</span></span><br><span class="line">[root@ansible mysql]<span class="comment">#./scripts/mysql_install_db --datadir=/data/mysql/ --user=mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>准备配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#cp /app/mysql/support-files/my-huge.cnf /etc/my.cnf</span></span><br></pre></td></tr></table></figure>

<p><strong>准备启动脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#cp /app/mysql/support-files/mysql.server /etc/init.d/mysqld</span></span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible mysql]<span class="comment">#chkconfig --add mysqld ;service mysqld start</span></span><br></pre></td></tr></table></figure>
<p>此时，mariadb编译安装已经完成。</p>
<h2 id="二进制安装mariadb"><a href="#二进制安装mariadb" class="headerlink" title="二进制安装mariadb"></a>二进制安装mariadb</h2><p><strong>到官网下载二进制文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#wget -p tools/ https://downloads.mariadb.org/interstitial/mariadb-10.3.11/source/mariadb-10.3.11.tar.gz/from/http%3A//mirrors.neusoft.edu.cn/mariadb/mariadb-10.2.19.tar.gz</span></span><br></pre></td></tr></table></figure>

<p><strong>创建相关用户和组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#useradd -r -s /sbin/nologin -d /data/mysql mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>创建数据库目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#modir /data/mysql</span></span><br><span class="line">[root@node01 ~]<span class="comment">#chown mysql.mysql /data/mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>解压二进制文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#tar xf mariadb-10.2.19-linux-x86_64.tar.gz -C /app/ </span></span><br><span class="line">[root@node01 ~]<span class="comment">#cd /app/ mariadb-10.2.19-linux-x86_64</span></span><br><span class="line">[root@node01 mariadb-10.2.19-linux-x86_64]<span class="comment">#ln -s ../../app/mariadb-10.2.19-linux-x86_64 /usr/local/mysql</span></span><br><span class="line">[root@node01 mariadb-10.2.19-linux-x86_64]<span class="comment">#chown -R mysql.mysql /usr/local/mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>准备配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mkdir /etc/mysql/</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp support-files/my-large.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure>

<p><strong>在配置文件的mysqld字段添加下面三个选项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datadir &#x3D; &#x2F;data&#x2F;mysql</span><br><span class="line">innodb_file_per_table &#x3D; on</span><br><span class="line">skip_name_resolve &#x3D; on 禁止主机名解析，建议使用</span><br></pre></td></tr></table></figure>

<p><strong>创建数据库文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cd /usr/local/mysql</span></span><br><span class="line">[root@node01 mysql]<span class="comment">#./scripts/mysql_install_db --datadir=/data/mysql --user=mysql</span></span><br></pre></td></tr></table></figure>

<h2 id="yum安装mariadb"><a href="#yum安装mariadb" class="headerlink" title="yum安装mariadb"></a>yum安装mariadb</h2><p><strong>准备服务脚本，并启动服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld</span></span><br><span class="line">[root@node01 ~]<span class="comment">#chkconfig --add mysqld</span></span><br><span class="line">[root@node01 ~]<span class="comment">#service mysqld start</span></span><br></pre></td></tr></table></figure>

<p><strong>添加PATH路径</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#echo ‘PATH=/user/local/mysql/bin:$PATH’ &gt; /etc/profile.d/mysql.sh</span></span><br></pre></td></tr></table></figure>

<p><strong>安全初始化</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#/user/local/mysql/bin/mysql_secure_installation</span></span><br></pre></td></tr></table></figure>


<h2 id="mysql安装配置相关知识讲解"><a href="#mysql安装配置相关知识讲解" class="headerlink" title="mysql安装配置相关知识讲解"></a>mysql安装配置相关知识讲解</h2><h4 id="简易数据规划流程"><a href="#简易数据规划流程" class="headerlink" title="简易数据规划流程"></a>简易数据规划流程</h4><p>第一阶段：收集数据，得到字段<br>• 收集必要且完整的数据项<br>• 转换成数据表的字段<br>第二阶段：把字段分类，归入表，建立表的关联<br>• 关联：表和表间的关系<br>• 分割数据表并建立关联的优点<br>• 节省空间<br>• 减少输入错误<br>• 方便数据修改<br>第三阶段：<br>• 规范化数据库</p>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>1NF：无重复的列，每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，就是无重复的列<br>    说明：第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库<br>2NF：属性完全依赖于主键，第二范式必须先满足第一范式，要求表中的每个行必须可以被唯一地区分。通常为表加上一个列，以存储各个实例的唯一标识PK，非PK的字段需要与整个PK有直接相关性<br>3NF：属性不依赖于其它非主属性，满足第三范式必须先满足第二范式。第三范式要求一个数据库表中不包含已在其它表中已包含的非主关键字信息，非PK的字段间不能有从属关系</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p><strong>约束</strong> ：constraint，表中的数据要遵守的限制<br>主键：一个或多个字段的组合，填入的数据必须能在本表中唯一标识本行；必须提供数据，即NOT NULL，一个表只能有一个<br>惟一键：一个或多个字段的组合，填入的数据必须能在本表中唯一标识本行；允许为NULL，一个表可以存在多个<br>外键：一个表中的某字段可填入的数据取决于另一个表的主键或唯一键已有的数据<br>检查：字段值在一定范围内</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>将表中的一个或多个字段中的数据复制一份另存，并且按特定次序排序存储<br>关系运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择：挑选出符合条件的行</span><br><span class="line">投影：挑选出需要的字段</span><br><span class="line">连接：表间字段的关联</span><br></pre></td></tr></table></figure>

<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p><strong>数据抽象：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理层：数据存储格式，即RDBMS在磁盘上如何组织文件</span><br><span class="line">逻辑层：DBA角度，描述存储什么数据，以及数据间存在什么样的关系</span><br><span class="line">视图层：用户角度，描述DB中的部分数据</span><br></pre></td></tr></table></figure>

<p><strong>关系模型的分类：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关系模型</span><br><span class="line">基于对象的关系模型</span><br><span class="line">半结构化的关系模型：XML数据</span><br></pre></td></tr></table></figure>

<h4 id="mysql的特性"><a href="#mysql的特性" class="headerlink" title="mysql的特性"></a>mysql的特性</h4><p>插件式存储引擎：也称为“表类型”，存储管理器有多种实现版本，功能和特性可能均略有差别；用户可根据需要灵活选择,Mysql5.5.5开始innoDB引擎是<br>MYSQL默认引擎</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyISAM &#x3D;&#x3D;&gt; Aria</span><br><span class="line">InnoDB &#x3D;&#x3D;&gt; XtraDB</span><br></pre></td></tr></table></figure>

<p>单进程，多线程<br>诸多扩展和新特性<br>提供了较多测试组件<br>开源</p>
<h4 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h4><p>mysql的用户账号由两部分组成<br>    ‘username’@’host’<br>说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host限制此用户可通过哪些远程主机连接mysql服务器</span><br><span class="line">主持使用通配符</span><br><span class="line">	% 匹配任意长度的任意字符</span><br><span class="line">		172.16.0.0&#x2F;255.255.0.0 和172.16.%.%等价</span><br><span class="line">	_ 匹配任意单个字符</span><br></pre></td></tr></table></figure>

<h4 id="mysql客户端"><a href="#mysql客户端" class="headerlink" title="mysql客户端"></a>mysql客户端</h4><p><strong>mysql客户端可用选项：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A, --no-auto-rehash 禁止补全</span><br><span class="line">-u, --user&#x3D; 用户名,默认为root</span><br><span class="line">-h, --host&#x3D; 服务器主机,默认为localhost</span><br><span class="line">-p, --passowrd&#x3D; 用户密码,建议使用-p,默认为空密码</span><br><span class="line">-P, --port&#x3D; 服务器端口</span><br><span class="line">-S, --socket&#x3D; 指定连接socket文件路径</span><br><span class="line">-D, --database&#x3D; 指定默认数据库</span><br><span class="line">-C, --compress 启用压缩</span><br><span class="line">-e “SQL“ 执行SQL命令</span><br><span class="line">-V, --version 显示版本</span><br><span class="line">-v --verbose 显示详细信息</span><br><span class="line">--print-defaults 获取程序默认使用的配置</span><br></pre></td></tr></table></figure>



<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>后面覆盖前面的配置文件，顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;my.cnf Global选项</span><br><span class="line">&#x2F;etc&#x2F;mysql&#x2F;my.cnf Global选项</span><br><span class="line">SYSCONFDIR&#x2F;my.cnf Global选项</span><br><span class="line">$MYSQL_HOME&#x2F;my.cnf Server-specific 选项</span><br><span class="line">--defaults-extra-file&#x3D;path</span><br><span class="line">~&#x2F;.my.cnf User-specific 选项</span><br></pre></td></tr></table></figure>









<h2 id="mysql使用"><a href="#mysql使用" class="headerlink" title="mysql使用"></a>mysql使用</h2><p><strong>使用mysql命令即可登录mysql数据库</strong></p>
<h4 id="mysql客户端工具"><a href="#mysql客户端工具" class="headerlink" title="mysql客户端工具"></a>mysql客户端工具</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status：查看当前数据库状态</span><br><span class="line">system：调用linux命令</span><br><span class="line">tee：把执行命令的结果保存到文件中</span><br><span class="line">charset：更改字符集</span><br><span class="line">prompt：设置提示符；如果想永久生效，需要写入配置文件的[mysqld]语句块</span><br></pre></td></tr></table></figure>

<h5 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h5><p>备份工具，基于mysql协议向mysqld发起查询请求，并将查得的所有数据转换成insert等写操作语句保存文本文件中</p>
<h5 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h5><p>基于mysql协议管理mysqld</p>
<h4 id="mysql服务器端工具"><a href="#mysql服务器端工具" class="headerlink" title="mysql服务器端工具"></a>mysql服务器端工具</h4><p>show engines;    查看数据库支持的引擎和默认引擎<br>select version(); 查看数据库版本<br>select user(); 查看当前登录用户<br>select database(); 查看当前正在使用的数据库<br>desc table_name; 查看表中的所有列<br>show variables like ‘datadir’; 查看数据库目录</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP_Wrappers</title>
    <url>/2017/09/20/tcp_wrappers/</url>
    <content><![CDATA[<p>工作在第四层（传输层）的TCP协议<br>对有状态连接的特定服务进行安全检测并实现访问控制<br>以库文件形式实现<br>某进程是否接受libwrap的控制取决于发起此进程的程序在编译时是否针对libwrap进行编译的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd /PATH/TO/PROGRAM|grep libwrap.so</span><br><span class="line">$ strings PATH/TO/PROGRAM|grep libwrap.so</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/hosts.allow,/etc/hosts.deny</p>
<h3 id="检查顺序"><a href="#检查顺序" class="headerlink" title="检查顺序"></a>检查顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hosts.allow,hosts.deny（默认允许）</span><br><span class="line">注意：一旦前面的规则匹配，直接生效，将不再继续</span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>daemon_list@hosts:client_list [:options:option…]</p>
<p><strong>[:options]选项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deny：主要用来在&#x2F;etc&#x2F;hosts.allow文件中定义&quot;拒绝&quot;规则</span><br><span class="line">	如：vsftpd:172.16. :deny</span><br><span class="line">aloow：主要用来在&#x2F;etc&#x2F;hosts.deny文件中定义&quot;允许&quot;规则</span><br><span class="line">	如：vsftpd:172.16. :aloow</span><br><span class="line">spawn：启动一个外部程序完成指定的操作；在允许或拒绝的同时触发一个动作</span><br><span class="line">twist：实际动作是拒绝访问，使用指定操作替换当前服务，标准输出和ERROR发送到客户端，默认至&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p><strong>spawn使用示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/hosts.allow </span><br><span class="line">sshd:ALL :spawn <span class="built_in">echo</span> <span class="string">"<span class="variable">$(date +%%F)</span>login attempt from %c to %s,%d"</span> &gt;&gt; /var/<span class="built_in">log</span>/tcpwrapper.log</span><br></pre></td></tr></table></figure>
<p>说明：<br>    在/etc/hosts.allow中添加，允许登录并记录日志<br>    在/etc/hosts.deny中添加，拒绝登陆并记录日志<br>    %c 客户端信息<br>    %s 服务器端信息<br>    %d 服务名<br>    %p 守护进程的PID<br>    %% 表示%</p>
<p><strong>twist使用示例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ [root@node01 ~]<span class="comment">#sed -n '/^[^#]/p' /etc/hosts.allow </span></span><br><span class="line">sshd:172.18. :twist /bin/<span class="built_in">echo</span> <span class="string">"不让你连！"</span></span><br></pre></td></tr></table></figure>

<p><strong>daemon_list@host格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单个应用程序的二进制文件名，而非服务名，例如vsftpd</span><br><span class="line">以逗号或空格分割的应用程序文件名列表，如：sshd,vsftpd</span><br><span class="line">ALL表示所有接受tcp_wrapper控制的服务程序</span><br><span class="line">主机有多个IP，可用@hostIP来实现控制</span><br><span class="line">	如：in.telnetd@192.168.0.254</span><br></pre></td></tr></table></figure>

<p><strong>client_list选项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对哪些主机生效定义的规则，可以是地址段</span><br></pre></td></tr></table></figure>

<p><strong>测试工具</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdmatch [-d] daemon[@host] client</span><br></pre></td></tr></table></figure>
<p>-d 测试当前目录下的hosts.allow和hosts.deny规则是否生效</p>
]]></content>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2017/08/20/redis1/</url>
    <content><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Rdies简介"><a href="#Rdies简介" class="headerlink" title="Rdies简介"></a>Rdies简介</h3><p>Redis(Remote Dictionary Server)在2009年发布，开发者Salvatore Sanfilippo是意大利开发者，他本想为自己的公司开发一个用于替换MySQL的产品Redis，但是没有想到他把Redis开源后大受欢迎，短短几年，Redis就有了很大的用户群体，目前国内外使用的公司有知乎网、新浪微博、GitHub等<br>redis是一个开源的、遵循BSD协议的、基于内存的而且目前比较流行的键值数据库(key-value database)，是一个非关系型数据库，redis提供将内存通过网络远程共享的一种服务，提供类似功能的还有memcache，但相比memcache，redis还提供了易扩展、高性能、具备数据持久性等功能。<br>  Redis在高并发、低延迟环境要求比较高的环境使用量非常广泛</p>
<h4 id="redis和memcached对比"><a href="#redis和memcached对比" class="headerlink" title="redis和memcached对比"></a>redis和memcached对比</h4><p>支持数据的持久化：可以将内存中的数据保持在磁盘中，重启redis服务或者服务器之后可以从备份文件中恢复数据到内存继续使用。<br>支持更多的数据类型：支持string(字符串)、hash(哈希数据)、list(列表)、set(集合)、zet(有序集合)<br>支持数据的备份：可以实现类似于数据的master-slave模式的数据备份，另外也支持使用快照+AOF。<br>支持更大的value数据：memcache单个key value最大只支持1MB，而redis最大支持512MB。<br>Redis 是单线程，而memcache是多线程，所以单机情况下没有memcache并发高，但redis 支持分布式集群以实现更高的并发，单Redis实例可以实现数万并发。<br>支持集群横向扩展：基于redis cluster的横向扩展，可以实现分布式集群，大幅提升性能和数据安全性。<br>都是基于C语言开发。</p>
<h4 id="redis典型应用场景"><a href="#redis典型应用场景" class="headerlink" title="redis典型应用场景"></a>redis典型应用场景</h4><p>Session 共享：常见于web集群中的Tomcat或者PHP中多web服务器session共享<br>消息队列：ELK的日志缓存、部分业务的订阅发布系统<br>计数器：访问排行榜、商品浏览数等和次数相关的场景<br>缓存：数据查询、电商网站商品信息、新闻内容<br>微博/微信社交场合：共同好友、点赞评论等</p>
<h4 id="编译安装redis"><a href="#编译安装redis" class="headerlink" title="编译安装redis"></a>编译安装redis</h4><p>到官网下载源码包，解压后进入解压目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-5.0.3]<span class="comment">#make PREFIX=/usr/local/redis install</span></span><br><span class="line">redis-5.0.3]<span class="comment">#mkdir /usr/local/redis/etc</span></span><br><span class="line">redis-5.0.3]<span class="comment">#cp redis.conf /usr/local/redis/etc/</span></span><br></pre></td></tr></table></figure>
<p>前台启动redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#/usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf</span></span><br></pre></td></tr></table></figure>
<p>在启动redis的时候回有几个报警需要调整一下<br><strong>WARNING</strong>: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.<br>backlog参数控制的是三次握手的时候server端收到client ack确认号之后的队列值。<br>net.core.somaxconn = 512<br><strong>WARNING</strong> overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.<br>0、表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。<br>1、表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2、表示内核允许分配超过所有物理内存和交换空间总和的内存<br>vm.overcommit_memory = 1<br><strong>WARNING</strong> you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.<br>开启大页内存动态分配，需要关闭让redis 负责内存管理。<br>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</p>
<p>之后再次启动redis即可消除警报</p>
<p><strong>编辑redis服务启动脚本</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># cat  /usr/lib/systemd/system/redis.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/etc/redis.conf  --supervised systemd</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span> </span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p><strong>将redis加入systemd管理</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 system]<span class="comment">#systemctl daemon-reload</span></span><br></pre></td></tr></table></figure>
<p>之后就可以用systemd管理redis服务，redis默认监听127.0.0.1:6379端口。</p>
<h4 id="创建redis用户和数据目录"><a href="#创建redis用户和数据目录" class="headerlink" title="创建redis用户和数据目录"></a>创建redis用户和数据目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># groupadd  -g 1000 redis &amp;&amp; useradd   -u 1000 -g 1000 redis -s /sbin/nologin</span></span><br><span class="line"><span class="comment"># mkdir -pv /usr/local/redis/&#123;etc,logs,data,run&#125;</span></span><br><span class="line"><span class="comment"># chown redis.redis -R  /usr/local/redis/</span></span><br></pre></td></tr></table></figure>
<h4 id="创建命令软连接以方便以后使用"><a href="#创建命令软连接以方便以后使用" class="headerlink" title="创建命令软连接以方便以后使用"></a>创建命令软连接以方便以后使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ln -sv /usr/<span class="built_in">local</span>/redis/bin/redis-* /usr/bin/</span><br><span class="line">‘/usr/bin/redis-benchmark’ -&gt; ‘/usr/<span class="built_in">local</span>/redis/bin/redis-benchmark’</span><br><span class="line">‘/usr/bin/redis-check-aof’ -&gt; ‘/usr/<span class="built_in">local</span>/redis/bin/redis-check-aof’</span><br><span class="line">‘/usr/bin/redis-check-rdb’ -&gt; ‘/usr/<span class="built_in">local</span>/redis/bin/redis-check-rdb’</span><br><span class="line">‘/usr/bin/redis-cli’ -&gt; ‘/usr/<span class="built_in">local</span>/redis/bin/redis-cli’</span><br><span class="line">‘/usr/bin/redis-sentinel’ -&gt; ‘/usr/<span class="built_in">local</span>/redis/bin/redis-sentinel’</span><br><span class="line">‘/usr/bin/redis-server’ -&gt; ‘/usr/<span class="built_in">local</span>/redis/bin/redis-server’</span><br></pre></td></tr></table></figure>
<h4 id="编译安装后的命令"><a href="#编译安装后的命令" class="headerlink" title="编译安装后的命令"></a>编译安装后的命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-10-10-8 system]<span class="comment">#ll /usr/local/redis/bin/</span></span><br><span class="line">total 32672</span><br><span class="line">-rwxr-xr-x 1 redis redis 4366608 Jan 12 16:34 redis-benchmark <span class="comment">#性能检测工具</span></span><br><span class="line">-rwxr-xr-x 1 redis redis 8090040 Jan 12 16:34 redis-check-aof <span class="comment">#文件检查工具</span></span><br><span class="line">-rwxr-xr-x 1 redis redis 8090040 Jan 12 16:34 redis-check-rdb <span class="comment">#文件检查工具</span></span><br><span class="line">-rwxr-xr-x 1 redis redis 4801864 Jan 12 16:34 redis-cli <span class="comment">#客户端工具</span></span><br><span class="line">lrwxrwxrwx 1 redis redis      12 Jan 12 16:34 redis-sentinel -&gt; redis-server <span class="comment">#哨兵，软连接到server</span></span><br><span class="line">-rwxr-xr-x 1 redis redis 8090040 Jan 12 16:34 redis-server <span class="comment">#redis服务端</span></span><br><span class="line">``` </span><br><span class="line"><span class="comment">#### redis的连接</span></span><br><span class="line">本机非密码连接</span><br><span class="line"></span><br><span class="line">	redis-cli</span><br><span class="line"></span><br><span class="line">夸主机非密码连接</span><br><span class="line"></span><br><span class="line">	redis-cli -h HOSTNAME/IP -p PORT</span><br><span class="line"></span><br><span class="line">夸主机密码连接</span><br><span class="line">	</span><br><span class="line">	redis-cli -h HOSTNAME/IP -p PORT -a PASSWORD</span><br><span class="line"></span><br><span class="line">python连接</span><br><span class="line">```python</span><br><span class="line"><span class="comment">#!/bin/env  python</span></span><br><span class="line"><span class="comment">#Author: Msq</span></span><br><span class="line">import redis</span><br><span class="line">import  time</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">"192.168.7.101"</span>, port=6379,password=<span class="string">""</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(100):</span><br><span class="line">    r.set(<span class="string">"k%d"</span> % i,<span class="string">"v%d"</span> % i)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    data=r.get(<span class="string">"k%d"</span> % i)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<h4 id="redis帮助命令"><a href="#redis帮助命令" class="headerlink" title="redis帮助命令"></a>redis帮助命令</h4><p>查看通用命令帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> @generic</span><br></pre></td></tr></table></figure>

<h4 id="redis配置文件详解"><a href="#redis配置文件详解" class="headerlink" title="redis配置文件详解"></a>redis配置文件详解</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment">#cat /usr/local/redis/etc/redis.conf</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0 <span class="comment">#监听地址，可以用空格隔开后多个监听IP</span></span><br><span class="line">protected-mode yes  <span class="comment">#redis3.2 之后加入的新特性，在没有设置bind IP和密码的时候只允许访问127.0.0.1:6379</span></span><br><span class="line">port 6379 <span class="comment">#监听端口</span></span><br><span class="line">tcp-backlog 511 <span class="comment">#三次握手的时候server端收到client ack确认号之后的队列值。</span></span><br><span class="line">timeout 0 <span class="comment">#客户端和Redis服务端的连接超时时间，默认是0，表示永不超时。 </span></span><br><span class="line">tcp-keepalive 300 <span class="comment">#tcp 会话保持时间</span></span><br><span class="line">daemonize no <span class="comment">#认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes,当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面</span></span><br><span class="line">supervised no <span class="comment">#和操作系统相关参数，可以设置通过upstart和systemd管理Redis守护进程，centos 7以后都使用systemd</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment">#pid文件路径</span></span><br><span class="line">loglevel notice <span class="comment">#日志级别</span></span><br><span class="line">logfile <span class="string">""</span> <span class="comment">#日志路径</span></span><br><span class="line">databases 16  <span class="comment">#设置db 库数量，默认16个库</span></span><br><span class="line">always-show-logo yes <span class="comment">#在启动redis 时是否显示log</span></span><br><span class="line"></span><br><span class="line">save 900 1 <span class="comment">#在900秒内有一个键内容发生更改就出就快照机制</span></span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes  <span class="comment">#快照出错时是否禁止redis 写入操作</span></span><br><span class="line">rdbcompression yes <span class="comment">#持久化到RDB文件时，是否压缩，"yes"为压缩，"no"则反之</span></span><br><span class="line">rdbchecksum yes  <span class="comment">#是否开启RC64校验，默认是开启</span></span><br><span class="line">dbfilename dump.rdb <span class="comment">#快照文件名</span></span><br><span class="line">dir ./ <span class="comment">#快照文件保存路径</span></span><br><span class="line">replica-serve-stale-data yes <span class="comment">#当从库同主库失去连接或者复制正在进行，从机库有两种运行方式：1) 如果replica-serve-stale-data设置为yes(默认设置)，从库会继续响应客户端的请求。2) 如果replica-serve-stale-data设置为no，除去指定的命令之外的任何请求都会返回一个错误"SYNC with master in progress"。</span></span><br><span class="line">replica-read-only yes <span class="comment">#是否设置从库只读</span></span><br><span class="line">repl-diskless-sync no <span class="comment">#是否使用socket方式复制数据，目前redis复制提供两种方式，disk和socket，如果新的slave连上来或者重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件，有2种方式：disk方式是master创建一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave，socket是master创建一个新的进程，直接把rdb文件以socket的方式发给slave，disk方式的时候，当一个rdb保存的过程中，多个slave都能共享这个rdb文件，socket的方式就是一个个slave顺序复制，只有在磁盘速度缓慢但是网络相对较快的情况下才使用socket方式，否则使用默认的disk方式</span></span><br><span class="line">repl-diskless-sync-delay 5  <span class="comment">#diskless复制的延迟时间，设置0为关闭，一旦复制开始还没有结束之前，master节点不会再接收新slave的复制请求，直到下一次开始</span></span><br><span class="line">repl-ping-slave-period 10 <span class="comment">#slave根据master指定的时间进行周期性的PING 监测</span></span><br><span class="line">repl-timeout 60 <span class="comment">#复制链接超时时间，需要大于repl-ping-slave-period，否则会经常报超时</span></span><br><span class="line">repl-disable-tcp-nodelay no <span class="comment">#在socket模式下是否在slave套接字发送SYNC之后禁用 TCP_NODELAY，如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒，如果你选择了 "no" 数据传输到salve的延迟将会减少但要使用更多的带宽</span></span><br><span class="line">repl-backlog-size 1mb <span class="comment">#复制缓冲区大小，只有在slave连接之后才分配内存。 </span></span><br><span class="line">repl-backlog-ttl 3600 <span class="comment">#多次时间master没有slave连接，就清空backlog缓冲区。</span></span><br><span class="line">replica-priority 100 <span class="comment">#当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。</span></span><br><span class="line">requirepass foobared <span class="comment">#设置redis 连接密码</span></span><br><span class="line">rename-command <span class="comment">#重命名一些高危命令</span></span><br><span class="line">maxclients 10000 <span class="comment">#最大连接客户端</span></span><br><span class="line">maxmemory <span class="comment">#最大内存，单位为bytes字节，8G内存的计算方式8(G)*1024(MB)*1024(KB)*1024(Kbyte)，需要注意的是slave的输出缓冲区是不计算在maxmemory内。</span></span><br><span class="line">appendonly no <span class="comment">#是否开启AOF日志记录，默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span> <span class="comment">#AOF文件名</span></span><br><span class="line">appendfsync everysec  <span class="comment">#aof持久化策略的配置,no表示不执行fsync,由操作系统保证数据同步到磁盘,always表示每次写入都执行fsync，以保证数据同步到磁盘,everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span></span><br><span class="line">no-appendfsync-on-rewrite no <span class="comment">#在aof rewrite期间,是否对aof新记录的append暂缓使用文件同步策略,主要考虑磁盘IO开支和请求阻塞时间。默认为no,表示"不暂缓",新的aof记录仍然会被立即同步，Linux的默认fsync策略是30秒，如果为yes 可能丢失30秒数据，但由于yes性能较好而且会避免出现阻塞因此比较推荐。</span></span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment"># 当Aof log增长超过指定比例时，重写log file， 设置为0表示不自动重写Aof 日志，重写是为了使aof体积保持最小，而确保保存最完整的数据。</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#触发aof rewrite的最小文件尺寸</span></span><br><span class="line">aof-load-truncated yes <span class="comment">#是否加载由于其他原因导致的末尾异常的AOF文件(主进程被kill/断电等)</span></span><br><span class="line">aof-use-rdb-preamble yes <span class="comment">#redis4.0新增RDB-AOF混合持久化格式，在开启了这个功能之后，AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，其中RDB格式的内容用于记录已有的数据，而AOF格式的内存则用于记录最近发生了变化的数据，这样Redis就可以同时兼有RDB持久化和AOF持久化的优点（既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据）。</span></span><br><span class="line">lua-time-limit 5000 <span class="comment">#lua脚本的最大执行时间，单位为毫秒</span></span><br><span class="line">cluster-enabled yes <span class="comment">#是否开启集群模式，默认是单机模式</span></span><br><span class="line">cluster-config-file nodes-6379.conf <span class="comment">#由node节点自动生成和的集群配置文件</span></span><br><span class="line">cluster-node-timeout 15000 <span class="comment">#集群中node节点连接超时时间</span></span><br><span class="line">cluster-replica-validity-factor 10 <span class="comment">#在执行故障转移的时候可能有些节点和master断开一段时间数据比较旧，这些节点就不适用于选举为master，超过这个时间的就不会被进行故障转移</span></span><br><span class="line">cluster-migration-barrier 1  <span class="comment">#一个主节点拥有的至少正常工作的从节点，即如果主节点的slave节点故障后会将多余的从节点分配到当前主节点成为其新的从节点。</span></span><br><span class="line">cluster-require-full-coverage yes <span class="comment">#集群槽位覆盖，如果一个主库宕机且没有备库就会出现集群槽位不全，那么yes情况下redis集群槽位验证不全就不再对外提供服务，而no则可以继续使用但是会出现查询数据查不到的情况(因为有数据丢失)。</span></span><br><span class="line">cluster-replica-no-failover no</span><br><span class="line"><span class="comment">#Slow log 是 Redis 用来记录查询执行时间的日志系统，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</span></span><br><span class="line">slowlog-log-slower-than 10000 <span class="comment">#以微秒为单位的慢日志记录，为负数会禁用慢日志，为0会记录每个命令操作。</span></span><br><span class="line">slowlog-max-len 128 <span class="comment">#记录多少条慢日志保存在队列，超出后会删除最早的，以此滚动删除</span></span><br></pre></td></tr></table></figure>

<h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><p>redis 虽然是一个内存级别的缓存程序，即redis 是使用内存进行数据的缓存的，但是其可以将内存的数据按照一定的策略保存到硬盘上，从而实现数据持久保存的目的，redis支持两种不同方式的数据持久化保存机制，分别是RDB和AOF</p>
<h5 id="RDB模式"><a href="#RDB模式" class="headerlink" title="RDB模式"></a>RDB模式</h5><p>RDB：基于时间的快照，只保留当前最新的一次快照，特点是执行速度比较快，缺点是可能会丢失从上次快照到当前快照未完成之间的数据。<br>RDB实现的具体过程Redis从主进程先fork出一个子进程，使用写时复制机制，子进程将内存的数据保存为一个临时文件，比如dump.rdb.temp，当数据保存完成之后再将上一次保存的RDB文件替换掉，然后关闭子进程，这样可以保存每一次做RDB快照的时候保存的数据都是完整的，因为直接替换RDB文件的时候可能会出现突然断电等问题而导致RDB文件还没有保存完整就突然关机停止保存而导致数据丢失的情况，可以手动将每次生成的RDB文件进程备份，这样可以最大化保存历史数据。<br><strong>RDB模式的优缺点</strong><br>优点：</p>
<ul>
<li>RDB快照保存了某个时间点的数据，可以通过脚本执行bgsave(非阻塞)或者save(阻塞)命令自定义时间点北备份，可以保留多个备份，当出现问题可以恢复到不同时间点的版本。</li>
<li>可以最大化io的性能，因为父进程在保存RDB 文件的时候唯一要做的是fork出一个子进程，然后的-操作都会有这个子进程操作，父进程无需任何的IO操作。RDB在大量数据比如几个G的数据，恢复的速度比AOF的快</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能时时的保存数据，会丢失自上一次执行RDB备份到当前的内存数据</li>
<li>数据量非常大的时候，从父进程fork的时候需要一点时间，可能是毫秒或者秒</li>
</ul>
<h5 id="AOF模式"><a href="#AOF模式" class="headerlink" title="AOF模式"></a>AOF模式</h5><p>AOF:按照操作顺序依次将操作添加到指定的日志文件当中，特点是数据安全性相对较高，缺点是即使有些操作是重复的也会全部记录。<br>AOF和RDB一样使用了写时复制机制，AOF默认为每秒钟fsync一次，即将执行的命令保存到AOF文件当中，这样即使redis服务器发生故障的话顶多也就丢失1秒钟之内的数据，也可以设置不同的fsync策略，或者设置每次执行命令的时候执行fsync，fsync会在后台执行线程，所以主线程可以继续处理用户的正常请求而不受到写入AOF文件的IO影响<br><strong>AOF模式的优缺点</strong><br>AOF的文件大小要大于RDB格式的文件<br>根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec即每秒执行一次fsync</p>
<h3 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是所有编程语言中最常见的和最常用的数据类型，而且也是redis最基本的数据类型之一，而且redis中所有的key的类型都是字符串。<br>添加一个key</p>
<pre><code>127.0.0.1:6379&gt; set key1 value1
OK</code></pre><p>获取一个key的内容</p>
<pre><code>127.0.0.1:6379&gt; get key1
&quot;value1&quot;</code></pre><p>删除一个key</p>
<pre><code>127.0.0.1:6379&gt; DEL key1
(integer) 1</code></pre><p>批量设置多个key</p>
<pre><code>127.0.0.1:6379&gt; MSET key1 value1 key2 value2
OK</code></pre><p>批量获取多个key</p>
<pre><code>127.0.0.1:6379&gt; MSET key1 value1 key2 value2
OK</code></pre><p>往key中追加数据</p>
<pre><code>127.0.0.1:6379&gt; APPEND key1 append
(integer) 12
127.0.0.1:6379&gt; get key1
&quot;value1append&quot;</code></pre><p>数值递增</p>
<pre><code>127.0.0.1:6379&gt; set num 10
OK
127.0.0.1:6379&gt; INCR num
(integer) 11
127.0.0.1:6379&gt; get num
&quot;11&quot;</code></pre><p>数值递减：</p>
<pre><code>127.0.0.1:6379&gt; set num 10
OK
127.0.0.1:6379&gt; DECR num
(integer) 9
127.0.0.1:6379&gt; get num
&quot;9&quot;</code></pre><p>返回字符串key长度：</p>
<pre><code>127.0.0.1:6379&gt; STRLEN key1
(integer) 12</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是一个双向可读写的管道，其头部是左侧尾部是右侧，一个列表最多可以包含2^32-1个元素即4294967295个元素。<br>列表相关操作</p>
<pre><code>10.10.10.8:6379&gt; LPUSH list1 jack #生成列表list1并插入第0个值Jack
(integer) 1
10.10.10.8:6379&gt; type list1 #查看list1的类型
list
10.10.10.8:6379&gt; LPUSH list1 msq 
(integer) 2
10.10.10.8:6379&gt; LPUSH list1 merry
(integer) 3
10.10.10.8:6379&gt; LLEN list1 #获取列表list1的长度
(integer) 3
10.10.10.8:6379&gt; LRANGE list1 0 2 #查看列表list1的第0个值到第2个值
1) &quot;merry&quot;
2) &quot;msq&quot;
3) &quot;jack&quot;</code></pre><h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h4><p>Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>生成集合key:</p>
<pre><code>127.0.0.1:6379&gt; SADD set1 v1 
(integer) 1
127.0.0.1:6379&gt; SADD set2 v2 v4
(integer) 2
127.0.0.1:6379&gt; TYPE set1
set
127.0.0.1:6379&gt; TYPE set2
set</code></pre><p>追加数值：<br>追加的时候不能追加已经存在的数值</p>
<pre><code>127.0.0.1:6379&gt; SADD set1 v2 v3 v4
(integer) 3
127.0.0.1:6379&gt; SADD set1 v2 #没有追加成功
(integer) 0
127.0.0.1:6379&gt; TYPE set1
set
127.0.0.1:6379&gt; TYPE set2
set</code></pre><p>查看集合的所有数据：</p>
<pre><code>127.0.0.1:6379&gt; SMEMBERS set1
1) &quot;v4&quot;
2) &quot;v1&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
127.0.0.1:6379&gt; SMEMBERS set2
1) &quot;v4&quot;
2) &quot;v2&quot;</code></pre><p>获取集合的差集：<br>差集：已属于A而不属于B的元素称为A与B的差（集）</p>
<pre><code>127.0.0.1:6379&gt; SDIFF set1 set2
1) &quot;v1&quot;
2) &quot;v3&quot;</code></pre><p>获取集合的交集：<br>交集：已属于A且属于B的元素称为A与B的交（集）</p>
<pre><code>127.0.0.1:6379&gt; SINTER set1 set2
1) &quot;v4&quot;
2) &quot;v2&quot;</code></pre><p>获取集合的并集：<br>并集：已属于A或属于B的元素为称为A与B的并（集）</p>
<pre><code>127.0.0.1:6379&gt; SUNION  set1 set2
1) &quot;v2&quot;
2) &quot;v4&quot;
3) &quot;v1&quot;
4) &quot;v3&quot;</code></pre><h4 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合(sorted set)"></a>有序集合(sorted set)</h4><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double(双精度浮点型)类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序，有序集合的成员是唯一的,但分数(score)却可以重复，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)， 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。<br>生成有序集合</p>
<pre><code>127.0.0.1:6379&gt; ZADD zset1 1 v1 
(integer) 1
127.0.0.1:6379&gt; ZADD zset1 2 v2
(integer) 1
127.0.0.1:6379&gt; ZADD zset1 2 v3
(integer) 1
127.0.0.1:6379&gt; ZADD zset1 3 v4
(integer) 1
127.0.0.1:6379&gt; TYPE zset1
zset
127.0.0.1:6379&gt; TYPE zset2
zset</code></pre><p>排行案例：</p>
<pre><code>192.168.7.104:6379&gt; ZADD paihangbang 10 key1 20 key2 30 key3
(integer) 3
192.168.7.104:6379&gt; ZREVRANGE paihangbang 0 -1 withscores
1) &quot;key3&quot;
2) &quot;30&quot;
3) &quot;key2&quot;
4) &quot;20&quot;
5) &quot;key1&quot;
6) &quot;10&quot;</code></pre><p>批量添加多个数值：</p>
<pre><code>127.0.0.1:6379&gt; ZADD zset2 1 v1 2 v2 4 v3 5 v5
(integer) 4</code></pre><p>获取集合的长度数：</p>
<pre><code>127.0.0.1:6379&gt; ZCARD zset1 
(integer) 4
127.0.0.1:6379&gt; ZCARD zset2
(integer) 4</code></pre><p>基于索引返回数值：</p>
<pre><code>127.0.0.1:6379&gt; ZRANGE zset1 1 3
1) &quot;v2&quot;
2) &quot;v3&quot;
3) &quot;v4&quot;
127.0.0.1:6379&gt; ZRANGE zset1 0 2
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;</code></pre><p>返回某个数值的索引：</p>
<pre><code>127.0.0.1:6379&gt; ZRANK zset1 v2
(integer) 1
127.0.0.1:6379&gt; ZRANK zset1 v3
(integer) 2</code></pre><h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希(hash)"></a>哈希(hash)</h4><p>hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象,Redis 中每个 hash 可以存储 2^32 - 1 键值对（40多亿）。</p>
<p>生成hash key：</p>
<pre><code>127.0.0.1:6379&gt; HSET hset1 name tom  age 18
(integer) 1
127.0.0.1:6379&gt; TYPE hset1
hash</code></pre><p>获取hash key字段值：</p>
<pre><code>127.0.0.1:6379&gt; HGET hset1 name
&quot;tom&quot;
127.0.0.1:6379&gt; HGET hset1  age
&quot;18&quot;</code></pre><p>删除一个hash key的字段：</p>
<pre><code>127.0.0.1:6379&gt; HDEL hset1 age
(integer) 1</code></pre><p>获取所有hash表中的字段：</p>
<pre><code>127.0.0.1:6379&gt; HSET hset1 name tom age 19
(integer) 1
127.0.0.1:6379&gt; HKEYS hset1
1) &quot;name&quot;
2) &quot;age&quot;</code></pre><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列主要分为两种，分别是生产者消费者模式和发布者订阅者模式，这两种模式Redis都支持。</p>
<h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><p>在生产者消费者(Producer/Consumer)模式下，在上层应用接收到的外部请求后开始处理其当前步骤的操作，在执行完成后将已经完成的操作发送至指定的频道(channel)当中，并由其下层的应用监听该频道并继续下一步的操作，如果其处理完成后没有下一步的操作就直接返回数据给外部请求，如果还有下一步的操作就再将任务发布到另外一个频道，由另外一个消费者继续监听和处理。</p>
<h5 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h5><p>生产者消费者模式下，多个消费者同时监听一个队里，但是一个消息只能被最先抢到消息的消费者消费，即消息任务是一次性读取和处理，此模式在分布式业务架构中非常常用，比较常用的软件还有 RabbitMQ、Kafka、RocketMQ、ActiveMQ等</p>
<h5 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h5><p>队列当中的 消息由不同的生产者写入也会有不同的消费者取出进行消费处理，但是买一个消息一定是只能被取出一次也就是被消费一次。</p>
<h2 id="redis高可用和集群"><a href="#redis高可用和集群" class="headerlink" title="redis高可用和集群"></a>redis高可用和集群</h2><p>虽然Redis可以实现单机的数据持久化，但无论是RDB也好或者AOF也好，都解决不了单点宕机问题，即一旦redis服务器本身出现系统故障、硬件故障等问题后，就会直接造成数据的丢失，因此需要使用另外的技术来解决单点问题。</p>
<h3 id="配置redis主从"><a href="#配置redis主从" class="headerlink" title="配置redis主从"></a>配置redis主从</h3><p>主备模式，可以实现Redis数据的跨主机备份。<br>程序端连接到高可用负载的VIP，然后连接到负载服务器设置的Redis后端real server，此模式不需要在程序里面配置Redis服务器的真实IP地址，当后期Redis服务器IP地址发生变更只需要更改redis 相应的后端real server即可，可避免更改程序中的IP地址设置。</p>
<h4 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h4><p>edis Slave 也要开启持久化并设置和master同样的连接密码，因为后期slave会有提升为master的可能,Slave端切换master同步后会丢失之前的所有数据。<br>一旦某个Slave成为一个master的slave，Redis Slave服务会清空当前redis服务器上的所有数据并将master的数据导入到自己的内存，但是断开同步关系后不会删除当前已经同步过的数据。</p>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>缓存服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables</title>
    <url>/2017/08/19/iptables/</url>
    <content><![CDATA[<p>防火墙的作用是阻止非授权网络的访问，防患于未然。只能识别事先定义好的规则。<br>杀毒软件的作用是杀毒，是治病的，当电脑遭受到攻击之后才起作用。<br>入侵检测与管理系统</p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>端口：进程地址<br>互联网主机间进程通讯的过程：传输层封装报文是会将进程端口写在报文上，ip封装时会写上源ip和目标ip，数据链路层会在报文外层再加一层帧封装，在报文传输过程中，MAC层首部会不断变换，而ip层首部始终不变，直到经过层层转发，到达目的主机。</p>
<p>防火墙的分类：<br>主机防火墙，服务范围为当前主机<br>网络防火墙，服务范围为防火墙一侧的局域网</p>
<p>硬件防火墙<br>软件防火墙</p>
<p>网络层防火墙，OSI模型下四层</p>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><p>prerouting：所有到达本机的数据包都要首先经过此hook，它的位置在本机内核边缘。<br>input ：所有发给本机的数据包都要经过此hook<br>output：所有由本机出去的数据包都要经过此hook<br>forward：所有经过本机转发的数据包都要经过此hook<br>postrouting：所有经由本机出去的额数据包都要经过此hook</p>
<h3 id="iptables表"><a href="#iptables表" class="headerlink" title="iptables表"></a>iptables表</h3><p>iptables默认包含5张表，分别具有不同的功能，大部分情况仅需使用filter和nat，其余用于更加复杂的情况，例如多路有哦和路由判定等<br><strong>raw</strong></p>
<ul>
<li>用于配置数据包，raw中的数据包不会被系统跟踪</li>
</ul>
<p><strong>filter</strong></p>
<ul>
<li>用于存放所有域防火墙相关操作的默认表</li>
</ul>
<p><strong>nat</strong></p>
<ul>
<li>用于网络地址转换，即端口转发</li>
</ul>
<p><strong>mangle</strong></p>
<ul>
<li>用于对特定数据包的修改</li>
</ul>
<p><strong>security</strong></p>
<ul>
<li>用于强制访问控制网络规则，如selinux</li>
</ul>
<h3 id="报文流向"><a href="#报文流向" class="headerlink" title="报文流向"></a>报文流向</h3><p>到本机内部</p>
<ul>
<li>prerouting-&gt; input</li>
</ul>
<p>由本机发出</p>
<ul>
<li>output -&gt; postrouting</li>
</ul>
<p>由本机转发</p>
<ul>
<li>prerouting -&gt; forward</li>
</ul>
<p>安装iptables-services包，可以开启系统服务管理规则，</p>
<h3 id="table与chains之间的映射关系"><a href="#table与chains之间的映射关系" class="headerlink" title="table与chains之间的映射关系"></a>table与chains之间的映射关系</h3><p>filter：INPUT,FORWARD,OUTPUT<br>nat：PREROUTING,INPUT,OUTPUT,POSTROUTING<br>mangle:PREROUTING,INPUT,OUTPUT,FORWARD,POSTROUTING<br>raw:PREROUTING,OUTPUT</p>
<h3 id="iptables命令详解"><a href="#iptables命令详解" class="headerlink" title="iptables命令详解"></a>iptables命令详解</h3><p><strong>命令使用格式</strong><br>iptables [ -t table] SUBCOMMAND chain [ num|rule-spec]</p>
<p>SUBCOMMAND自命令介绍</p>
<ul>
<li><p>管理规则</p>
<blockquote>
<p>-A:append,追加，追加到最后一条<br>  -I：insert，插入，默认插入到第一条，可以指定插到第几条<br>  -D:删除<br>  -R:替换</p>
</blockquote>
</li>
<li><p>管理链</p>
<blockquote>
<p>-N:new，新增一条链<br>  -X:删除一条自定义的、空的、引用计数为0的链。<br>  -E:<br>  -P:policy，创建链的默认策略<br>  -F:flush，清空链上的所有策略，不包括默认策略<br>  -Z:zero，计数器置零，iptables的每条规则和每个链都有专用的两个计数器：pkts，bytes<br>  -L:查看表中的链上定义的策略，加上-n选项，表示不经过地址解析，直接以数字的方式显示主机地址和端口,加上-v，显示详细信息，加上-x显示精确的匹配到的数据大小，–line-numbers显示每条规则的编号</p>
</blockquote>
</li>
</ul>
<p>检查报文，检查报文的tcp/udp首部、ip首部，MAC首部格式中的某个数据。</p>
<ul>
<li>tcp/udp首部：源端口，目标端口</li>
<li>ip首部：sip、dip</li>
<li>MAC首部：源MAC，目的MAC</li>
</ul>
<p>匹配条件</p>
<ul>
<li>通用匹配<blockquote>
<p>[!] -s,–sip,–source-ip：报文源地址，其值可以是单个ip或一个网段，但不能是离散单个ip，前面加！表示取反。<br>  [!] -d,–dip,–destnation-ip:目标ip<br>  -i，–in-interface报文流入的接口；只能应用于数据报文流入环节，只应用于INPUT、FORWARD、PREROUTING链<br>  -o,–out-interface,报文流出的接口；只能应用于数据报文流出的环节，只应用于FORWARD、OUTPUT、POSTROUTING链<br>  -p protocol:四层协议，例如tcp,udp,icmp</p>
</blockquote>
</li>
</ul>
<ul>
<li>扩展匹配<blockquote>
<p>隐式扩展<br>  显式扩展，需要使用-m选项指明要调用的扩展模块的扩展机制，要手动加载扩展模块。模块可以通过ls /lib/modules/`uname -r`/kernel/net/netfilter 命令查看</p>
</blockquote>
</li>
</ul>
<p>隐式扩展：在使用-p选项指明了特定的协议时，无需再用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块</p>
<ul>
<li><p>基于tcp的隐式扩展</p>
<blockquote>
<p>[!] –source-port, –sport port[:port]：匹配报文源端口,可为端口范围<br>  [!] –destination-port,–dport port[:port]：匹配报文目标端口,可为范围<br>  [!] –tcp-flags mask comp</p>
</blockquote>
</li>
<li><p>基于icmp的隐式扩展</p>
<blockquote>
<p>[!] –icmp-type {type[/code]|typename}<br>  type/code<br>  0/0 echo-reply icmp应答<br>  8/0 echo-request icmp请求</p>
</blockquote>
</li>
</ul>
<p>处理动作</p>
<ul>
<li>DROP:丢弃</li>
<li>REJECT：拒绝</li>
<li>ACCEPT:接受</li>
<li>RETURN:返回调用链</li>
<li>REDIRECT</li>
<li>SNAT</li>
<li>DNAT</li>
<li>MASQURADE</li>
<li>LOG</li>
</ul>
<h3 id="iptables实战"><a href="#iptables实战" class="headerlink" title="iptables实战"></a>iptables实战</h3><p><strong>查看规则</strong></p>
<ul>
<li>iptables -t filter -vnL</li>
</ul>
<p><strong>将某个链的计数置零</strong></p>
<ul>
<li>iptables -t fileter -Z INPUT</li>
</ul>
<p><strong>拒绝web服务被某个特定的网段访问</strong></p>
<ul>
<li>iptables -I INPUT -p tcp -s 192.168.34.0/16 -d 192.168.34.108 –dport 80 -j REJECT</li>
</ul>
<p><strong>允许发出dns请求</strong></p>
<ul>
<li>iptables -I OUTPUT -p udp –dport 53 -j ACCEPT</li>
<li>iptables -I INPIT -p udp –sport 53 -j ACCEPT</li>
</ul>
<p><strong>当本机作为Samba服务器时，开放相关端口允许访问，udp:137,138 tcp:139,445</strong></p>
<ul>
<li>iptables -A cifs_rules -p tcp –dport 139 -j ACCEPT</li>
<li>iptables -A cifs_rules -p tcp –dport 445 -j ACCEPT</li>
<li>iptables -A cifs_rules -p udp –dport 137:138 -j ACCEPT</li>
<li>iptables -A cifs_rules -j RETURN (如果本链中没有规则被匹配到，则将请求返回给调用者)</li>
<li>iptables -I INPUT 5 -S 172.18.0.0/16 -j cifs_rules</li>
</ul>
<p>如果要删除该自定义链，则</p>
<ul>
<li>iptables -D INPUT 5 </li>
<li>iptables -F cifs_rules</li>
<li>iptables -X cifs_rules</li>
</ul>
<h4 id="显式扩展实战"><a href="#显式扩展实战" class="headerlink" title="显式扩展实战"></a>显式扩展实战</h4><p><strong>multiport扩展：以离散的方式定义多个端口匹配，最多指定15个端口，用：隔开的算作一个端口</strong><br>[!] –sports port[,port,port:port,…] 指定多个源端口<br>[!] –destination-ports,–dports port[,port|,port:port]…指定多个目标端口<br>[!] –ports port[,port|,port:port]…多个源或目标端口<br><strong>示例</strong></p>
<ul>
<li>iptables -A INPUT -s 172.16.0.0/16 -d 172.16.100.10 -p tcp -m multiport –dports 20:22,80 -j ACCEPT</li>
</ul>
<p><strong>iprange扩展：指明连续的(但一般不是整个网段)ip地址范围</strong><br>[!] –src-range from[-to] 源IP地址范围<br>[!] –dst-range from[-to] 目标IP地址范围<br><strong>示例</strong></p>
<ul>
<li>iptables -A INPUT -d 172.16.1.100 -p tcp –dport 80 -m iprange –src-range 172.16.1.5-172.16.1.10 -j DROP</li>
</ul>
<p><strong>mac扩展：指明源MAC地址，适用于：PREROUTING,FORWARD,INPUT</strong><br>[!] –mac-source XX:XX:XX:XX:XX:XX<br><strong>示例</strong></p>
<ul>
<li>iptables -A INPUT -s 172.16.0.100 -m mac –mac-source 00:50:56:12:34:56 -j ACCEPT</li>
<li>iptables -A INPUT -s 172.16.0.100 -j REJECT</li>
</ul>
<p><strong>set扩展</strong><br>set扩展依赖ipset工具，需要安装ipset包<br>yum -y install ipset<br>使用ipset创建一个集合，如果是网段使用hash:net,如果是单个网址使用hash:ip。<br>创建集合后，向集合内添加元素，然后利用该集合创建策略。<br><strong>示例</strong></p>
<ul>
<li>ipset create allowpinghosts hash:ip</li>
<li>ipset list #查看创建的列表</li>
<li>ipset add allowpinghosts 172.18.0.100</li>
<li>ipset add allowpinghosts 172.18.0.200</li>
<li>iptables -I INPUT 4 -p icmp –icmp-type 8 -m set –match-set allowpinghosts src -j ACCEPT</li>
<li>iptables -I OUTPUT 4 -p icmp –icmp-type 0 -m set –match-set allowpinghosts dst -j ACCEPT</li>
</ul>
<p><strong>string扩展：对报文中的应用层数据做字符创模式匹配检测</strong><br>–algo {bm|kmp} 字符串匹配检测算法</p>
<pre><code>bm:Boyer-Moore
kmp:Knuth-Pratt-Morris</code></pre><p>–from offset 开始偏移<br>–to offset 结束偏移<br>[!] –string pattern 要检测的字符串模式<br>[!] –hex-string pattern要检测字符串模式，16进制格式<br><strong>示例</strong></p>
<ul>
<li>iptables -I INPUT -m string –string “sex” –algo bm -j REJECT</li>
<li>iptables -I OUTPUT -m string –string “sex” –algo bm -j REJECT</li>
</ul>
<p><strong>time扩展</strong><br>根据报文达到的时间与指定的时间范围进行匹配度检测<br>–datestart YYYY[-MM[-DD[Thh[:mm[:ss]]]]] 日期<br>–datestop YYYY[-MM[-DD[Thh[:mm[:ss]]]]]<br>–timestart hh:mm[:ss] 时间<br>–timestop hh:mm[:ss]<br>[!] –monthdays day[,day…] 每个月的几号<br>[!] –weekdays day[,day…] 星期几，1 – 7 分别表示星期一到星期日<br>–kerneltz：内核时区，不建议使用，CentOS7系统默认为UTC</p>
<p><strong>connlimit扩展</strong><br>根据客户端ip做并发连接数量匹配<br>可防止CC(Challenge Collapsar挑战黑洞)攻击<br>–connlimit-upto #：连接的数量小于等于#时匹配<br>–connlimit-above #：连接的数量大于#时匹配<br>通常分别与默认的拒绝或允许策略配合使用<br><strong>例如</strong></p>
<ul>
<li>iptables -I INPUT -p tcp –dport 22 -m connlimit –connlimit-above 2 -j REJECT</li>
</ul>
<p><strong>limit扩展</strong><br>基于收发报文速率的匹配<br>令牌桶过滤器<br>–limit #[/second|/minute|/hour|/day]<br>–limit-burst number<br><strong>示例</strong></p>
<ul>
<li>iptables -I INPUT -p icmp –icmp-type 8 -m limit –limit 6/minute –limite-burst 5 -j ACCEPT</li>
</ul>
<p><strong>state扩展</strong><br>根据”连接追踪机制”去检查连接的状态，比较消耗资源<br>[!] –state state<br>conntrack机制：追踪本机上的请求和响应之间的关系<br>state状态有如下几种：<br><strong>NEW</strong>：新发出请求；连接追踪信息库中不存在此链接的相关信息条目，因此，将其识别为第一次发出的请求<br><strong>ESTABLISHED</strong>：NEW状态之后，连接追踪信息库中为其建立的条目失效之前期间内所进行的通信状态<br><strong>RELATED</strong>：新发起的但与已有连接相关联的连接，如：ftp协议中的数据连接与命令连接之间的关系<br><strong>INVALID</strong>：无效的连接，如flag标记不正确<br><strong>UNTRACKED</strong>：未进行追踪的连接，如raw表中关闭追踪</p>
<p><strong>示例</strong></p>
<ul>
<li>iptables -t filter -A INPUT -s 172.18.0.0/16 -p tcp –dport 22 -m state –state NEW,ESTABLISHED -j ACCEPT</li>
<li>iptables -t filter -d 182.18.0.230 -p tcp –dport 80 -m state –state NEW,ESTABLISHED -j ACCEPT</li>
</ul>
<p>已经追踪到的并记录下来的连接信息库</p>
<ul>
<li>/proc/net/nf_conntrack</li>
</ul>
<p>调整连接追踪功能所能够容纳的最大连接数量</p>
<ul>
<li><p>/proc/sys/net/nf_conntrack_max,各种状态的超时连接会从表中删除，当模板满载时，后续连接可能会超时，解决办法有两个</p>
<blockquote>
<p>加大nf_conntrack_max的值<br>  vi /etc/sysctl.conf<br>  net.nf_conntrack_max = 393216<br>  net.netfilter.nf_conntrack_max = 393216</p>
</blockquote>
<blockquote>
<p>减低nf_conntrack timeout时间<br>  vi /etc/sysctl.conf<br>  net.netfilter.nf_conntrack_tcp_timeout_established = 300<br>  net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120<br>  net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60<br>  net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120</p>
</blockquote>
</li>
</ul>
<p>不同的协议的连接追踪时长</p>
<ul>
<li>/proc/sys/net/netfilter/</li>
</ul>
<p>注意：centos7需要加载模块：modeprob nf_conntrack</p>
<p>开放被动模式的ftp服务</p>
<ol>
<li>装载ftp连接追踪的专用模块：<br>跟踪模块路径：/lib/modules/kernelversion/kernel/net/netfilter<br>vim /etc/sysconfig/iptables-config 配置文件<br>IPTABLES_MODULES=“nf_conntrack_ftp”<br>modproble nf_conntrack_ftp</li>
<li>放行请求报文：<br>命令连接：NEW, ESTABLISHED<br>数据连接：RELATED, ESTABLISHED<br>iptables –I INPUT -d LocalIP -p tcp -m state –state ESTABLISHED,RELATED -j<br>ACCEPT<br>iptables -A INPUT -d LocalIP -p tcp –dport 21 -m state –state NEW -j ACCEPT</li>
<li>放行响应报文：<br>iptables -I OUTPUT -s LocalIP -p tcp -m state –state ESTABLISHED -j ACCEPT</li>
</ol>
<p><strong>示例</strong><br>开放被动模式的ftp服务示例</p>
<pre><code>yum install vsftpd
systemctl start vsftpd
modprobe nf_conntrack_ftp
iptables -F
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -p tcp --dport 21 -m state --state NEW -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
iptables -P INPUT DROP
iptables -P OUTPUT DROP
iptables -vnL</code></pre><p>最后的动作包括：ACCEPT,DROP,REJECT,RETURN,LOG,SNAT,DNAT,REDIRECT,MASQUERADE…<br>其中<br>LOG:非中断target，本身不拒绝和允许，放在拒绝和允许规则之前，并将日志记录在/var/log/messages系统日志中<br> –log-level level 级别有：debug,info,notice,warning,error,crit,alert,emerg<br> –log-prefix prefix日志前缀，用于区别不同的日志，最多29个字符<br> <strong>示例</strong></p>
<ul>
<li>iptables -I INPUT -s 10.0.1.0/24 -p tcp -m multiport –dports 21:23,80 -m state –state NEW -j LOG –log-prefix “new connections:”</li>
</ul>
<p><strong>iptables策略的优化</strong>：<br>任何不允许的访问，应该在请求到达时给予拒绝<br>规则在链上的次序即为其检查时的生效次序</p>
<ol>
<li>按去哪个放行所有入栈和出站的状态为ESTABLISHED状态连接</li>
<li>谨慎放行入栈的新情求</li>
<li>有特殊目的限制访问功能，要在放行规则之前加以拒绝</li>
<li>同类规则(访问同一应用)，匹配范围小的放在前面，用于特殊处理</li>
<li>不同类的规则（访问不同应用），匹配范围大的放在前面</li>
<li>应该将那些可由一条规则能够描述的多个规则合并为一条</li>
<li>设置默认策略，建议白名单（只放行特定连接）<ul>
<li>iptables -P，不建议</li>
<li>建议在规则的最后定义规则做为默认策略</li>
</ul>
</li>
</ol>
<p>策略有效期限：使用iptables命令定义的规则，手动删除之前，其生效期限为kernel存活期限<br>将规则保存至指定文件</p>
<ul>
<li><p>centos6</p>
<blockquote>
<p>service iptables save<br>  规则将覆盖把哦哦存执/etc/sysconfig/iptables文件中</p>
</blockquote>
</li>
<li><p>centos7</p>
<blockquote>
<p>iptables-save &gt; /PATH/TO/SOME_RULES_FILE</p>
</blockquote>
</li>
</ul>
<p>将文件中的规则载入到iptables中</p>
<ul>
<li><p>centos6</p>
<blockquote>
<p>service iptables restart<br>  会自动从/etc/sysconfig/iptables重载规则</p>
</blockquote>
</li>
<li><p>centos7</p>
<blockquote>
<p>iptables-restore &lt; /PATH/FROM/SOME_RULES_FILE<br>  -n,–noflush:不清除原有规则<br>  -t,–test:仅分析生成规则集，但不提交</p>
</blockquote>
</li>
</ul>
<h3 id="iptables的网络地址转发功能"><a href="#iptables的网络地址转发功能" class="headerlink" title="iptables的网络地址转发功能"></a>iptables的网络地址转发功能</h3><p>NAT：network address translation<br>可以在PREROUTING,INPUT,OUTPUT,POSTROUTING链上做网络地址转发的相关策略，比较常见的是在PREROUTING和POSTROUTING链上做策略。<br>请求报文：修改源/目标ip，由定义如何修改<br>响应报文：修改源/目标ip，根据跟踪机制自动实现</p>
<h4 id="SNAT：source-nat-POSTROUTING-INPUT"><a href="#SNAT：source-nat-POSTROUTING-INPUT" class="headerlink" title="SNAT：source nat POSTROUTING,INPUT"></a>SNAT：source nat POSTROUTING,INPUT</h4><p>让本地网络中的主机通过某一特定地址访问外部网络，实现地址伪装，也解决了地址不够用的问题。<br>对请求报文修改源ip<br>SNAT只能在POSTROUTING链上做报文修改，因为如果在PREROUTING链上做修改，主机会认为是发给自己的报文。postrouting位置在报文刚要离开本机还未进行路由的地方。<br>iptables -t nat -A POSTROUTING  -s 172.18.0.0/16 ! -d 172.18.0.0/16 -j SNAT –to-source localhost-ip</p>
<h4 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT:"></a>DNAT:</h4><p>prerouting，位置在报文刚刚到达本机还未进行路由的地方<br>DNAT还可以做端口映射<br>iptables -t nat -A PREROUTING -d serverip -p tcp –dport 80 -j DNAT –to-destination real-serverip[:port]</p>
<h4 id="REDIRECT"><a href="#REDIRECT" class="headerlink" title="REDIRECT"></a>REDIRECT</h4><p>NAT表<br>可用于：PREROUTING OUTPUT 自定义链<br>通过改变目标IP和端口，将接受的包转发至不同端口<br>–to-ports port[-port]<br>REDIRECT可以实现对本机端口访问的报文做端口转换，例如本机的httpd监听的端口是8080，而客户端只能通过80访问，此时就可以在本机PREROUTING链上做端口转换。<br>iptables -t nat -A PREROUTING -d 本机ip –dport 80 -j REDIRECT –to-ports 8080</p>
]]></content>
      <tags>
        <tag>iptables</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>CA和证书</title>
    <url>/2017/06/11/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="使用gpg实现对称加密"><a href="#使用gpg实现对称加密" class="headerlink" title="使用gpg实现对称加密"></a>使用gpg实现对称加密</h2><pre><code>**实验：在主机A和主机B之间实现对称加密传输数据**
gpg -c file
scp file IP(将文件传输到另一台主机上)
在另一台主机上解密（与加密使用同一个密码）
    gpg -d file</code></pre><h2 id="使用gpg实现非对称加密"><a href="#使用gpg实现非对称加密" class="headerlink" title="使用gpg实现非对称加密"></a>使用gpg实现非对称加密</h2><pre><code>**实验：在主机A和主机B之间实现非对称加密传输数据**
1、现在客户端B上生成公钥：
    gpg --gen-key
    按步骤操作即可生成密钥对，放在家目录下的.gnupg目录下
2、将公钥导出
    gpg -a --export -o /data/msqpunkey
    此时公钥以文本形式导入到/data目录下
3、将导出的公钥传送到主机A
    scp key IPA/data
4、在主机A上生成密钥对，方法如上1。
5、将主机B传过来的公钥导入
    gpg --import /data/msqpubkey
6、对文件file进行加密（使用主机B的公钥）
    gpg -e -r lovey(此处指定的是公钥对应的uid) f1
    将加密后的文件传输给B
    scp f1.gpg IPB:/data
7、在主机B进行解密操作
    gpg -o f1 -d f1.gpg
8、删除本机上其余主机的公钥
    gpg --delete-keys lovey
    如果要删除本机的公钥，需要先删除本机的私钥
        gpg --delete-secret-keys lovem
        gpg --delete-keys lovem

上述方法采取非对称加密的方式存在重大安全隐患：中间人攻击。那么如何解决这个问题呢：</code></pre><h2 id="CA和证书"><a href="#CA和证书" class="headerlink" title="CA和证书"></a>CA和证书</h2><h3 id="建立私有CA，并实现证书申请"><a href="#建立私有CA，并实现证书申请" class="headerlink" title="建立私有CA，并实现证书申请"></a>建立私有CA，并实现证书申请</h3><pre><code>1、在服务器上建立私有CA
    cd /etc/pki/CA
    (umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048)
    openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650
    touch index.txt
    echo 00 &gt; serial
2、在客户端申请证书
    (umask 077;openssl genrsa -out app.key 1024)
    openssl req -new -key app.key -out app.csr
    scp app.csr 服务器IP:/etc/pki/CA/z
3、在服务器上颁发证书
    openssl ca -in app.csr -out /etc/pki/CA/certs/app.crt -days 1000
    scp /etc/pki/CA/certs/app.crt 客户端:
4、脚本实现
    creat_ca.sh
    request_crt.sh</code></pre><h2 id="tls协议和openssl工具"><a href="#tls协议和openssl工具" class="headerlink" title="tls协议和openssl工具"></a>tls协议和openssl工具</h2><pre><code>HTTPS：http协议经过tls协议加密。
HTTPS工作原理：
    1、客户端向HTTPS服务器发送请求
    2、服务器回应证书（被CA签过名的公钥，CA信息等）
    3、客户端检查证书（拿CA的公钥解密，要争有效期等）
    4、检查如果没通过会发出警告信息，检查通过后客户端生成一个随机key（秘钥），并用服务器的公钥加密key，发送给服务器
    5、服务器用自身私钥解密解密客户端发送的随机key，并用此key加密之后的传输数据。</code></pre><h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>OpenSSL是一个开源项目，由三个组件组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL：多用途的额明航工具，由openssl包提供</span><br><span class="line">libcrypto：加密算法库，由openssl-libs提供</span><br><span class="line">libssl：加密模块应用库，实现了ssl及tls，由nss包提供</span><br></pre></td></tr></table></figure>
<p>openssl命令：<br>        两种运行模式：<br>            交互模式<br>            批处理模式<br>        标准命令，消息摘要命令，加密命令<br>            标准命令：enc,ca,req,…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl实现对文件的对称加密：</span><br><span class="line">	openssl enc -e -des3 -a -salt -in input-file -out output-file</span><br><span class="line">解密</span><br><span class="line">	openssl enc -d -des3 -a -salt -in input-file -out output-file</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl生成用户密码：</span><br><span class="line">	openssl passwd -1 -salt SALT(最多8位)</span><br><span class="line">	openssl passwd -1 -salt centos</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl生成随机数：</span><br><span class="line">	openssl rand -base64|-hex NUM</span><br><span class="line">	NUM:表示字节数，使用-hex,每个字符为16进制，相当于4位二进制，出现的字符数为NUM*2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用openssl生成秘钥对</span><br><span class="line">	生成私钥</span><br><span class="line">		openssl genrsa -out &#x2F;PATH&#x2F;TO&#x2F;PRIVATEKEY.FILE NUM_BITS</span><br><span class="line">		(umask 077;openssl genrsa -out test.key -des3 2048)</span><br><span class="line">		将加密key解密：</span><br><span class="line">			openssl rsa -in test.key -out test2.key</span><br><span class="line">	从私钥中提取公钥</span><br><span class="line">		openssl rsa -in PRIVATEKEYFILE -pubout -out PUBLICKEYFILE</span><br><span class="line">	利用公钥进行加密</span><br><span class="line">		openssl  rsautl  -encrypt  -in  file  -inkey  test_pub.key  -pubin  -out  file.en</span><br><span class="line">		-in指定要加密的文件，-inkey指定密钥，-pubin表明是用纯公钥文件加密，-out为加密后的文件。</span><br><span class="line">	利用公钥进行解密</span><br><span class="line">		openssl rsautl -decrypt -in file.en -inkey test.key -out file.de</span><br><span class="line">		-in指定被加密的文件，-inkey指定私钥文件，-out为解密后的文件</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机数生成器：伪随机数</span><br><span class="line">	键盘和鼠标，块设备中断</span><br><span class="line">	&#x2F;dev&#x2F;random：仅从熵池中返回随机数；随机数用尽，阻塞</span><br><span class="line">	&#x2F;dev&#x2F;urandom：从熵池中返回随机数；随机数用尽，会利用软件生成为随机数，非阻塞</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>利用cobbler自动安装系统</title>
    <url>/2017/05/27/cobbler/</url>
    <content><![CDATA[<h2 id="在centos7实现基于PXE安装centos6，7"><a href="#在centos7实现基于PXE安装centos6，7" class="headerlink" title="在centos7实现基于PXE安装centos6，7"></a>在centos7实现基于PXE安装centos6，7</h2><p><strong>安装dhcp、tftp、http、syslinux等相关服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#yum -y install dhcp httpd tftp-server syslinux</span></span><br></pre></td></tr></table></figure>

<p><strong>将光盘挂载到httpd共享目录下，将应答文件也放入其中</strong><br>如果不知道应答文件如何制作，请移步至<em>制作自动安装光盘和U盘</em>篇了解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mount /dev/sr0 /app/httpd/htdocs/centos/6/os/x86_64</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mkdir /app/httpd/htdocs/ksdir/&#123;6,7&#125; -p</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp ks6.cfg /app/httpd/htdocs/ksdir/6/</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp ks.cfg /app/httpd/htdocs/ksdir/7/</span></span><br></pre></td></tr></table></figure>

<p><strong>将启动需要的相关引导文件拷贝到tftpd的默认目录下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mkdir /var/lib/tftpboot/centos&#123;6,7&#125;</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp /app/httpd/htdocs/centos/7/os/x86_64/isolinux/&#123;vmlinuz,initrd.img&#125; /var/lib/tftpboot/centos7/</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp /app/httpd/htdocs/centos/6/os/x86_64/isolinux/&#123;vmlinuz,initrd.img&#125; /var/lib/tftpboot/centos6/</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp /usr/share/syslinux/&#123;pxelinux.0,menu.c32&#125; /var/lib/tftpboot</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mkdir /var/lib/tftpboot/pxelinux.cfg</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cp /app/httpd/htdocs/centos/7/os/x86_64/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default</span></span><br></pre></td></tr></table></figure>

<p>最终tftp默认目录下的文件结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#tree /var/lib/tftpboot/</span></span><br><span class="line">/var/lib/tftpboot/</span><br><span class="line">├── centos6</span><br><span class="line">│   ├── initrd.img</span><br><span class="line">│   └── vmlinuz</span><br><span class="line">├── centos7</span><br><span class="line">│   ├── initrd.img</span><br><span class="line">│   └── vmlinuz</span><br><span class="line">├── menu.c32</span><br><span class="line">├── pxelinux.0</span><br><span class="line">└── pxelinux.cfg</span><br><span class="line">    └── default</span><br></pre></td></tr></table></figure>

<p>其中引导菜单default的内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /var/lib/tftpboot/pxelinux.cfg/default </span></span><br><span class="line">default menu.c32</span><br><span class="line">timeout 100</span><br><span class="line"></span><br><span class="line">display boot.msg</span><br><span class="line"></span><br><span class="line">menu title PXE Install CentOS</span><br><span class="line"></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Auto install mini CentOS 7</span><br><span class="line">  menu default</span><br><span class="line">  kernel centos7/vmlinuz</span><br><span class="line">  append initrd=centos7/initrd.img ks=http://192.168.34.108/ksdir/7/ks.cfg</span><br><span class="line"></span><br><span class="line">label linux</span><br><span class="line">  menu label ^Auto install mini CentOS 6</span><br><span class="line">  kernel centos6/vmlinuz</span><br><span class="line">  append initrd=centos6/initrd.img ks=http://192.168.34.108/ksdir/7/ks6.cfg</span><br><span class="line"></span><br><span class="line">label <span class="built_in">local</span></span><br><span class="line">  menu label Boot from ^<span class="built_in">local</span> drive</span><br><span class="line">  localboot 0xffff</span><br></pre></td></tr></table></figure>

<p><strong>dhcp配置文件中的子网分配如下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /etc/dhcp/dhcpd.conf</span></span><br><span class="line">subnet 192.168.34.0 netmask 255.255.255.0 &#123;</span><br><span class="line">      range 192.168.34.10 192.168.34.90;</span><br><span class="line">      option routers 192.168.34.1;</span><br><span class="line">      option domain-name-servers 8.8.8.8;</span><br><span class="line">      next-server 192.168.34.108;</span><br><span class="line">      filename <span class="string">"pxelinux.0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开启dhcp服务和tftp服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#systemctl start dhcp tftpd.socket</span></span><br></pre></td></tr></table></figure>
<p>此时，在新建助理上就可以实现基于http的自动安装</p>
<h2 id="利用cobbler制作自动安装centos"><a href="#利用cobbler制作自动安装centos" class="headerlink" title="利用cobbler制作自动安装centos"></a>利用cobbler制作自动安装centos</h2><p><strong>安装cobbler</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#yum -y install cobbler</span></span><br></pre></td></tr></table></figure>

<p><strong>启动cobbler等相关服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#systemctl start httpd tftp.socket dhcpd cobblerd</span></span><br></pre></td></tr></table></figure>

<p><strong>执行cobbler检查</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler check</span></span><br><span class="line">The following are potential configuration items that you may want to fix:</span><br><span class="line"></span><br><span class="line">1 : The <span class="string">'server'</span> field <span class="keyword">in</span> /etc/cobbler/settings must be <span class="built_in">set</span> to something other than localhost, or kickstarting features will not work.  This should be a resolvable hostname or IP <span class="keyword">for</span> the boot server as reachable by all machines that will use it.</span><br><span class="line">2 : For PXE to be functional, the <span class="string">'next_server'</span> field <span class="keyword">in</span> /etc/cobbler/settings must be <span class="built_in">set</span> to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.</span><br><span class="line">3 : change <span class="string">'disable'</span> to <span class="string">'no'</span> <span class="keyword">in</span> /etc/xinetd.d/tftp</span><br><span class="line">4 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run <span class="string">'cobbler get-loaders'</span> to download them, or, <span class="keyword">if</span> you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files <span class="keyword">in</span> this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The <span class="string">'cobbler get-loaders'</span> <span class="built_in">command</span> is the easiest way to resolve these requirements.</span><br><span class="line">5 : <span class="built_in">enable</span> and start rsyncd.service with systemctl</span><br><span class="line">6 : debmirror package is not installed, it will be required to manage debian deployments and repositories</span><br><span class="line">7 : The default password used by the sample templates <span class="keyword">for</span> newly installed machines (default_password_crypted <span class="keyword">in</span> /etc/cobbler/settings) is still <span class="built_in">set</span> to <span class="string">'cobbler'</span> and should be changed, try: <span class="string">"openssl passwd -1 -salt 'random-phrase-here' 'your-password-here'"</span> to generate new one</span><br><span class="line">8 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them</span><br><span class="line"></span><br><span class="line">Restart cobblerd and <span class="keyword">then</span> run <span class="string">'cobbler sync'</span> to apply changes.</span><br></pre></td></tr></table></figure>
<p>根据check的提示信息修改cobbler配置文件，并执行相关动作<br>配置文件需要修改的内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line">default_password_crypted: &quot;$1$3BMeiH.s$mtrUL&#x2F;wNANnV7z1QUduwU0&quot;   #更改默认root密码</span><br><span class="line">server: 192.168.34.17 	#修改cobbler服务器地址，以使客户端能够连接，默认127.0.0.1别的主机无法连接</span><br><span class="line">next_server: 192.168.34.17   	#指定tftp服务器地址</span><br><span class="line">manage_dhcp: 1 	#允许cobbler管理tftp的配置文件，此时要配合修改&#x2F;etc&#x2F;cobbler&#x2F;dhcp.template</span><br></pre></td></tr></table></figure>
<p>修改完之后，执行动作使cobbler从github自动下载启动菜单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler get-loaders  #如果节点不能访问互联网，需要安装syslinux包，然后复制/usr/share/syslinux/&#123;pxelinux.0,memu.c32&#125;等文件至/var/lib/cobbler/loaders/目录中</span></span><br></pre></td></tr></table></figure>

<p>导入光盘镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler import --path=/app/httpd/htdocs/centos/7/os/x86_64/ --name=centos-7.5-x86_64 --arch=x86_64</span></span><br></pre></td></tr></table></figure>

<p>向cobbler导入应答文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cp ks.cfg /var/lib/cobbler/kickstarts/</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cobbler profile add --name=centos7.5-x86_64_mini --distro=centos7.5-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks.cfg</span></span><br></pre></td></tr></table></figure>

<p>此时查看cobbler的引导文件中的菜单项会多出一项刚才添加的选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">		[root@node01 ~]<span class="comment">#cat /var/lib/tftpboot/pxelinux.cfg/default </span></span><br><span class="line">DEFAULT menu</span><br><span class="line">PROMPT 0</span><br><span class="line">MENU TITLE Cobbler | http://cobbler.github.io/</span><br><span class="line">TIMEOUT 200</span><br><span class="line">TOTALTIMEOUT 6000</span><br><span class="line">ONTIMEOUT <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">LABEL <span class="built_in">local</span></span><br><span class="line">        MENU LABEL (<span class="built_in">local</span>)</span><br><span class="line">        MENU DEFAULT</span><br><span class="line">        LOCALBOOT -1</span><br><span class="line"></span><br><span class="line">LABEL centos-6.10-x86_64</span><br><span class="line">        kernel /images/centos-6.10-x86_64/vmlinuz</span><br><span class="line">        MENU LABEL centos-6.10-x86_64</span><br><span class="line">        append initrd=/images/centos-6.10-x86_64/initrd.img ksdevice=bootif lang=  kssendmac text  ks=http://192.168.34.108/cblr/svc/op/ks/profile/centos-6.10-x86_64</span><br><span class="line">        ipappend 2</span><br><span class="line"></span><br><span class="line">LABEL centos-7.5-x86_64</span><br><span class="line">        kernel /images/centos-7.5-x86_64/vmlinuz</span><br><span class="line">        MENU LABEL centos-7.5-x86_64</span><br><span class="line">        append initrd=/images/centos-7.5-x86_64/initrd.img ksdevice=bootif lang=  kssendmac text  ks=http://192.168.34.108/cblr/svc/op/ks/profile/centos-7.5-x86_64</span><br><span class="line">        ipappend 2</span><br><span class="line"></span><br><span class="line">LABEL centos7.5-x86_64</span><br><span class="line">        kernel /images/centos7.5-x86_64/vmlinuz</span><br><span class="line">        MENU LABEL centos7.5-x86_64</span><br><span class="line">        append initrd=/images/centos7.5-x86_64/initrd.img ksdevice=bootif lang=  kssendmac text  ks=http://192.168.34.108/cblr/svc/op/ks/profile/centos7.5-x86_64</span><br><span class="line">        ipappend 2</span><br><span class="line"></span><br><span class="line">LABEL centos7.5-x86_64_mini</span><br><span class="line">        kernel /images/centos7.5-x86_64/vmlinuz</span><br><span class="line">        MENU LABEL centos7.5-x86_64_mini</span><br><span class="line">        append initrd=/images/centos7.5-x86_64/initrd.img ksdevice=bootif lang=  kssendmac text  ks=http://192.168.34.108/cblr/svc/op/ks/profile/centos7.5-x86_64_mini</span><br><span class="line">        ipappend 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MENU end</span><br></pre></td></tr></table></figure>

<p>查看cobbler distro列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler distro list</span></span><br></pre></td></tr></table></figure>

<p>查看cobbler profile列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler profile list</span></span><br></pre></td></tr></table></figure>

<p>同步cobbler配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cobbler sync</span></span><br></pre></td></tr></table></figure>

<p>此时，就可以在一个干净机器上基于http安装系统。</p>
<h3 id="cobbler目录介绍"><a href="#cobbler目录介绍" class="headerlink" title="cobbler目录介绍"></a>cobbler目录介绍</h3><p><strong>配置文件目录 /etc/cobbler</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;settings : cobbler 主配置文件</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;iso&#x2F;: iso模板配置文件</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;pxe: pxe模板文件</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;power: 电源配置文件</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;user.conf: web服务授权配置文件</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;users.digest: web访问的用户名密码配置文件</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;dhcp.template : dhcp服务器的的配置末班</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;dnsmasq.template : dns服务器的配置模板</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;tftpd.template : tftp服务的配置模板</span><br><span class="line">&#x2F;etc&#x2F;cobbler&#x2F;modules.conf : 模块的配置文件</span><br></pre></td></tr></table></figure>

<p><strong>数据目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;config&#x2F;: 用于存放distros，system，profiles 等信息配置文件</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;triggers&#x2F;: 用于存放用户定义的cobbler命令</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;kickstart&#x2F;: 默认存放kickstart文件</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;cobbler&#x2F;loaders&#x2F;: 存放各种引导程序</span><br></pre></td></tr></table></figure>

<p><strong>镜像目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;cobbler&#x2F;ks_mirror&#x2F;: 导入的发行版系统的所有数据</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;cobbler&#x2F;images&#x2F; : 导入发行版kernel和initrd镜像用于远程网络启动</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;cobbler&#x2F;repo_mirror&#x2F;: yum 仓库存储目录</span><br></pre></td></tr></table></figure>

<p><strong>日志目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;log&#x2F;cobbler&#x2F;installing: 客户端安装日志</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;cobbler&#x2F;cobbler.log : cobbler日志</span><br></pre></td></tr></table></figure>

<h3 id="cobbler命令介绍"><a href="#cobbler命令介绍" class="headerlink" title="cobbler命令介绍"></a>cobbler命令介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cobbler check 核对当前设置是否有问题</span><br><span class="line">cobbler list 列出所有的cobbler元素</span><br><span class="line">cobbler report 列出元素的详细信息</span><br><span class="line">cobbler sync 同步配置到数据目录,更改配置最好都要执行下</span><br><span class="line">cobbler reposync 同步yum仓库</span><br><span class="line">cobbler distro 查看导入的发行版系统信息</span><br><span class="line">cobbler system 查看添加的系统信息</span><br><span class="line">cobbler profile 查看配置信息</span><br></pre></td></tr></table></figure>

<h3 id="cobbler重要参数"><a href="#cobbler重要参数" class="headerlink" title="cobbler重要参数"></a>cobbler重要参数</h3><p><strong>/etc/cobbler/settings中重要的参数设置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_password_crypted: &quot;$1$gEc7ilpP$pg5iSOj&#x2F;mlxTxEslhRvyp&#x2F;&quot;</span><br><span class="line">manage_dhcp：1</span><br><span class="line">manage_tftpd：1</span><br><span class="line">pxe_just_once：1</span><br><span class="line">next_server：&lt; tftp服务器的 IP 地址&gt;</span><br><span class="line">server：&lt;cobbler服务器的 IP 地址&gt;</span><br></pre></td></tr></table></figure>

<h2 id="cobbler的web管理实现"><a href="#cobbler的web管理实现" class="headerlink" title="cobbler的web管理实现"></a>cobbler的web管理实现</h2><p>安装cobbler-web</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#yum -y install cobbler-web</span></span><br></pre></td></tr></table></figure>

<p>重启httpd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#systemctl reload httpd</span></span><br></pre></td></tr></table></figure>

<p>此时在浏览器就可以以可视化方式配置cobbler，并实现自动安装系统</p>
<p>用浏览器配置cobbler需要用户和口令，安装cobbler-web会自带一个用户cobbler，密码也是cobbler。也可以自己添加用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#htdigest /etc/cobbler/users.digest Cobbler username</span></span><br></pre></td></tr></table></figure>

<p>也可以更改cobbler用户验证方式，使用系统账户管理cobbler-web<br>验证方式在/etc/cobbler/modules.conf中修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[authentication]</span><br><span class="line">module &#x3D; authn_pam</span><br></pre></td></tr></table></figure>

<p>在系统中新建用户用户登录cobbler</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#useradd -s /sbin/nologin cobbleradmin</span></span><br><span class="line">[root@node01 ~]<span class="comment">#echo "centos"|passwd --stdin cobbleradmin</span></span><br></pre></td></tr></table></figure>

<p>将用户信息添加到/etc/cobbler/users.conf中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#sed -n '/^[^#]/p' /etc/cobbler/users.conf </span></span><br><span class="line">[admins]</span><br><span class="line">admin = <span class="string">"cobbleradmin"</span></span><br><span class="line">cobbler = <span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>此时，就可以使用此系统用户登录管理cobbler</p>
]]></content>
      <tags>
        <tag>cobbler</tag>
        <tag>自动安装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建DNS服务器</title>
    <url>/2017/04/21/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><strong><em>本实验从搭建dns只缓存服务器，到搭建权威DNS服务器、实现DNS反向解析、泛域名解析、主备DNS服务器、创建子域，直到实现智能服务器。通过各个实验演示DNS实际场景应用，最后总结DNS相关知识概念</em></strong></p>
<h2 id="搭建正向的主权威DNS服务器"><a href="#搭建正向的主权威DNS服务器" class="headerlink" title="搭建正向的主权威DNS服务器"></a>搭建正向的主权威DNS服务器</h2><p><em>以192.168.34.108为DNS服务器，192.168.34.103为客户端</em><br><strong>安装bind包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#yum -y install bind</span></span><br></pre></td></tr></table></figure>

<p><strong>修改配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#vi /etc/named.conf</span></span><br></pre></td></tr></table></figure>
<p>将监听端口改为localhost或者注释掉；默认只监听127.0.0.1的53端口，会导致只能为本机提供DNS服务，注释或修改为localhost就可以监听所有网卡的53端口。<br>将allow-query修改为any；默认只允许本机查询，any为内置关键字，意为所有主机均可查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#vi /etc/named.rfc1912.zones</span></span><br></pre></td></tr></table></figure>
<p>在文件中添加一个域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zone &quot;msq.com&quot;&#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;msq.com.zone&quot;;                                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>创建域对应的区域数据库文件</strong><br>复制一个模板文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cp -p /var/named/&#123;named.localhost,msq.com.zone&#125;</span></span><br></pre></td></tr></table></figure>
<p>编译该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /var/named/named.msq.com </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@	IN SOA	 dns1 admin (</span><br><span class="line">					0	; serial</span><br><span class="line">					1D	; refresh</span><br><span class="line">					1H	; retry</span><br><span class="line">					1W	; expire</span><br><span class="line">					3H )	; minimum</span><br><span class="line">	NS	dns1</span><br><span class="line">dns1	A 	192.168.34.108</span><br><span class="line">www	A	8.8.8.8</span><br></pre></td></tr></table></figure>

<p><strong>启动服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#systemctl start named</span></span><br></pre></td></tr></table></figure>

<p><strong>在客户端查询</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#dig www.msq.com</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-61.el7 &lt;&lt;&gt;&gt; www.msq.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 52646</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIO</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.msq.com.			IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.msq.com.		86400	IN	A	8.8.8.8</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">msq.com.		86400	IN	NS	dns1.msq.com.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">dns1.msq.com.		86400	IN	A	192.168.34.108</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 192.168.34.108<span class="comment">#53(192.168.34.108)</span></span><br><span class="line">;; WHEN: Fri Nov 23 20:30:24 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 91</span><br></pre></td></tr></table></figure>
<p>此时得到正确解析</p>
<h2 id="搭建反向的权威DNS服务器"><a href="#搭建反向的权威DNS服务器" class="headerlink" title="搭建反向的权威DNS服务器"></a>搭建反向的权威DNS服务器</h2><p><strong>修改配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#vi /etc/named.rfc1912.zones</span></span><br><span class="line">zone <span class="string">"34.168.192.in-addr.arpa"</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">"192.168.34.zone"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>增加区域数据库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /var/named/192.168.34.zone </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@ IN SOA dnsserver admin (0 1D 1H 1W 3H)</span><br><span class="line"> NS dnsserver</span><br><span class="line">dnsserver A 192.168.34.7</span><br><span class="line">100 PTR www.msq.com</span><br><span class="line">200 PTR mail.msq.com</span><br><span class="line">101 PTR blog.msq.com</span><br></pre></td></tr></table></figure>

<p><strong>重启服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#systemctl restart named</span></span><br></pre></td></tr></table></figure>

<h2 id="实现DNS主从复制"><a href="#实现DNS主从复制" class="headerlink" title="实现DNS主从复制"></a>实现DNS主从复制</h2><p><strong>修改主服务器配置，指向从服务器并对从服务器做解析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#vi /etc/named.conf</span></span><br><span class="line">options&#123;</span><br><span class="line">	...</span><br><span class="line">	allow-transfer &#123;192.168.34.101;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#vi /var/named/msq.com.zone</span></span><br><span class="line">...</span><br><span class="line">	NS	dns2</span><br><span class="line">dns2 	A 	192.168.34.103</span><br></pre></td></tr></table></figure>

<p><strong>配置从服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cat /ec/named.conf</span></span><br><span class="line">...</span><br><span class="line">allow-transfer	&#123;none;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /etc/named.rfc1912.zones</span></span><br><span class="line">zone <span class="string">"msq.com"</span> &#123;</span><br><span class="line">	<span class="built_in">type</span>	slave;</span><br><span class="line">	masters	&#123;192.168.34.108;&#125;;</span><br><span class="line">	file	<span class="string">"slaves/msq.com.zone.slave"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>开启服务后，即可做到DNS主从同步，注意：在更改主服务器配置后，需要将serails改成一个大一点的数字，才能再重新加载配置时推送到从服务器。</p>
<h2 id="创建子域"><a href="#创建子域" class="headerlink" title="创建子域"></a>创建子域</h2><p><strong>子域和主与不在同一服务器</strong><br>在主域数据库文件中增加名字解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#vi /var/named/msq.com.zone </span></span><br><span class="line">...</span><br><span class="line">shandong	NS	dns4</span><br><span class="line">dns4	A 	192.168.34.103</span><br></pre></td></tr></table></figure>

<p>在192.168.34.103这台从服务器上增加新域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#vi /etc/named.rfc1912.zones</span></span><br><span class="line">zone <span class="string">"shandong.msq.com"</span> &#123;</span><br><span class="line">	<span class="built_in">type</span>	master;</span><br><span class="line">	file	<span class="string">"shandong.msq.com.zone"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建域数据库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#vi /var/named/shandong.msq.com.zone </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@	IN SOA	 dns4 admin (</span><br><span class="line">					13	; serial</span><br><span class="line">					1D	; refresh</span><br><span class="line">					1H	; retry</span><br><span class="line">					1W	; expire</span><br><span class="line">					3H )	; minimum</span><br><span class="line">	NS	dns4</span><br><span class="line">dns4	A	192.168.34.108</span><br><span class="line">www	A	88.88.88.88</span><br><span class="line">@	MX	10	mailsrv</span><br><span class="line">mailsrv	A	114.114.114.11</span><br><span class="line">@	A	2.2.2.6</span><br><span class="line">*	A	3.3.3.6</span><br></pre></td></tr></table></figure>


<p><strong>子域和主域在同一服务器</strong><br>在配置文件中增加一个域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#vi /etc/named.rfc1912.zones</span></span><br><span class="line">...</span><br><span class="line">zone <span class="string">"beijing.msq.com"</span> &#123;</span><br><span class="line">	<span class="built_in">type</span> master;</span><br><span class="line">	file <span class="string">"beijing.msq.com.zone"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为beijing域新增域数据库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /var/named/beijing.msq.com.zone </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@	IN SOA	 dns4 admin (</span><br><span class="line">					13	; serial</span><br><span class="line">					1D	; refresh</span><br><span class="line">					1H	; retry</span><br><span class="line">					1W	; expire</span><br><span class="line">					3H )	; minimum</span><br><span class="line">	NS	dns4</span><br><span class="line">dns4	A	192.168.34.108</span><br><span class="line">www	A	88.88.88.88</span><br><span class="line">@	MX	10	mailsrv</span><br><span class="line">mailsrv	A	114.114.114.11</span><br><span class="line">@	A	2.2.2.6</span><br><span class="line">*	A	3.3.3.6</span><br></pre></td></tr></table></figure>
<p>此时，一个子域就添加成功了</p>
<h2 id="DNS区域转发功能开启"><a href="#DNS区域转发功能开启" class="headerlink" title="DNS区域转发功能开启"></a>DNS区域转发功能开启</h2><p>在转发服务器开启转发功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#vi /etc/named.conf</span></span><br><span class="line">...</span><br><span class="line">forword first;</span><br><span class="line">forwarders &#123;192.168.34.103;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>实现区域转发功能，需要在/etc/named.conf中关闭两项安全功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnssec-enable no;</span><br><span class="line">dnssec-validation no;</span><br></pre></td></tr></table></figure>


<h2 id="实现智能DNS"><a href="#实现智能DNS" class="headerlink" title="实现智能DNS"></a>实现智能DNS</h2><p><strong>在主配置文件曾加acl设置</strong><br>在DNS主配置文件中增加三个acl权限设定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /etc/named.conf</span></span><br><span class="line">acl shandong &#123;</span><br><span class="line">	192.168.34.0/24;</span><br><span class="line">&#125;;</span><br><span class="line">acl beijing &#123;</span><br><span class="line">	172.18.0.0/16;</span><br><span class="line">&#125;;</span><br><span class="line">acl hangzhou &#123;</span><br><span class="line">	any;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">view view_beijing &#123;</span><br><span class="line">	match-clients &#123;beijing;&#125;;</span><br><span class="line">	include <span class="string">"/etc/named.rfc1912.zones"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">view view_shandong &#123;</span><br><span class="line">	match-clients &#123;shandong;&#125;;</span><br><span class="line">	include <span class="string">"/etc/named.rfc1912.zones.sd"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">view view_hangzhou &#123;</span><br><span class="line">	match-clients &#123;hangzhou;&#125;;</span><br><span class="line">	include <span class="string">"/etc/named.rfc1912.zones.hz"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：一旦使用了view，所有的zone都只能定义在view内，否则无效！</p>
<p><strong>增加三个相应的库配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ls /etc/named.rfc*</span></span><br><span class="line">/etc/named.rfc1912.zones.bj     /etc/named.rfc1912.zones.sd</span><br><span class="line">/etc/named.rfc1912.zones.hz</span><br></pre></td></tr></table></figure>
<p>其内容为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /etc/named.rfc1912.zones.bj</span></span><br><span class="line">zone <span class="string">"msq.com"</span> &#123;</span><br><span class="line">	<span class="built_in">type</span> master;</span><br><span class="line">	file <span class="string">"msq.com.zone.bj"</span>; <span class="comment">#此处不同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>增加三个对应的域数据库文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#ls /var/named/msq.com.zone.*</span></span><br><span class="line">/var/named/msq.com.zone.bj  /var/named/msq.com.zone.sd</span><br><span class="line">/var/named/msq.com.zone.hz</span><br></pre></td></tr></table></figure>
<p>为显示区别，将其中的A记录分别解析为不同的IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /var/named/msq.com.zone.hz </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@	IN SOA	 dns1 admin (</span><br><span class="line">					14	; serial</span><br><span class="line">					1D	; refresh</span><br><span class="line">					1H	; retry</span><br><span class="line">					1W	; expire</span><br><span class="line">					3H )	; minimum</span><br><span class="line">	NS	dns1</span><br><span class="line">dns1	A	192.168.34.108 <span class="comment">#此处的地址解析设为不同的IP地址</span></span><br><span class="line">www	A	3.3.3.3</span><br></pre></td></tr></table></figure>
<p>配置完毕，在客户端分别以三个网段的ip去解析<a href="http://www.msq.com，会得到不同的地址，说明不同区域的用户会访问离自己的最近的DNS服务器。实现智能DNS服务器搭建" target="_blank" rel="noopener">www.msq.com，会得到不同的地址，说明不同区域的用户会访问离自己的最近的DNS服务器。实现智能DNS服务器搭建</a></p>
<h2 id="DNS服务器搭建知识汇总"><a href="#DNS服务器搭建知识汇总" class="headerlink" title="DNS服务器搭建知识汇总"></a>DNS服务器搭建知识汇总</h2><p><strong>与数据库文件内容详解</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /var/named/msq.com.zone </span></span><br><span class="line"><span class="variable">$TTL</span> 1D</span><br><span class="line">@				IN 			SOA	 			dns1 			admin (</span><br><span class="line">当前数据库名		固定写法		起始授权记录		DNS服务器名 		管理员邮箱</span><br><span class="line">					11	; serial，版本号，主从复制时用</span><br><span class="line">					1D	; refresh，从服务器的拉取间隔</span><br><span class="line">					1H	; retry，拉取失败时的重试时间</span><br><span class="line">					1W	; expire，若一直拉取失败，从服务器的生命周期，超过此时长，从服务器的数据不再供查询</span><br><span class="line">					3H )	; minimum，若果用户查询的域名无法解析，规定时间内由缓存服务器恢复用户同样求情，本服务器不再响应。</span><br><span class="line">	NS	dns1 	<span class="comment">#name server解析到本域的dns服务器，需要配合A记录解析成IP</span></span><br><span class="line">	NS	dns2</span><br><span class="line">dns2	A	192.168.34.101</span><br><span class="line">dns1	A	192.168.34.108</span><br><span class="line">www		CNAME	websrv</span><br><span class="line">websrv	A	1.1.1.1</span><br><span class="line">websrv	A 	5.5.5.5</span><br><span class="line">websrv 	A 	9.9.9.9	</span><br><span class="line">@	A	2.2.2.2</span><br><span class="line">*	A	3.3.3.3-</span><br><span class="line"><span class="comment">#配置邮件服务器解析</span></span><br><span class="line">@			MX			10 							mailsrv1</span><br><span class="line"><span class="comment">#本域域名	记录类型		优先级；数字越小优先级越高		名字</span></span><br><span class="line">@	MX 	20 	mailsrv2</span><br><span class="line">mailsrv1	A 	10.10.10.11 	<span class="comment">#对名字做A记录解析到IP地址</span></span><br><span class="line">mailsrv2 	A 	11.11.11.11</span><br></pre></td></tr></table></figure>

<h2 id="rndc工具小结"><a href="#rndc工具小结" class="headerlink" title="rndc工具小结"></a>rndc工具小结</h2><p><strong>rndc常用命令：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法：rndc COMMAND</span><br><span class="line">reload: 重载主配置文件和区域解析库文件</span><br><span class="line">reload zonename: 重载区域解析库文件</span><br><span class="line">retransfer zonename: 手动启动区域传送，而不管序列号是否增加</span><br><span class="line">notify zonename: 重新对区域传送发通知</span><br><span class="line">reconfig: 重载主配置文件</span><br><span class="line">querylog: 开启或关闭查询日志文件&#x2F;var&#x2F;log&#x2F;message</span><br><span class="line">trace: 递增debug一个级别</span><br><span class="line">trace LEVEL: 指定使用的级别</span><br><span class="line">notrace：将调试级别设置为 0</span><br><span class="line">flush：清空DNS服务器的所有缓存记录</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>awk精讲</title>
    <url>/2017/03/12/awk%E7%B2%BE%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="awk介绍"><a href="#awk介绍" class="headerlink" title="awk介绍"></a>awk介绍</h2><p>awk：Aho,Weinberger,Kernghan,报告生成器，格式化文本输出<br>有多种版本：New awk（nawk），GNU awk（ gawk）<br>gawk：模式扫描和处理语言<br>基本用法：</p>
<pre><code>awk [options] &apos;program&apos; var=value file…
awk [options] -f programfile var=value file…
awk [options] &apos;BEGIN{action;… }pattern{action;… }END{action;… }&apos; file ...
awk 程序可由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句
块，共3部分组成
program 通常是被放在单引号中
选项：
    -F “分隔符” 指明输入时用到的字段分隔符
    -v var=value 变量赋值</code></pre><p>awk语言：</p>
<pre><code>基本格式：awk [options] &apos;program&apos; file...
    program：pattern{action statements;...}
        patern和action：
            pattern部分决定动做语句合适出发及触发事件
                BEGIN,END
            action statements对数据进行处理，放在{}内指明
                print，printf
分隔符、域和记录
    awk执行时，由分隔符分割的字段（域）标记$1,$2...$n称为域标识。$0为所有域，注意：此时和shell中变量$符含义不同
    文件的每一行称为一个记录
    省略action，则默认执行print $0操作</code></pre><p>awk工作原理：</p>
<pre><code>第一步：
    执行BEGIN{action}语句块中的语句
第二步：
    从文件或标准输入(stdin)读取一行，然后执行pattern{action}语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。
第三步：
    当读至输入流末尾时，执行END{action;...}语句块
    BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中
    END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块
    pattern语句块中的通用命令是最重要的部分，也是可选的。如果没有提供pattern语句块，则默认执行{print}，即打印每一个读取到的行，awk读取的每一行都会执行该语句块</code></pre><p>print格式：print item1,item2,…</p>
<p>要点：</p>
<pre><code>1、都好分隔符
2、输出item可以字符串，也可以数值；当前记录的字段、变量或awk的表达式
3、如果省略item，相当于print $0</code></pre><p>示例：</p>
<pre><code>awk &apos;{print &quot;hello,awk&quot;}&apos;
awk –F: &apos;{print}&apos; /etc/passwd
awk –F: &apos;{print &quot;wang&quot;}&apos; /etc/passwd
awk –F: &apos;{print $1}&apos; /etc/passwd
awk –F: &apos;{print $0}&apos; /etc/passwd
awk –F: &apos;{print $1”\t”$3}&apos; /etc/passwd
grep &quot;^UUID&quot;/etc/fstab | awk &apos;{print $2,$4}&apos;</code></pre><p>printf命令：</p>
<p>格式化输出：printf “FORMAT”, item1, item2, …</p>
<pre><code>(1) 必须指定FORMAT
(2) 不会自动换行，需要显式给出换行控制符，\n
(3) FORMAT中需要分别为后面每个item指定格式符</code></pre><p>格式符：与item一一对应</p>
<pre><code>%c：显示字符的ASCII码
%d, %i：显示十进制整数
%e, %E：显示科学计数法数值
%f：显示为浮点数
%g, %G：以科学计数法或浮点形式显示数值
%s：显示字符串
%u：无符号整数
%%：显示%自身</code></pre><p>修饰符</p>
<pre><code>#[.#] 第一个数字控制显示的宽度；第二个#表示小数点后精度，%3.1f
- 左对齐（默认右对齐） %-15s
+ 显示数值的正负符号 %+d</code></pre><p>printf示例：</p>
<pre><code>awk -F: ‘{printf &quot;%s&quot;,$1}’ /etc/passwd
awk -F: ‘{printf &quot;%s\n&quot;,$1}’ /etc/passwd
awk -F: &apos;{printf &quot;%-20s %10d\n&quot;,$1,$3}&apos; /etc/passwd
awk -F:‘ {printf &quot;Username: %s\n&quot;,$1}’ /etc/passwd
awk -F: ‘{printf “Username: %s,UID:%d\n&quot;,$1,$3}’ /etc/passwd
awk -F: ‘{printf &quot;Username: %15s,UID:%d\n&quot;,$1,$3}’ /etc/passwd
awk -F: ‘{printf &quot;Username: %-15s,UID:%d\n&quot;,$1,$3}’ /etc/passwd</code></pre><h3 id="awk变量："><a href="#awk变量：" class="headerlink" title="awk变量："></a>awk变量：</h3><p><strong>内置变量</strong><br>FS：输入字段分割符，默认为空白字符</p>
<pre><code>awk -v FS=&apos;:&apos; &apos;{print $1,FS,$3}&apos; /etc/passwd
awk -F: &apos;{print $1,$3,$7}&apos; /etc/passwd</code></pre><p>OFS:输出字段分格符，默认为空白字符</p>
<pre><code>awk -v FS=&apos;:&apos; -v OFS=&apos;:&apos; &apos;{print $1,$3,$7}&apos; /etc/passwd</code></pre><p>RS:输入记录分格符，指定输入时的换行符</p>
<pre><code>awk -v RS=&apos; &apos; &apos;{print}&apos; /etc/passwd</code></pre><p>ORS:输出记录分格符，输出是用指定符号代替换行符</p>
<pre><code>awk -v RS=&apos; &apos; -v ORS=&apos;###&apos; &apos;{print}&apos; /etc/passwd</code></pre><p>NF：字段数量</p>
<pre><code>awk -F: &apos;{print NF}&apos; /etc/passwd 注意：引用变量时，变量前不需加$
awk -F: &apos;{print $(NF-1)}&apos; /etc/passwd</code></pre><p>NR:记录号</p>
<pre><code>awk &apos;{print NR}&apos; /etc/fstab;awk END &apos;{print NR}&apos; /etc/fstab</code></pre><p>FNR:各文件分别记录，记录号</p>
<pre><code>awk &apos;{print FNR}&apos; /etc/fstab /etc/inittab</code></pre><p>FILENAME:当前文件名</p>
<pre><code>awk &apos;{print FILENAME}&apos; /etc/fstab</code></pre><p>ARGC:命令行参数的个数</p>
<pre><code>awk &apos;{print ARGC}&apos; /etcfstab /etc/inittab
awk &apos;BEGIN{print ARGC}&apos; /etc/fstab /etc/inittab</code></pre><p>ARGV:数组，保存的是命令行所给定的各参数</p>
<pre><code>awk &apos;BEGIN {print ARGV[0]}&apos; /etc/fstab /etc/inittab
awk &apos;BEGIN {print ARGV[1]}&apos; /etc/fstab /etc/inittab</code></pre><p><strong>自定义变量</strong></p>
<p>1、-v var=value<br>2、在program中直接定义<br>示例：</p>
<pre><code>awk -v test=&apos;hello gawk&apos; &apos;{print test}&apos; /etc/fstab
awk -v test=&apos;hello gawk&apos; &apos;BEGIN{print test}&apos;
awk &apos;BEGIN{test=&quot;hello,gawk&quot;;print test}&apos;
awk -F:‘{sex=“male”;print $1,sex,age;age=18}’ /etc/passwd
cat awkscript
{print script,$1,$2}
awk -F: -f awkscript script=“awk” /etc/passwd</code></pre><h3 id="操作符："><a href="#操作符：" class="headerlink" title="操作符："></a>操作符：</h3><p>算数操作符：</p>
<pre><code>x+y, x-y, x*y, x/y, x^y, x%y
- x：转换为负数
+x：将字符串转换为数值</code></pre><p>字符串操作符：</p>
<pre><code>没有符号的操作符，字符串连接</code></pre><p>赋值操作符：</p>
<pre><code>=, +=, -=, *=, /=, %=, ^=，++, --</code></pre><p>比较操作符：</p>
<pre><code>==, !=, &gt;, &gt;=, &lt;, &lt;=</code></pre><p>模式匹配符：</p>
<pre><code>~：左边是否和右边匹配，包含
!~：是否不匹配</code></pre><p>示例：</p>
<pre><code>awk -F: &apos;$0 ~ /root/{print $1}‘ /etc/passwd
awk &apos;$0~“^root&quot;&apos; /etc/passwd
awk &apos;$0 !~ /root/‘ /etc/passwd
awk -F: ‘$3==0’ /etc/passwd</code></pre><p>逻辑操作符：与&amp;&amp; 或|| 非！<br>示例：<br>    awk -F: ‘$3&gt;=0 &amp;&amp; $3&lt;=1000 {print $1}’ /etc/passwd<br>    awk -F: ‘$3==0 || $3&gt;=1000 {print $1}’ /etc/passwd<br>    awk -F: ‘!($3==0) {print $1}’ /etc/passwd<br>    awk -F: ‘!($3&gt;=500) {print $3}’ /etc/passwd<br>条件表达式:(三目表达式)</p>
<pre><code>selector?if-true-expression:if-false-expression</code></pre><p>示例：</p>
<pre><code>awk -F: &apos;{$3&gt;=1000?usertype=&quot;Common User&quot;:usertype=&quot;SysUser&quot;;printf &quot;%15s:%-s\n&quot;,$1,usertype}&apos; /etc/passwd</code></pre><h3 id="awk-PATTERN"><a href="#awk-PATTERN" class="headerlink" title="awk PATTERN"></a>awk PATTERN</h3><pre><code>PATTERN:根据pattern条件，过滤匹配的行，再做处理
    1、如果未指定：空模式，匹配每一行
    2、/regular expresion/：仅处理能够模式匹配到的行，需要用/ /括起来
        awk &apos;/^UUID/{print $1}&apos; /etc/fstab
        awk &apos;!/^UUID/{print $1}&apos; /etc/fstab
    3、relational expression:关系表达式，结果为&quot;真&quot;才会被处理
        真：结果为非0值，非空字符串
        假：结果为空字符串或0值
    示例：
        awk -F: &apos;i=1;j=1{printf i,j}&apos; /etc/passwd
        awk ‘!0’ /etc/passwd ; awk ‘!1’ /etc/passwd
        awk -F: &apos;$3&gt;=1000{print $1,$3}&apos; /etc/passwd
        awk -F: &apos;$3&lt;1000{print $1,$3}&apos; /etc/passwd
        awk -F: &apos;$NF==&quot;/bin/bash&quot;{print $1,$NF}&apos; /etc/passwd
        awk -F: &apos;$NF ~ /bash$/{print $1,$NF}&apos; /etc/passwd
    4、line range：行范围
        startline,endline：/pat1/,/pat2/不支持直接给出数字格式
        awk -F: &apos;/^root\&gt;/,/^nobody\&gt;/{print $1}&apos; /etc/passwd
        awk -F: &apos;(NR&gt;=10&amp;&amp;NR&lt;=20){print NR,$1}&apos; /etc/passwd
    5、BEGIN/END模式：
        BEGIN{}：仅在开始处理文件中的文本之前执行一次
        END{}：仅在文本处理完成之后执行一次
示例：
    awk -F: &apos;BEGIN {print &quot;USER USERID&quot;}{print $1&quot;:&quot;$3}    END{print &quot;END FILE&quot;}&apos; /etc/passwd
    awk -F: &apos;{print &quot;USER USERID&quot;;print $1&quot;:&quot;$3}END{print &quot;END FILE&quot;}&apos; /etc/passwd
    awk -F: &apos;BEGIN{print &quot;USER UID \n------------&quot;}{print $1,$3}&apos; /etc/passwd
    awk -F: &apos;BEGIN{print &quot;USER UID \n---------------&quot;}{print $1,$3}END{print &quot;=================&quot;}&apos; /etc/passwd
    seq 10 | awk ‘i=0’
    seq 10 | awk ‘i=1’
    seq 10 | awk &apos;i=!i&apos;
    seq 10 | awk &apos;{i=!i;print i}‘
    seq 10 | awk ‘!(i=!i)’
    seq 10 |awk -v i=1 ‘i=!i’</code></pre><h3 id="awk-action-动作"><a href="#awk-action-动作" class="headerlink" title="awk action(动作)"></a>awk action(动作)</h3><pre><code>常用的action分类：
    1、expressions：算数，比价表达式等
    2、control statements：if，while等
    3、compound statements：组合语句
    4、input statements
    5、output statements：print等</code></pre><h3 id="awk控制语句："><a href="#awk控制语句：" class="headerlink" title="awk控制语句："></a>awk控制语句：</h3><pre><code>{statements;...}组合语句
if(condition){statements;...}
if(condition){statements;...}else{statements;...}
while(condition){statements;...}
do{statements;...}whie(condition)
for(expr1;expr2;expr3){statements;...}
break
continue
delete arry[index]
delete arry
exit</code></pre><h4 id="awk控制语句之if-else"><a href="#awk控制语句之if-else" class="headerlink" title="awk控制语句之if-else"></a>awk控制语句之if-else</h4><pre><code>语法：
    if(condition){statement;...}[else statement]
    if(condition1){statement1}else if(condition2){statement2}else{statement3}
使用场景：
    对awk取得的整行或某个字段做条件判断
示例：
    awk -F: &apos;{if($3&gt;=1000){print $1,$3}&apos; /etc/passwd
    awk -F: &apos;{if($NF==&quot;/bin/bash&quot;)print $1}&apos; /etc/passwd
    awk &apos;{if(NF&gt;5) print $0}&apos; /etc/fstab
    awk -F: &apos;{if($3&gt;=1000) {printf &quot;Common user: %s\n&quot;,$1} else {printf &quot;root or Sysuser: %s\n&quot;,$1}}&apos; /etc/passwd
    awk -F: &apos;{if($3&gt;=1000) printf &quot;Common user: %s\n&quot;,$1; else printf &quot;root or Sysuser: %s\n&quot;,$1}&apos; /etc/passwd
    df -h|awk -F% &apos;/^\/dev/{print $1}&apos;|awk &apos;$NF&gt;=80{print $1,$5}‘
    awk &apos;BEGIN{ test=100;if(test&gt;90){print &quot;very good&quot;}    else if(test&gt;60){ print &quot;good&quot;}else{print &quot;no pass&quot;}}&apos;</code></pre><h4 id="awk控制语句之while循环"><a href="#awk控制语句之while循环" class="headerlink" title="awk控制语句之while循环"></a>awk控制语句之while循环</h4><pre><code>语法：
    while(condition){statement;...}
条件:
    真：进入循环
    假：退出循环
使用场景：
    对一行内的多个字段逐一类似处理时使用
    对数组中的各元素逐一处理时使用
示例：
    awk &apos;/^[[:space:]]*linux16/{i=1;while(i&lt;=NF){print $i,length($i); i++}}&apos; /etc/grub2.cfg
    awk ‘/^[[:space:]]*linux16/{i=1;while(i&lt;=NF) {if(length($i)&gt;=10) {print $i,length($i)}; i++}}’ /etc/grub2.cfg</code></pre><h4 id="awk控制语句之do-while循环"><a href="#awk控制语句之do-while循环" class="headerlink" title="awk控制语句之do-while循环"></a>awk控制语句之do-while循环</h4><pre><code>语法：
    do {statement;...}while(condition)
意义：
    无论真假，至少执行一次循环体
示例：
    awk &apos;BEGIN{sum=0;for(i=1;i&lt;=100000;i++){sum+=i};print sum}&apos;</code></pre><h4 id="awk控制语句之for循环"><a href="#awk控制语句之for循环" class="headerlink" title="awk控制语句之for循环"></a>awk控制语句之for循环</h4><pre><code>语法：
    for(expr1;expr2;expr3){statement;...}
常见用法：
    for(variable assignment;condition;iteration process){for-body}
特殊用法：
    能够遍历数组中的元素
示例：
    awk &apos;/^[[:space:]]*linux16/{for(i=1;i&lt;=NF;i++) {print $i,length($i)}}&apos; /etc/grub2.cfg
awk中执行循环的效率比shell更高</code></pre><h4 id="awk控制语句之switch语句"><a href="#awk控制语句之switch语句" class="headerlink" title="awk控制语句之switch语句"></a>awk控制语句之switch语句</h4><pre><code>语法：
    switch(expression){case VALUE1 or /REGEXP/:statement1;case VALUE2 or /REGEXP2/:statement2;...;default:statementn}</code></pre><h4 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4><pre><code>    awk ‘BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i%2==0)continue;sum+=i}print sum}&apos;
    awk &apos;BEGIN{sum=0;for(i=1;i&lt;=100;i++){if(i==66)break;sum+=i}print sum}&apos;

    break [n]
    continue [n]

next 
    提前结束对本行处理而直接进入下一行处理(awk自身循环)
    awk -F: &apos;{if($3%2!=0){print NR,$1,$3}}&apos; /etc/passwd</code></pre><h2 id="awk数组："><a href="#awk数组：" class="headerlink" title="awk数组："></a>awk数组：</h2><pre><code>关联数组：arry[index-expression]
index-expression:
    1、可以用任意字符串；字符串要使用双引号括起来
    2、如果某数组元素实现不存在，在引用时，awk会自动创建此元素，并将其值初始化为&quot;空串&quot;
    3、若要判断数组中是否存在某元素，要使用&quot;index in arry&quot;格式进行遍历
    示例：
        weekdays[&quot;mon&quot;]=&quot;Monday&quot;
        awk &apos;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;print weekdays[&quot;mon&quot;]}&apos;
        awk &apos;!line[$0]++&apos; dupfile
        awk &apos;{!line[$0]++;print $0, line[$0]}&apos; dupfile
若要遍历数组中的每个元素，要使用for循环
    for(var in arry){for-body}
注意：var会遍历arry的每个元素，其值为arry数组的下标，而不是其值
示例：
    awk &apos;BEGIN{weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for(i in weekdays){print i,weekdays[i]}}&apos;
    netstat -tan|awk &apos;/^tcp/{state[$NF]++}END{for(i in state){print i,state[i]}}&apos;</code></pre><h2 id="awk函数"><a href="#awk函数" class="headerlink" title="awk函数"></a>awk函数</h2><h3 id="awk自带函数"><a href="#awk自带函数" class="headerlink" title="awk自带函数"></a>awk自带函数</h3><pre><code>数值处理类：
    rand():返回0和1之间的一个随机数
        aawk &apos;BEGIN{srand();for(i=1;i&lt;=10;i++)print int(rand()*100)}&apos; #生成十个1-100之间的随机整数
字符串处理类：
    length([s]):返回指定字符串的长度
        echo &quot;aidhuq39r832748wus&quot;|awk &apos;{print length($0)}&apos;
    sub(r,s,[t]):对t字符串进行搜索r表示的模式匹配的内容，并将第一个匹配内容替换为s
        echo &quot;2008:08:08 08:08:08&quot; | awk &apos;sub(/:/,“-&quot;,$1)&apos;
    gsub(r,s,[t]):对t字符串进行搜索r表示的模式匹配的内容，并全部替换为s所表示的内容
        echo &quot;2008:08:08 08:08:08&quot; | awk ‘gsub(/:/,“-&quot;,$0)&apos;
    split(s,arry,[r]):以r为分割符，切割字符串s，并将切割后的结果保存至arry所表示的数组中，第一个索引值为1，第二个索引值为2...
        netstat -tn|awk &apos;/^tcp/{split($4,arry,&quot;:&quot;);ip[arry[1]]++}END{for(i in ip){print i,ip[i]}}&apos;</code></pre><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><pre><code>格式：
    function name (parameter,parameter,...){
        statements
        return expression
    }
示例：
    cat fun.awk
    function max(x,y){
        x&gt;y?var=x:var=y
        return var
    }
    BEGIN{print max(a,b)}
    此函数实现比较两个数字的大小，并打印较大的数字的功能。</code></pre><h2 id="awk中调用shell命令"><a href="#awk中调用shell命令" class="headerlink" title="awk中调用shell命令"></a>awk中调用shell命令</h2><pre><code>system命令
    空格是awk中的字符串连接符，如果system中需要使用awk中的变量可以使用空格分隔符，或者说除了awk的变量外其他一律用&quot;&quot;引用起来
    awk &apos;BEGIN{system(&quot;hostname&quot;)}&apos;
    awk &apos;BEGIN{score=100;system(&quot;echo your score is &quot;score)}&apos;
awk脚本
将awk程序携程脚本，直接调用或执行
示例：
    cat f1.awk
        {if($3&gt;=1000)print $1,$3}
        awk -F: -f f1.awk /etc/passwd

    cat f2.awk
        #!/bin/awk -f
        #this is a awk script
        {if($3&gt;=1000)print $1,$3}
        chmod +x f2.awk
        f2.awk -F: /etc/passwd
想awk脚本传递参数
格式：
    awkfile var=value var2=value2... Inputfile
注意：
    在BEGIN过程中不可用。直到首行输入完成以后，变量才可用。可以通过-v参数，让awk在执行BEGIN之前得到变量的值。命令行中每一个指定的变量都需要一个-v参数
示例：
    cat test.awk
        #!/bin/awk -f
        {if($3&gt;=min &amp;&amp; $3&lt;=max)print $1,$3}

    chmod +x test.awk
    test.awk -F: min=100 max=200 /etc/passwd</code></pre>]]></content>
      <tags>
        <tag>awk</tag>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PAM认证机制</title>
    <url>/2017/03/10/PAM%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>(PAM架构){E:\博客图片\PAM架构.PNG}</p>
<p>认证库：文本文件，MySQL,NIS,LDAP等<br>Sun公司于1995年开发的一种于认证相关的通用框架机制<br>PAM是关注如何为服务验证用户的API，通过提供一些动态链接库和一套同一的API，将系统提供的服务和该服务的认证方式分开<br>使得系统管理员可以灵活的根据需要给不同的服务配置不同的认证方式而无需更改服务程序<br>一种认证框架，自身不做认证</p>
<p>PAM相关文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模块文件：&#x2F;lib64&#x2F;security&#x2F;*.so</span><br><span class="line">环境相关的配置：&#x2F;etc&#x2F;security&#x2F;</span><br><span class="line">主配置文件：&#x2F;etc&#x2F;pam.conf,默认不存在而是为每种应用模块提供一个专用的配置文件：&#x2F;etc&#x2F;pam.d&#x2F;APP_NAME</span><br><span class="line">注意：如果&#x2F;etc&#x2F;pam.d&#x2F;文件夹存在，则&#x2F;etc&#x2F;pam.conf将失效</span><br></pre></td></tr></table></figure>
<h3 id="pam-shells模块简介"><a href="#pam-shells模块简介" class="headerlink" title="pam_shells模块简介"></a>pam_shells模块简介</h3><p>此模块用于控制那些用户可以登录，即只有用户所使用的shell是/etc/shells文件中的一种时，才可登陆。</p>
<p><strong>查看哪些程序调用了该模块</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/pam.d/</span><br><span class="line">$ grep pam_shells *</span><br></pre></td></tr></table></figure>

<p><strong>实验：利用pam_shells模块控制用户使用su时的限制</strong><br>默认su命令不调用pam_shells模块，需增加对此模块的调用后才能使用，调用方法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'2aauth	required	pam_shells.so'</span> /etc/pam.d/su</span><br></pre></td></tr></table></figure>
<p>将/etc/shells文件中的/bin/csh注释掉，并将用户msq的shell类型改为/bin/csh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  sed -i <span class="string">'/csh/s/.*/#&amp;/'</span> /etc/shells</span><br><span class="line">$ chsh -s /bin/csh msq</span><br></pre></td></tr></table></figure>
<p>然后用su命令切换到msq用户，会发现无法正常切换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$su</span> - msq</span><br><span class="line">Password: </span><br><span class="line">su: Authentication failure</span><br></pre></td></tr></table></figure>

<h3 id="pam-securetty模块简介"><a href="#pam-securetty模块简介" class="headerlink" title="pam_securetty模块简介"></a>pam_securetty模块简介</h3><p>此模块用于控制root只能在安全的终端登录，即只有终端是/etc/securetty文件中的一种时才能用root在该终端登录</p>
<p><strong>实验：设置Telnet远程登录允许root用户登录</strong><br>修改/etc/pam.d/remote文件，使远程登录不调用pam.securetty模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'/pam.securetty/s/.*/#.*/'</span> /etc/pam.d/remote</span><br></pre></td></tr></table></figure>
<p>此时，Telnet等远程命令即可使用使用root账号直接登录，但是由于Telnet协议不加密，所以要慎用。</p>
<h3 id="pam-nologin模块简介"><a href="#pam-nologin模块简介" class="headerlink" title="pam.nologin模块简介"></a>pam.nologin模块简介</h3><p>此模块的作用为，当/var/run/nologin或/etc/nologin文件存在时，禁止普通用户使用任何方式登录系统。<br>一般在系统维护时比较实用。</p>
<h3 id="pam-limits模块简介"><a href="#pam-limits模块简介" class="headerlink" title="pam_limits模块简介"></a>pam_limits模块简介</h3><p>功能：在用户级别实现对其可使用的资源的限制，例如：可打开的文件数量，可运行的进程数量，可用内存空间。</p>
<p>修改限制的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit命令修改，立即生效，但是无法保存</span><br><span class="line">	-n 每个进程最多打开的文件描述符个数</span><br><span class="line">	-u 最大用户进程数</span><br><span class="line">	-S 使用soft（软）资源限制</span><br><span class="line">	-H 使用hard（硬）资源限制</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改配置文件：&#x2F;etc&#x2F;security&#x2F;limits.conf,&#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*.conf</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>软件包管理</title>
    <url>/2016/12/24/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E3%80%81%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1、查询命令java来自哪个rpm包。</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#type java</span></span><br><span class="line">java is /usr/bin/java</span><br><span class="line">[root@node01 ~]<span class="comment">#rpm -qf /usr/bin/java</span></span><br><span class="line">file /usr/bin/java is not owned by any package</span><br><span class="line">```  </span><br><span class="line">**2、yum的配置和使用，包括yum仓库的创建。**  </span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#vi /etc/yum.conf</span></span><br><span class="line">yum主配置文件。</span><br><span class="line">```  </span><br><span class="line">***利用centos安装光盘创建局域网仓库***  </span><br><span class="line">a、安装Apache：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#yum -y install httpd</span></span><br></pre></td></tr></table></figure>
<p>b、在/var/www/html/目录下创建挂载点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cd /var/www/html/</span></span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#mkdir centos/&#123;6,7&#125;/os/x86_64</span></span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#tree</span></span><br><span class="line">.</span><br><span class="line">└── centos</span><br><span class="line">    ├── 6</span><br><span class="line">    │   └── os</span><br><span class="line">    │       └── x86_64</span><br><span class="line">    └── 7</span><br><span class="line">        └── os</span><br><span class="line">            └── x86_64</span><br></pre></td></tr></table></figure>
<p>c、在虚拟机增加两个光驱，分别加载centos6和centos7的镜像，将两个镜像分别挂载到上述两个目录中。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 /var/www/html]<span class="comment">#mount /dev/sr1 /var/www/html/centos/6/os/x86_64/</span></span><br><span class="line">mount: /dev/sr1 is write-protected, mounting <span class="built_in">read</span>-only</span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#mount /dev/sr0 /var/www/html/centos/7/os/x86_64/</span></span><br><span class="line">mount: /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>
<p>d、开启Apache服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 /var/www/html]<span class="comment">#systemctl start httpd</span></span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#ps aux |grep httpd</span></span><br><span class="line">root       2332  0.6  0.3 230376  5164 ?        Ss   09:54   0:00 /usr</span><br><span class="line">apache     2333  0.0  0.2 232460  3148 ?        S    09:54   0:00 /usr</span><br><span class="line">apache     2334  0.0  0.2 232460  3148 ?        S    09:54   0:00 /usr</span><br><span class="line">apache     2335  0.0  0.2 232460  3148 ?        S    09:54   0:00 /usr</span><br><span class="line">apache     2336  0.0  0.2 232460  3148 ?        S    09:54   0:00 /usr</span><br><span class="line">apache     2337  0.0  0.2 232460  3148 ?        S    09:54   0:00 /usr</span><br><span class="line">root       2339  0.0  0.0 112704   972 pts/0    R+   09:54   0:00 grep</span><br><span class="line">```  </span><br><span class="line">e、在客户端备份原有yum源，新建一个以.repo结尾的yum源</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#mkdir /etc/yum.repos.d/bak</span></span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#mv /etc/yum.repos.d/* /etc/yum.repos.d/bak/</span></span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#vi /etc/yum.repos.d/base.repo</span></span><br><span class="line">[root@node01 /var/www/html]<span class="comment">#cat /etc/yum.repos.d/base.repo </span></span><br><span class="line">[base]</span><br><span class="line">name=base</span><br><span class="line">baseurl=http://172.18.132.240/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgurl=http://172.18.132.240/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="comment">#baseurl=file:///app/httpd/htdocs/centos/7/os/x86_64</span></span><br><span class="line"><span class="comment">#gpgcheck=0</span></span><br><span class="line"><span class="comment">#gpgurl=file:///app/httpd/htdocs/centos/$releasever/os/$basearch</span></span><br><span class="line">```  </span><br><span class="line">按如上方式配置好之后，一个基于centos安装光盘的局域网yum源就配置好了。可以在客户端使用 ***yum repolist*** 查看是否生效。  </span><br><span class="line">3、**编写系统初始化脚本 reset.sh，包括别名，提示符颜色，yum仓库配置文件，安装安装tree，ftp，lftp，telnet等包**  </span><br><span class="line">```bash</span><br><span class="line">[root@node01 /data/bin]<span class="comment">#cat reset.sh</span></span><br><span class="line"><span class="built_in">echo</span> PS1=<span class="string">"\[\e[1;35m\][\u@\h \w]\\$\[\e[0m\]"</span> &gt;&gt; /root/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias scandisk='echo - - - &gt; /sys/class/scsi_host/host2/scan'"</span> &gt;&gt; /root/.bashrc</span><br><span class="line">cat &gt; CentOS-Bsse.repo &lt;&lt; EOF</span><br><span class="line">[base]</span><br><span class="line">name=base</span><br><span class="line">baseurl=http://172.18.132.240/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgurl=http://172.18.132.240/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">EOF</span><br><span class="line">yum -qy install tree ftp lftp telnet </span><br><span class="line">```  </span><br><span class="line">**4、在centos7上编译安装Apache2.4源码包，并启动此服务。**  </span><br><span class="line">a、下载Apache源码包：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 /data]<span class="comment">#wget http://mirrors.shu.edu.cn/apache//httpd/httpd-2.4.35.tar.bz2</span></span><br><span class="line">```  </span><br><span class="line">b、解压httpd-2.4.35.tar.bz2</span><br><span class="line">```bash</span><br><span class="line">[root@node01 /data]<span class="comment">#tar -xf httpd-2.4.35.tar.bz2</span></span><br><span class="line">```  </span><br><span class="line">c、进入解压目录执行编译安装，需要安装相关依赖库,之后编译安装Apache。</span><br><span class="line">```bash</span><br><span class="line">[root@node01 /data]<span class="comment">#yum -y install apr-devel apr-util-devel pcre-devel openssl-devel</span></span><br><span class="line">[root@node01 /data]<span class="comment">#yum -y groupinstall "development tools"</span></span><br><span class="line">[root@node01 /data]<span class="comment">#cd httpd-2.4.35/</span></span><br><span class="line">[root@node01 /data/httpd-2.4.35]<span class="comment">#./configure --prefix=/app/httpd-2.4.35 --sysconfdir=/etc/httpd24  --enable-ssl --disable-status</span></span><br><span class="line">[root@node01 /data/httpd-2.4.35]<span class="comment">#make</span></span><br><span class="line">[root@node01 /data/httpd-2.4.35]<span class="comment">#make install</span></span><br></pre></td></tr></table></figure>
<p>d、将Apache启动脚本加入环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 /data/httpd-2.4.35]<span class="comment">#echo 'PATH=/app/httpd/bin:$PATH' &gt;&gt; /etc/profile.d/httpd.sh</span></span><br><span class="line">```  </span><br><span class="line">e、创建apache用户并将httpd进程用户改为apache：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 /data/httpd-2.4.35]<span class="comment">#useradd -r -d /var/www/ -s /sbin/nologin -u 48 apache</span></span><br><span class="line">[root@node01 ~]<span class="comment">#cat /etc/httpd24/httpd.conf |egrep "^[User|Group]"</span></span><br><span class="line">User apache</span><br><span class="line">Group apache</span><br><span class="line">```  </span><br><span class="line">f、启动apache服务：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#apachectl start</span></span><br><span class="line">[root@node01 ~]<span class="comment">#ps aux |grep httpd</span></span><br><span class="line">root       3727  0.0  0.1  72788  2240 ?        Ss   10:55   0:00 /app/httpd-2.4.35/bin/httpd -k start</span><br><span class="line">apache     3728  0.0  0.3 363836  4284 ?        Sl   10:55   0:00 /app/httpd-2.4.35/bin/httpd -k start</span><br><span class="line">apache     3729  0.0  0.3 363836  4288 ?        Sl   10:55   0:00 /app/httpd-2.4.35/bin/httpd -k start</span><br><span class="line">apache     3730  0.0  0.3 429372  4284 ?        Sl   10:55   0:00 /app/httpd-2.4.35/bin/httpd -k start</span><br><span class="line">```  </span><br><span class="line">出现上述信息说明源码编译安装Apache已经成功。  </span><br><span class="line"><span class="comment"># 磁盘存储和文件系统  </span></span><br><span class="line">**1.创建一个2G的文件系统，块大小为2048byte，预留1%的可以空间，文件系统格式为ext4，卷标为TEST，要求此分区开机后自动挂载至/<span class="built_in">test</span>目录，并且默认有acl挂载选项。**  </span><br><span class="line">a、创建一个2G的文件以供实验,并在该文件上创建ext4文件系统：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#dd if=/dev/zero of=ext4file bs=1M count=2048</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mkfs.ext4 -b 2048 -L test -m1 ext4file</span></span><br><span class="line">```  </span><br><span class="line">b、将开机自动挂载信息写入/etc/fstab：</span><br><span class="line">```bash</span><br><span class="line">[root@centos6 /data]<span class="comment">#cat /etc/fstab |grep "/test"</span></span><br><span class="line">UUID=b1d9dd07-681b-43d5-a95a-e55e5b8aaf8a	/<span class="built_in">test</span>	ext4	loop,acl	0 0</span><br><span class="line">```  </span><br><span class="line">**2.写一个脚本，完成如下功能：(1)列出当前系统识别到的所有磁盘设备，(2)如果磁盘数量为1，则显示其空间使用信息，否则显示最后一个磁盘上的空间使用信息**  </span><br><span class="line">```bash</span><br><span class="line">[root@node01 /data/bin]<span class="comment">#cat findfs.sh</span></span><br><span class="line">ls /lib/modules/`uname -r`/kernel/fs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"####################################################"</span></span><br><span class="line">num=`ls /dev/sd?|wc -l`</span><br><span class="line">[ <span class="variable">$num</span> -eq 1 ] &amp;&amp; df |grep `ls /dev/sd?` || df |grep `ls /dev/sd?|tail -1`</span><br><span class="line">```  </span><br><span class="line">**3.将CentOS6的CentOS-6.10-x86_64-bin-DVD1.iso和CentOS-6.10-x86_64-bin-DVD2.iso两个文件，合并成一个CentOS-6.10-x86_64-Everything.iso文件，并将其配置为yum源。**  </span><br><span class="line">a、将centod6的两张盘放入虚拟光驱并挂载。</span><br><span class="line">```bash</span><br><span class="line">[root@centos6 /data]<span class="comment">#mount /dev/sr0 /mnt/cdrom/</span></span><br><span class="line">mount: block device /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br><span class="line">[root@centos6 /data]<span class="comment">#mount /dev/sr1 /mnt/media/</span></span><br><span class="line">mount: block device /dev/sr1 is write-protected, mounting <span class="built_in">read</span>-only</span><br><span class="line">```  </span><br><span class="line">b、在/data目录下新建centos6_1.iso文件夹，并将/mnt/cdrom中的所有文件复制到该文件夹，然后将/mnt/media/Packages文件夹中的所有的rpm包移动到此目录，并将TRANS.TBL文件排序后合二为一。</span><br><span class="line">```bash</span><br><span class="line">[root@centos6 /data]<span class="comment">#cp -av /mnt/cdrom/* centos6_1.iso/</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#cp /mnt/media/Packages/*.rpm centos6_1.iso/Packages/</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#cat /mnt/media/Packages/TRANS.TBL &gt;&gt;centos6_1.iso/Packages/TRANS.TBL</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#mv centos6_1.iso/Packages/TRANS.TBL&#123;,.bak&#125;</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#sort centos6_1.iso/Packages/TRANS.TBL.bak &gt;centos6_1.iso/Packages/TRANS.TBL</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#rm -f centos6_1.iso/Packages/TRANS.TBL.bak</span></span><br></pre></td></tr></table></figure>
<p>c、将centos6_1.iso文件夹制作成centos6.iso文件，并挂载到/mnt/media文件夹下。(这里为手动使用mount命令临时挂载，如要开机自动挂载需要写入/etc/fstab文件。)  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos6 /data]<span class="comment">#mkisofs -r -o centos6.iso centos6_1.iso/</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#mount -o loop centos6.iso /mnt/media/</span></span><br></pre></td></tr></table></figure>
<p>可使用如下方式实现开机自动挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos6 /data]<span class="comment">#cat /etc/fstab</span></span><br><span class="line">UUID=93c43225-f85b-4cd3-87e1-9c94a08fb70e /mnt/media                  iso9660    loop        0 0</span><br></pre></td></tr></table></figure>
<p>d、配置yum配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos6 /data]<span class="comment">#cat /etc/yum.repos.d/base.repo </span></span><br><span class="line">[base]</span><br><span class="line">name=base</span><br><span class="line">baseurl=file:///mnt/media</span><br><span class="line">gpgcheck=0</span><br><span class="line">[root@centos6 /data]<span class="comment">#yum clean all</span></span><br><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Cleaning repos: base</span><br><span class="line">Cleaning up Everything</span><br><span class="line">Cleaning up list of fastest mirrors</span><br><span class="line">[root@centos6 /data]<span class="comment">#yum repolist</span></span><br><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">base                                      | 4.0 kB     00:00 ... </span><br><span class="line">base/primary_db                           | 4.7 MB     00:00 ... </span><br><span class="line">repo id                        repo name                   status</span><br><span class="line">base                           base                        6,713</span><br><span class="line">repolist: 6,713</span><br></pre></td></tr></table></figure>
<p>至此，一个将两张光盘合为一个yum本地yun仓库的方法已经实现并且可用。如果要将该yum源作为局域网yum源使用，需安装httpd服务，并将centos6.iso挂在到httpd的相关目录下，有关httpd的安装上述题目中有详细步骤，这里不在赘述。<br><strong>4.创建一个可用空间为1G的RAID1设备，文件系统为ext4，有一个空闲盘，开机可自动挂载至/backup目录。</strong><br>a、在磁盘上使用fdisk命令创建三个1G空间的分区。<br>b、将三个分区组合成raid1,并将挂在信息写入/etc/fstab实现开机自动挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos6 /data]<span class="comment">#mdadm -C -n2 -x1 -l 1 /dev/md0 /dev/sda&#123;6,7,8</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#blkid /dev/md0</span></span><br><span class="line">/dev/md0: UUID=<span class="string">"8f55f137-4e8f-4650-9afc-3b8f2857d2f7"</span> TYPE=<span class="string">"ext4"</span></span><br><span class="line">[root@centos6 /data]<span class="comment">#echo "UUID=8f55f137-4e8f-4650-9afc-3b8f2857d2f7   /backup ext4 defaults 0 0"&gt;&gt;/etc/fstab</span></span><br></pre></td></tr></table></figure>
<p><strong>5.创建由三块硬盘组成的可用空间为2G的RAID5设备，要求其chunk大小为256k，文件系统为ext4，开机可自动挂载至/mydata目录。</strong><br>a、在centos虚拟机内新增三块容量为20G的硬盘以共实验，并在每块硬盘上使用fdisk命令创建一个容量为2G的分区。<br>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#lsblk</span></span><br><span class="line">sdb       8:16   0   20G  0 disk  </span><br><span class="line">└─sdb1    8:17   0    1G  0 part  </span><br><span class="line">sdc       8:32   0   20G  0 disk  </span><br><span class="line">└─sdc1    8:33   0    1G  0 part   </span><br><span class="line">sdd       8:48   0   20G  0 disk  </span><br><span class="line">└─sdd1    8:49   0    1G  0 part</span><br></pre></td></tr></table></figure><br>b、利用这三个分区组合成raid5并实现开机自动挂载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#mdadm -C -l5 -n3 -c 256 /dev/md2 /dev/sd&#123;b,c,d&#125;1</span></span><br><span class="line">mdadm: array /dev/md2 started.</span><br><span class="line">[root@node01 ~]<span class="comment">#mkfs.ext4 /dev/md2 </span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line">[root@node01 ~]<span class="comment">#blkid /dev/md2</span></span><br><span class="line">/dev/md2: UUID=<span class="string">"4a1e0a12-6a0c-47cf-8a27-3fe9f062703f"</span> TYPE=<span class="string">"ext4"</span></span><br><span class="line">[root@node01 ~]<span class="comment">#echo "UUID=4a1e0a12-6a0c-47cf-8a27-3fe9f062703f  /mydata  ext4  defaults  0 0" &gt;&gt; /etc/fstab</span></span><br></pre></td></tr></table></figure>
<p><strong>6.创建一个至少有两个PV组成的大小为20G的名为testvg的VG；要求PE大小为16MB，而后在卷组中创建大小为5G的逻辑卷testlv；挂载至/users目录</strong><br>a、添加两个大小为20G的硬盘并在每个硬盘创建一个10G大小的分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#lsblk</span></span><br><span class="line">sdb      8:16   0   20G  0 disk </span><br><span class="line">├─sdb1   8:17   0    1G  0 part </span><br><span class="line">└─sdb2   8:18   0   10G  0 part </span><br><span class="line">sdc      8:32   0   20G  0 disk </span><br><span class="line">├─sdc1   8:33   0    1G  0 part </span><br><span class="line">└─sdc2   8:34   0   10G  0 part </span><br><span class="line">```  </span><br><span class="line">b、创建vg，在vg中创建lv，并实现挂载。</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#pvcreate /dev/sd&#123;b,c&#125;2</span></span><br><span class="line">  Physical volume <span class="string">"/dev/sdb2"</span> successfully created.</span><br><span class="line">  Physical volume <span class="string">"/dev/sdc2"</span> successfully created.</span><br><span class="line">[root@node01 ~]<span class="comment">#pvs</span></span><br><span class="line">  PV         VG Fmt  Attr PSize  PFree </span><br><span class="line">  /dev/sdb2     lvm2 ---  10.00g 10.00g</span><br><span class="line">  /dev/sdc2     lvm2 ---  10.00g 10.00g</span><br><span class="line">[root@node01 ~]<span class="comment">#vgcreate testvg /dev/sd&#123;b,c&#125;2</span></span><br><span class="line">  Volume group <span class="string">"testvg"</span> successfully created</span><br><span class="line">[root@node01 ~]<span class="comment">#vgdisplay</span></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               testvg</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               &lt;19.97 GiB</span><br><span class="line">  PE Size               16.00 MiB</span><br><span class="line">  Total PE              1278</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       1278 / &lt;19.97 GiB</span><br><span class="line">  VG UUID               SEUFJ4-70KX-Lo8o-Xysa-3EEj-sv0z-8jLBaI</span><br><span class="line">[root@node01 ~]<span class="comment">#lvcreate -L 5G -n testlv testvg</span></span><br><span class="line">  Logical volume <span class="string">"testlv"</span> created.</span><br><span class="line">[root@node01 ~]<span class="comment">#mkfs.ext4 /dev/testvg/testlv</span></span><br><span class="line">[root@node01 ~]<span class="comment">#blkid /dev/testvg/testlv</span></span><br><span class="line">/dev/testvg/testlv: UUID=<span class="string">"e51b109d-2505-4249-80a3-e607ae4c476c"</span> TYPE=<span class="string">"xfs"</span> </span><br><span class="line">[root@node01 ~]<span class="comment">#mkdir /users</span></span><br><span class="line">[root@node01 ~]<span class="comment">#mount /dev/testvg/testlv /users/</span></span><br><span class="line">[root@node01 ~]<span class="comment">#df /users/</span></span><br><span class="line">Filesystem                1K-blocks  Used Available Use% Mounted on</span><br><span class="line">/dev/mapper/testvg-testlv   5232640 32944   5199696   1% /users</span><br><span class="line">```  </span><br><span class="line">**7.新建用户archlinux，要求其家目录为/users/archlinux,而后su切换至archlinux用户，复制/etc/pam.d目录至自己的家目录**  </span><br><span class="line">a、创建用户：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#useradd -d /users/archlinux archlinux</span></span><br><span class="line">[root@node01 ~]<span class="comment">#getent passwd archlinux</span></span><br><span class="line">archlinux:x:1007:1010::/users/archlinux:/bin/bash</span><br><span class="line">```  </span><br><span class="line">b、切换用户并执行剩余操作：</span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#su - archlinux</span></span><br><span class="line">[archlinux@node01 ~]$ cp -a /etc/pam.d/* .</span><br><span class="line">```  </span><br><span class="line">**8.扩展testlv至7G，要求archlinux用户的文件不能丢失**</span><br><span class="line">a、扩展testlv的容量为7G  </span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[root@node01 ~]<span class="comment">#lvextend -L 7G /dev/testvg/testlv </span></span><br><span class="line">  Size of logical volume testvg/testlv changed from 5.00 GiB (320 extents) to 7.00 GiB (448 extents).</span><br><span class="line">  Logical volume testvg/testlv successfully resized.</span><br><span class="line">[root@node01 ~]<span class="comment">#resize2fs /dev/testvg/testlv</span></span><br><span class="line">```  </span><br><span class="line">经过上述操作，已经实现对testlv的在线扩容，并且archlinux用户文件没有丢失。  </span><br><span class="line">**9.收缩testlv至3G，要求archlinux用户的文件不能丢失**  </span><br><span class="line">```bash</span><br><span class="line">[root@centos6 ~]<span class="comment">#umount /users/</span></span><br><span class="line">[root@centos6 ~]<span class="comment">#e2fsck -f /dev/testvg/testlv</span></span><br><span class="line">[root@centos6 ~]<span class="comment">#resize2fs /dev/testvg/testlv 3G</span></span><br><span class="line">resize2fs 1.41.12 (17-May-2010)</span><br><span class="line">Resizing the filesystem on /dev/testvg/testlv to 786432 (4k) blocks.</span><br><span class="line">The filesystem on /dev/testvg/testlv is now 786432 blocks long.</span><br><span class="line">[root@centos6 ~]<span class="comment">#mount /dev/testvg/testlv /users/</span></span><br><span class="line">[root@centos6 ~]<span class="comment">#ls /users/archlinux/</span></span><br><span class="line">abrt-cli-root        remote</span><br><span class="line">atd                  run_init</span><br><span class="line">chfn                 runuser</span><br><span class="line">chsh                 runuser<span class="_">-l</span></span><br><span class="line">config-util          screen</span><br><span class="line">```  </span><br><span class="line">经过试验，在缩减容量后，用户archlinux的数据并没有丢失情况发生，暂定为正常。  </span><br><span class="line">**10.对testlv创建快照，并尝试基于快照备份数据，验证快照的功能**  </span><br><span class="line">a、给testlv创建快照</span><br><span class="line">```bash</span><br><span class="line">root@centos6 ~]<span class="comment">#lvcreate -n testlv_snap -s -p r -L 1G /dev/testvg/testlv </span></span><br><span class="line">  Logical volume <span class="string">"testlv_snap"</span> created.</span><br><span class="line">[root@centos6 ~]<span class="comment">#lvs</span></span><br><span class="line">  LV          VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  testlv      testvg owi-aos--- 3.00g                                                    </span><br><span class="line">  testlv_snap testvg sri<span class="_">-a</span><span class="_">-s</span>--- 1.00g      testlv 0.00</span><br></pre></td></tr></table></figure>
<p>b、将lv快照挂在到/mnt，删除archlinux用户家目录下的文件做测试。</p>
<pre><code class="bash">[root@centos6 ~]<span class="comment">#mount /dev/testvg/testlv_snap /mnt/</span>
mount: block device /dev/mapper/testvg-testlv_snap is write-protected, mounting <span class="built_in">read</span>-only
[root@centos6 ~]<span class="comment">#rm -f  /users/archlinux/sudo </span>
[root@centos6 ~]<span class="comment">#ls /mnt/archlinux/sudo</span>
/mnt/archlinux/sudo</code></pre>
<p>从上述实验看出，删除archlinux用户家目录下的sudo文件后，在快照testlv_snap中仍能看到该文件，起到了快照的功能，实验结束。</p>
]]></content>
  </entry>
  <entry>
    <title>搭建DHCP服务器</title>
    <url>/2016/11/21/%E6%90%AD%E5%BB%BADHCP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><strong>DHCP简介</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动态获取IP地址，UDP协议</span><br><span class="line">主要用途：</span><br><span class="line">	用于内部网络和网络服务供应商自动分配IP地址给用户</span><br><span class="line">	用于内部网络管理员作为对所有电脑集中管理的手段</span><br><span class="line">使用场景：</span><br><span class="line">	自动化安装系统</span><br><span class="line">	解决IPV4资源不足的问题</span><br></pre></td></tr></table></figure>
<h3 id="DHCP自动获取地址过程"><a href="#DHCP自动获取地址过程" class="headerlink" title="DHCP自动获取地址过程"></a>DHCP自动获取地址过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DHCP DISCOVERY：客户端到服务器</span><br><span class="line">DHCP OFFER：服务器到客户端</span><br><span class="line">DHCP REQUEST：客户端到服务器</span><br><span class="line">DHCP ACK：服务器到客户端</span><br></pre></td></tr></table></figure>

<p><strong>DHCP获取地址过程</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 /data/iso]<span class="comment">#dhclient -d</span></span><br><span class="line">Internet Systems Consortium DHCP Client 4.2.5</span><br><span class="line">Copyright 2004-2013 Internet Systems Consortium.</span><br><span class="line">All rights reserved.</span><br><span class="line">For info, please visit https://www.isc.org/software/dhcp/</span><br><span class="line"></span><br><span class="line">Listening on LPF/ens37/00:0c:29:03:24:26</span><br><span class="line">Sending on   LPF/ens37/00:0c:29:03:24:26</span><br><span class="line">Listening on LPF/ens33/00:0c:29:03:24:1c</span><br><span class="line">Sending on   LPF/ens33/00:0c:29:03:24:1c</span><br><span class="line">Sending on   Socket/fallback</span><br><span class="line">DHCPDISCOVER on ens37 to 255.255.255.255 port 67 interval 7 (xid=0xd064c5c)</span><br><span class="line">DHCPDISCOVER on ens33 to 255.255.255.255 port 67 interval 5 (xid=0x1e827aa6)</span><br><span class="line">DHCPREQUEST on ens33 to 255.255.255.255 port 67 (xid=0x1e827aa6)</span><br><span class="line">DHCPOFFER from 192.168.34.254</span><br><span class="line">DHCPACK from 192.168.34.254 (xid=0x1e827aa6)</span><br><span class="line">bound to 192.168.34.109 -- renewal <span class="keyword">in</span> 837 seconds.</span><br><span class="line">DHCPDISCOVER on ens37 to 255.255.255.255 port 67 interval 18 (xid=0xd064c5c)</span><br><span class="line">DHCPREQUEST on ens37 to 255.255.255.255 port 67 (xid=0xd064c5c)</span><br><span class="line">DHCPOFFER from 172.18.0.1</span><br><span class="line">DHCPACK from 172.18.0.1 (xid=0xd064c5c)</span><br><span class="line">bound to 172.18.134.222 -- renewal <span class="keyword">in</span> 36077 seconds.</span><br></pre></td></tr></table></figure>
<p>DHCP服务端端口：67<br>DHCP客户端端口：68</p>
<p><strong>查看DHCP获取到的地址的详细信息</strong><br>DHCP获取的地址的详细信息存放在/var/lib/dhclient/dhclient.leases文件中</p>
<p><strong>跨网段的DHCP服务解决办法</strong><br>使用DHCP relay agent即DHCP中继代理服务</p>
<p><strong>DHCP同网段有多个服务器提供服务</strong><br>DHCP服务必须基于先到先得的原则，即哪个服务器提供的地址先到达客户端，就使用该地址。</p>
<h3 id="实验：搭建DHCP服务器"><a href="#实验：搭建DHCP服务器" class="headerlink" title="实验：搭建DHCP服务器"></a>实验：搭建DHCP服务器</h3><p><strong>安装dhcp软件包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install dhcp</span><br></pre></td></tr></table></figure>

<p><strong>将配置模板覆盖到原来的配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure>
<p>dhcp服务器配置范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/dhcp/dhcpd.conf</span><br><span class="line">subnet 192.168.34.0 netmask 255.255.255.0 &#123; <span class="comment">#提供地址的网段和子网掩码</span></span><br><span class="line">	range 192.168.34.10 192.168.34.200; <span class="comment">#提供的具体主机的范围</span></span><br><span class="line">	option routers 192.168.34.1; <span class="comment">#提供的网关地址</span></span><br><span class="line">	option domain-name-servers 8.8.8; <span class="comment">#提供的dns服务器的地址，可以配置多个，以逗号分隔</span></span><br><span class="line">	next-server 192.168.34.7; <span class="comment">#tftp服务器地址</span></span><br><span class="line">	filename <span class="string">"pxelinux.0"</span>; <span class="comment">#要从tftp服务器下载的文件(最后这两行是和自动安装相关的配置)</span></span><br><span class="line">&#125;</span><br><span class="line">host <span class="function"><span class="title">dbsrv</span></span>()&#123;</span><br><span class="line">	hardware ethernet 物理地址 ;</span><br><span class="line">	fixed-address 192.168.34.101;</span><br><span class="line">	next-server 192.168.34.7;</span><br><span class="line">	filename <span class="string">"pxelinux.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#此设置是针对特定的主机网卡配置固定的ip地址是针对，以及从某个tftp服务器下载特定的文件</span></span><br></pre></td></tr></table></figure>

<p><strong>启动dhcp服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start dhcpd.service</span><br></pre></td></tr></table></figure>

<p>此时，在客户端使用dhclient命令即可获取到dhcp服务器提供的地地址。</p>
]]></content>
  </entry>
  <entry>
    <title>rsyslog日志管理</title>
    <url>/2016/11/18/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>日志的记录格式：日期时间    主机    进程[pid]    实践内容<br>syslogd：system application记录应用日志<br>klogd：linux kernel记录内核日志<br>C/S架构：通过TCP或UDP协议的服务完成日志记录传送，将分布在不同主机的日志实现集中管理<br><strong>rsyslog特性</strong></p>
<ul>
<li>多线程</li>
<li>UDP,TCP,SSL,TLS,RELP</li>
<li>Mysql,PGSQL,Oracle实现日志存储</li>
<li>强大的过滤器，可实现过滤记录日志信息中任意部分</li>
<li>自定义输出格式</li>
</ul>
<p><strong>ELK</strong>：elasticsearch，logstash，kibana</p>
<ul>
<li>非关系型分布式数据库</li>
<li>基于Apache软件基金会jakarta项目组的项目lucene</li>
<li>Elasticsearch是个开源分布式搜索引擎</li>
<li>Logstash对日志进行收集，分析，并将其存储供以后使用</li>
<li>kibana可以提供的日志分析友好的web界面</li>
</ul>
<h2 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h2><p>rsyslog相关术语</p>
<ul>
<li><p>facility：设施，从功能或程序上对日志进行归类</p>
<blockquote>
<p>auth, authpriv, cron, daemon,ftp,kern, lpr, mail, news, security(auth),user, uucp, local0-local7, syslog</p>
</blockquote>
</li>
<li><p>Priority 优先级别，从低到高排序</p>
<blockquote>
<p>debug, info, notice, warn(warning), err(error), crit(critical), alert,emerg(panic)</p>
</blockquote>
</li>
<li><p>帮助：man 3 syslog</p>
</li>
</ul>
<h3 id="配置rsyslog为日志服务器"><a href="#配置rsyslog为日志服务器" class="headerlink" title="配置rsyslog为日志服务器"></a>配置rsyslog为日志服务器</h3><p>修改配置文件，使rsyslog可以接收禹城客户端发来的日志，一般只开启UDP或TCP其中的一个，这里为了演示效果，所以都开启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/rsyslog.conf</span><br><span class="line"><span class="variable">$ModLoad</span> imudp</span><br><span class="line"><span class="variable">$UDPServerRun</span> 514</span><br><span class="line"><span class="variable">$ModLoad</span> imtcp</span><br><span class="line"><span class="variable">$InputTCPServerRun</span> 514</span><br></pre></td></tr></table></figure>
<p>重启rsyslog</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart rsyslog</span><br></pre></td></tr></table></figure>
<h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><p>使其产生的日志信息发往服务器，客户端的日志可以及保存在本机，同时也发往服务器，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/rsyslog.conf</span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages</span><br><span class="line">*.info;mail.none;authpriv.none;cron.none               @192.168.34.108</span><br></pre></td></tr></table></figure>
<p>此时，rsyslog产生的响应日志在本机记录的同时，也会在rsyslog中保存一份</p>
<h3 id="rsyslog将日志记录于mysql中"><a href="#rsyslog将日志记录于mysql中" class="headerlink" title="rsyslog将日志记录于mysql中"></a>rsyslog将日志记录于mysql中</h3><h4 id="大致步骤梳理"><a href="#大致步骤梳理" class="headerlink" title="大致步骤梳理"></a>大致步骤梳理</h4><p><strong>准备mysql server</strong></p>
<p><strong>在mysql server上授权rsyslog能连接至当前服务器</strong></p>
<ul>
<li>grant all on syslog.* to ‘user’@’host’ identified by ‘password’;</li>
</ul>
<p><strong>在rsyslog服务器上安装mysql模块相关的程序包</strong></p>
<ul>
<li>yum -y install rsyslog-mysql</li>
</ul>
<p><strong>为rsyslog创建数据库及表</strong></p>
<ul>
<li>mysql -uusername -hhost -ppassword &lt; /usr/share/doc/rsyslog-7.4.7/mysql-createDB.sql</li>
</ul>
<p><strong>配置rsyslog将日志保存到mysql中</strong><br>必须将加载模块写入modules语句块中，将规则写入rules语句块中。</p>
<pre><code>#### MODULES ####
$ModLoad ommysql
#### RULES ####
facility.priority :ommysql:DBHOST,DBNAME,DBUSER, PASSWORD</code></pre><h3 id="实验：rsyslog将日志记录于mysql中"><a href="#实验：rsyslog将日志记录于mysql中" class="headerlink" title="实验：rsyslog将日志记录于mysql中"></a>实验：rsyslog将日志记录于mysql中</h3><p>本实验次用A(192.168.34.108)作为rsyslog服务器，用B(192.168.34.102)作为mariadb服务器做实验。</p>
<h4 id="在B服务器配置mariadb"><a href="#在B服务器配置mariadb" class="headerlink" title="在B服务器配置mariadb"></a>在B服务器配置mariadb</h4><p><strong>安装mariadb</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ yum -y <span class="keyword">install</span> mariadb-serevr</span><br></pre></td></tr></table></figure>
<p><strong>创建一个可以用于远程登录的账号</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; grant all on *.* to root@<span class="string">'192.168.34.%'</span> identified by <span class="string">'centos'</span>;</span><br></pre></td></tr></table></figure>
<h4 id="配置rsyslog服务器"><a href="#配置rsyslog服务器" class="headerlink" title="配置rsyslog服务器"></a>配置rsyslog服务器</h4><p><strong>在rsyslog服务器安装rsyslog-mysql</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache data]<span class="comment">#yum -y install rsyslog-mysql</span></span><br><span class="line">[root@apache data]<span class="comment">#rpm -ql rsyslog-mysql</span></span><br><span class="line">/usr/lib64/rsyslog/ommysql.so</span><br><span class="line">/usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql</span><br></pre></td></tr></table></figure>
<p><strong>在服务器生成数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache data]<span class="comment">#mysql -uroot -pcentos -h192.168.34.102 &lt; /usr/share/doc/rsyslog-8.24.0/mysql-createDB.sql</span></span><br></pre></td></tr></table></figure>
<p><strong>在mariadb服务器构建一个能远程管理该数据库的账号</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; grant all on Syslog.* to <span class="string">'rsyslog'</span>@<span class="string">'192.168.34.108'</span> identofoed by <span class="string">'centos'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>配置rsyslog将数据发往mariadb</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/rsyslog.conf</span><br><span class="line"><span class="comment">#### MODULES ####</span></span><br><span class="line"><span class="variable">$LoadModule</span> ommysql <span class="comment">#此语句必须写在MODULES语句块下</span></span><br><span class="line"><span class="comment">#### RULES ####</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                :ommysql:192.168.34.102,Syslog,rsyslog,centos <span class="comment">#此语句必须写在RULES语句块下</span></span><br></pre></td></tr></table></figure>
<p><strong>重启rsyslog服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart rsyslog</span><br></pre></td></tr></table></figure>
<p>此时已经完成所有配置，mariadb服务器已经可以远程接收rsyslog服务器发过来的日志。</p>
<h3 id="其他日志文件"><a href="#其他日志文件" class="headerlink" title="其他日志文件"></a>其他日志文件</h3><p>/var/log/secure：系统安装日志，文本格式，应周期性分析<br>/var/log/btmp：当前系统上，用户的失败尝试登录相关的日志信息，二进制格式，lastb命令进行查看<br>/var/log/wtmp：当前系统上，用户正常登录系统的相关日志信息，二进制格式，last命令可以查看<br>/var/log/lastlog:每一个用户最近一次的登录信息，二进制格式，lastlog命令可以查看<br>/var/log/dmesg：系统引导过程中的日志信息，文本格式</p>
<ul>
<li>文本查看工具查看</li>
<li>专用命令dmesg查看</li>
</ul>
<p>/var/log/messages ：系统中大部分的信息<br>/var/log/anaconda : anaconda的日志</p>
<h3 id="日志管理journalctl"><a href="#日志管理journalctl" class="headerlink" title="日志管理journalctl"></a>日志管理journalctl</h3><p>systemd统一管理所有unit的启动日志，带来的好处就是，可以只用journalctl一个命令，查看所有日志(内核日志和应用日志)。日志的配置文件/etc/systemd/journald.conf<br><strong>journalctl用法</strong></p>
<p>查看所有日志(默认情况下，只保存本次启动的日志)</p>
<ul>
<li>journalctl</li>
</ul>
<p>查看内核日志(不显示应用日志)</p>
<ul>
<li>journalctl -k</li>
</ul>
<p>查看系统本次启动的日志</p>
<ul>
<li>journalctl -b</li>
<li>journalctl -b -0</li>
</ul>
<p>查看上一次启动的日志(需要更改配置)</p>
<ul>
<li>journalctl -b -1</li>
</ul>
<p>查看指定时间的日志</p>
<ul>
<li>journalctl –since=”2017-10-30 18:10:30”</li>
<li>journalctl –since “20 min ago”</li>
<li>journalctl –since yesterday</li>
<li>journalctl –since “2017-01-10” –until “2017-01-11 03:00”</li>
<li>journalctl –since 09:00 –until “1 hour ago”</li>
</ul>
<p>显示尾部的最新十行</p>
<ul>
<li>journalctl -n</li>
</ul>
<p>显示尾部指定行数的日志</p>
<ul>
<li>journalctl -n 20</li>
</ul>
<p>实时滚动显示最新日志</p>
<ul>
<li>journalctl -f</li>
</ul>
<p>查看指定服务的日志</p>
<ul>
<li>journalctl /usr/lib/systemd/systemd</li>
</ul>
<p>查看指定进程的日志</p>
<ul>
<li>journalctl _PID=1</li>
</ul>
<p>查看某个路径的脚本的日志</p>
<ul>
<li>journalctl /usr/bin/bash</li>
</ul>
<p>查看指定用户的日志</p>
<ul>
<li>journalctl _UID=33 –since today</li>
</ul>
<p>查看某个unit的日志</p>
<ul>
<li>journalctl -u nginx.service</li>
<li>journalctl -u nginx.service –since today</li>
</ul>
<p>实时滚动显示某个unit的最新日志</p>
<ul>
<li>journalctl -u nginx.service -f</li>
</ul>
<p>合并显示多个unit的日志</p>
<ul>
<li>journalctl -u nginx.service -u php-fpm.service –since today</li>
</ul>
<p>查看指定优先级(及其以上级别)的日志，共有8级<br>0: emerg<br>1: alert<br>2: crit<br>3: err<br>4: warning<br>5: notice<br>6: info<br>7: debug</p>
<ul>
<li>journalctl -p err -b</li>
</ul>
<p>日志默认分页输出，–no-pager改为正常的标准输出</p>
<ul>
<li>journalctl –no-pager</li>
</ul>
<p>以 JSON 格式（单行）输出</p>
<ul>
<li>journalctl -b -u nginx.service -o json</li>
</ul>
<p>以 JSON 格式（多行）输出，可读性更好</p>
<ul>
<li>journalctl -b -u nginx.serviceqq -o json-pretty</li>
</ul>
<p>显示日志占据的硬盘空间</p>
<ul>
<li>journalctl –disk-usage</li>
</ul>
<p>指定日志文件占据的最大空间，指定上限或阈值</p>
<ul>
<li>journalctl –vacuum-size=1G</li>
</ul>
<p>指定日志文件保存多久</p>
<ul>
<li>journalctl –vacuum-time=1years</li>
</ul>
<h3 id="更改单个服务的日志"><a href="#更改单个服务的日志" class="headerlink" title="更改单个服务的日志"></a>更改单个服务的日志</h3><p>以ssh为例，让ssh产生的日志单独记录<br><strong>修改ssh配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/ssh/sshd_config</span><br><span class="line">SyslogFacility local0</span><br></pre></td></tr></table></figure>
<p><strong>修改rsyslog配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/rsyslog.conf</span><br><span class="line">local0 /var/<span class="built_in">log</span>/openssh.log <span class="comment">#必须加在RULES语句块内</span></span><br></pre></td></tr></table></figure>
<p><strong>重启rsyslog和ssh</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart rsyslog sshd</span><br></pre></td></tr></table></figure>
<p>之后ssh产生的相关日志就会单独记录在/var/log/openssh.log文件中</p>
<h2 id="logrotate日志存储"><a href="#logrotate日志存储" class="headerlink" title="logrotate日志存储"></a>logrotate日志存储</h2>]]></content>
      <tags>
        <tag>日志管理</tag>
        <tag>rsyslog</tag>
      </tags>
  </entry>
  <entry>
    <title>利用NFS搭建网络共享存储</title>
    <url>/2016/11/13/NFS/</url>
    <content><![CDATA[<h2 id="基础知识梳理"><a href="#基础知识梳理" class="headerlink" title="基础知识梳理"></a>基础知识梳理</h2><h3 id="存储网络分类"><a href="#存储网络分类" class="headerlink" title="存储网络分类"></a>存储网络分类</h3><h4 id="直连存储DAS-Direct-Attached-Storage"><a href="#直连存储DAS-Direct-Attached-Storage" class="headerlink" title="直连存储DAS(Direct Attached Storage)"></a>直连存储DAS(Direct Attached Storage)</h4><p>存储设备与主机紧密相连，有以下特点</p>
<ul>
<li>管理成本低，实施简单</li>
<li>存储时依附在服务器上，因此存储共享受到限制</li>
<li>CPU必须同时完成磁盘存取和应用运行的双重任务，所以不利于CPU的指令周期的优化，增加系统负担。</li>
</ul>
<h4 id="网络连接存储NAS-Network-Attached-Storage"><a href="#网络连接存储NAS-Network-Attached-Storage" class="headerlink" title="网络连接存储NAS(Network Attached Storage)"></a>网络连接存储NAS(Network Attached Storage)</h4><p>通过局域网在多个文件服务器之间实现了互联，基于文件的协议(FTP,NFS,SMB/CIFS),实现文件共享，有以下特点</p>
<ul>
<li>集中管理数据，从而释放带宽、提高性能</li>
<li>可提供夸平台文件共享功能</li>
<li>可靠性较差，适用于局域网或较小的网络</li>
</ul>
<h4 id="存储区域网络SAN-Storage-Area-Networks"><a href="#存储区域网络SAN-Storage-Area-Networks" class="headerlink" title="存储区域网络SAN(Storage Area Networks)"></a>存储区域网络SAN(Storage Area Networks)</h4><p>利用高速的光纤网络连接服务器与存储设备，基于SCSI,IP,ATM等多种高级协议，实现共享存储，有以下特点</p>
<ul>
<li>服务器与存储装置两者各司其职</li>
<li>利用光纤信道来传输数据，以达到一个服务器以存储装置之间多对多的高效能、高稳定度的存储环境</li>
<li>实施复杂，管理成本高</li>
</ul>
<h3 id="NFS基础知识"><a href="#NFS基础知识" class="headerlink" title="NFS基础知识"></a>NFS基础知识</h3><p>NFS：Network File System，即网络文件系统，基于内核的文件系统，时NAS的一种实现，由SUN公司研发，通过使用NFS，用户和程序可以向访问本地文件一样访问远端系统上的文件，基于RPC(Remote Procedure Call Protocol远程过程调用)实现。</p>
<p>RPC采用C/S模式。客户机请求程序调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行</p>
<p>NFS优势：节省本地存储空间，将常用的数据,如home目录,存放在NFS服务器上且可以通过网络访问，本地终端将可减少自身存储空间的使用</p>
<p>NFS的访问授权是靠uid进行识别的，即如果服务器端授权uid为2000的用户的有写权限，客户端只要使用uid为2000的用户登录就有写权限，而不管用户名。</p>
<p>软件包：nfs-utils<br>kernel支持：nfs.ko<br>端口：2049(nfsd)，其他端口由portmap(111)分配<br>配置文件：/etc/exports,/etc/exports.d/*.exports<br>centos7不支持同一目录同时使用nfs和Samba共享，因为使用锁机制不同<br>相关软件包：rpcbind（必须），tcp_wrappers<br>centos6开始portmap进程由rpcbind代替<br>NFS服务的主要进程</p>
<ul>
<li>rpc.nsfd 最主要的NFS进程，核心服务进程，管理客户端是否可以登录</li>
<li>rpc.mountd 挂载和卸载NFS文件系统，包括权限管理</li>
<li>rpc.lockd 非必要，管理文件锁，避免同时写出错</li>
<li>rpc.statd 非必要，检查文件一致性，可修复文件</li>
</ul>
<p>日志：/var/lib/nfs/</p>
<h2 id="配置NFS服务"><a href="#配置NFS服务" class="headerlink" title="配置NFS服务"></a>配置NFS服务</h2><h3 id="配置服务器端"><a href="#配置服务器端" class="headerlink" title="配置服务器端"></a>配置服务器端</h3><p><strong>在服务器和客户端分别安装nfs-utils包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install nfs-utils</span><br></pre></td></tr></table></figure>
<p>如果操作系统为centos6，则还需要配置防火墙规则，开放NFS服务<br>配置NFS使用固定端口</p>
<pre><code>vim /etc/sysconfig/nfs
RQUOTAD_PORT=875
LOCKD_TCPPORT=32803
LOCKD_UDPPORT=32769
MOUNTD_PORT=892
STATD_PORT=662
STATD_OUTGOING_PORT=2020</code></pre><p>防火墙除了要开房上述端口，还需要开放TCP和UDP的111和2049共四个端口。</p>
<p><strong>修改配置文件</strong><br>对于要共享的目录的配置可以写在/etc/exports文件内，也可以在/etc/exports.d/目录下新建一个以.exports结尾的文件写入配置<br>配置文件格式<br>/dir     主机1(opt1,opt2…)         主机2(opt1,opt2…)…<br>主机的格式</p>
<ul>
<li><p>单个主机：ipv4，ipv6，FQDN</p>
</li>
<li><p>IP networks：两种掩码格式均支持</p>
<blockquote>
<p>172.18.0.0/255.255.0.0<br>  172.18.0.0/16</p>
</blockquote>
</li>
<li><p>wildcards：主机名通配，例如*.magedu.com，IP不可以</p>
</li>
<li><p>netgroups：NIS域的主机组，@group_name</p>
</li>
<li><p>anonymous：表示使用*通配所有客户端</p>
</li>
</ul>
<p>每个条目指定目录导出到的哪些主机，及相关的权限和选项</p>
<ul>
<li>默认选项：(ro,sync,root_squash,no_all_squash)</li>
<li>ro,rw 只读和读写</li>
<li>async 异步，数据变化后不立即写磁盘，性能高</li>
<li>sync（1.0.0后为默认）同步，数据在请求时立即写入共享</li>
<li>no_all_squash （默认）保留共享文件的UID和GID</li>
<li>all_squash 所有远程用户(包括root)都变成nfsnobody</li>
<li>root_squash （默认）远程root映射为nfsnobody,UID为65534，早期版本是4294967294 (nfsnobody)</li>
<li>no_root_squash 远程root映射成root用户</li>
<li>anonuid和anongid 指明匿名用户映射为特定用户UID和组GID，而非nfsnobody,可配合all_squash使用</li>
</ul>
<p>以共享服务器/data/目录为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/exports.d/data.exports</span><br><span class="line">/data/ 192.168.34.0/24(rw,all_squash)</span><br></pre></td></tr></table></figure>
<p>修改服务器配置之后，可以使用exportfs -r重新加配置文件使其生效，exports -v可以查看分享目录的详细分享选项。exportfs命令介绍</p>
<pre><code>-v 查看本机所有的NFS共享
-r 重读配置文件，并共享目录
-a 输出本机所有共享
-au 停止本机所有共享</code></pre><p>rpcinfo工具</p>
<pre><code>rpcinfo -p hostname
rpcinfo -s hostname 查看rpc注册程序</code></pre><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start nfs</span><br></pre></td></tr></table></figure>

<h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><p>客户端也需要安装nfs-utils，安装好之后使用如下命令查看nfs服务器共享出来的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#showmount -e 192.168.34.108</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.34.108:</span><br><span class="line">/data 172.18.0.0/16</span><br></pre></td></tr></table></figure>
<p>说明nfs服务器已经成功共享了data目录</p>
<p>客户端可以使用mount.nfs4命令进行挂载操作，mount.nfs4命令介绍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#mount.nfs4 --help</span></span><br><span class="line">usage: mount.nfs4 remotetarget dir [-rvVwfnsh] [-o nfsoptions]</span><br><span class="line">options:</span><br><span class="line">	-r		Mount file system <span class="built_in">readonly</span> <span class="comment">#以只读方式挂载</span></span><br><span class="line">	-v		Verbose <span class="comment">#显示详细信息</span></span><br><span class="line">	-V		Print version <span class="comment">#显示版本</span></span><br><span class="line">	-w		Mount file system <span class="built_in">read</span>-write <span class="comment">#以可读可写的方式挂载</span></span><br><span class="line">	-f		Fake mount, <span class="keyword">do</span> not actually mount <span class="comment">#干跑，测试是否可以挂载而不真正挂载</span></span><br><span class="line">	-n		Do not update /etc/mtab <span class="comment">#挂在完不更新/etc/fstab</span></span><br><span class="line">	-s		Tolerate sloppy mount options rather than fail </span><br><span class="line">	-h		Print this <span class="built_in">help</span></span><br><span class="line">	nfsoptions	Refer to mount.nfs(8) or nfs(5)</span><br></pre></td></tr></table></figure>

<p>在客户端挂载nfs共享目录，NFSv4支持通过挂载NFS服务器的共享根，从而浏览NFS服务器上的共享目录列表<br>mount nfsserver:/ /mnt/nfs<br>基于安全考虑，建议使用nosuid，nodev，noexec挂载选项<br>NFS相关的挂载选项</p>
<pre><code>fg（默认）前台挂载，bg后台挂载
hard（默认）持续请求，soft 非持续请求
intr 和hard配合，请求可中断
rsize和wsize 一次读和写数据最大字节数，rsize=32768
_netdev 无网络不挂载</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mount -o rw,nosuid,<span class="built_in">fg</span>,hard,intr 192.168.34.108:/data/ /mnt/</span><br></pre></td></tr></table></figure>

<h3 id="实现nfs自动挂载"><a href="#实现nfs自动挂载" class="headerlink" title="实现nfs自动挂载"></a>实现nfs自动挂载</h3><p>通过autofs包提供的功能可以实现NFS在需要时自动挂载，不需要时自动卸载的功能。<br><strong>安装autofs</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install autofs</span><br></pre></td></tr></table></figure>
<p><strong>配置autofs自动挂载nfs共享目录,计划挂载到/mnt/nfs目录下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi /etc/auto.master</span><br><span class="line">/mnt/ /etc/auto.mnt</span><br><span class="line">$ vi /etc/auto.mnt</span><br><span class="line">nfs -fstype=nfs,rw,nosuid,nodev 192.168.34.108:/data/</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>NFS</tag>
        <tag>文件共享</tag>
      </tags>
  </entry>
  <entry>
    <title>sudo管理</title>
    <url>/2016/10/29/sudo/</url>
    <content><![CDATA[<h3 id="sudo配置文件"><a href="#sudo配置文件" class="headerlink" title="sudo配置文件"></a>sudo配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#vi /etc/sudoers</span></span><br></pre></td></tr></table></figure>
<p>也可以使用visudo命令直接编辑配置文件，由于visudo命令是基于vi的，所以不带颜色，不方便浏览，可以使用export EDITOR=vim使visudo命令带颜色（写入文件以长久生效）</p>
<h3 id="配置文件书写格式："><a href="#配置文件书写格式：" class="headerlink" title="配置文件书写格式："></a>配置文件书写格式：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#sed -n '/^root/p' /etc/sudoers</span></span><br><span class="line">root	ALL=(ALL) 	ALL</span><br></pre></td></tr></table></figure>
<p>用户         主机=代表用户     拥有的权限</p>
<ul>
<li>特殊的授权方式：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /etc/sudoers.d/test</span></span><br><span class="line">msq		ALL=sudoedit</span><br></pre></td></tr></table></figure>
此条命令为授权msq用户修改sudo配置文件的权限，等价于授权msq用户所有权限<br>用法：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[msq@node01 ~]$ sudoedit /etc/sudoers</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="sudo别名"><a href="#sudo别名" class="headerlink" title="sudo别名"></a>sudo别名</h3><p>别名格式：<br>    <a href="[A-Z][0-9]_">A-Z</a>*<br>    即别名只能是大写字母开头且只包括大写字母数字额下划线组成</p>
<p>别名种类：<br>    User_Alias：用户别名<br>    Runas_Alias：代表的用户别名<br>    Host_Alias：主机别名<br>    Cmnd_Alias：命令别名</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#cat /etc/sudoers.d/test </span></span><br><span class="line">User_Alias	ADMIN02=msq,mage</span><br><span class="line">Cmnd_Alias	DISKCMD=/bin/fdisk,/bin/mkfs</span><br><span class="line">Host_Alias	LOCALNET=192.168.34.0/24</span><br><span class="line">Runas_Alias	ADMIN=root</span><br><span class="line"></span><br><span class="line">ADMIN02	LOCALNET=(ADMIN)	DISKCMD</span><br></pre></td></tr></table></figure>

<h4 id="sudo别名示例"><a href="#sudo别名示例" class="headerlink" title="sudo别名示例"></a>sudo别名示例</h4><p>示例1：<br>    Student ALL=(ALL) ALL<br>    %wheel ALL=(ALL) ALL</p>
<p>示例2：<br>    student ALL=(root) /sbin/pidof,/sbin/ifconfig<br>    %wheel ALL=(ALL) NOPASSWD: ALL<br>示例3<br>    User_Alias NETADMIN= netuser1,netuser2<br>    Cmnd_Alias NETCMD = /usr/sbin/ip<br>    NETADMIN ALL=（root） NETCMD<br>示例4<br>    User_Alias SYSADER=wang,mage,%admins<br>    User_Alias DISKADER=tom<br>    Host_Alias SERS=<a href="http://www.magedu.com,172.16.0.0/24" target="_blank" rel="noopener">www.magedu.com,172.16.0.0/24</a><br>    Runas_Alias OP=root<br>    Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod<br>    Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk<br>    SYSADER SERS= SYDCMD,DSKCMD<br>    DISKADER ALL=(OP) DSKCMD<br>示例4<br>    User_Alias ADMINUSER = adminuser1,adminuser2<br>    Cmnd_Alias ADMINCMD = /usr/sbin/useradd，/usr/sbin/usermod,<br>    /usr/bin/passwd [a-zA-Z]<em>, !/usr/bin/passwd root<br>    ADMINUSER ALL=(root) NOPASSWD:ADMINCMD，<br>    PASSWD:/usr/sbin/userdel<br>示例5<br>    Defaults:wang runas_default=tom<br>    wang ALL=(tom,jerry) ALL<br>示例6<br>    wang 192.168.1.6,192.168.1.8=(root) /usr/sbin/,!/usr/sbin/useradd<br>示例7<br>    wang ALL=(ALL) /bin/cat /var/log/messages</em> *</p>
]]></content>
  </entry>
  <entry>
    <title>inotify+rsync实现实时备份</title>
    <url>/2016/10/23/%E5%AE%9E%E6%97%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>本实验使用A（192.168.34.108）作为客户端，B（192.168.34.103）作为实时备份服务器，利用inotify对同步数据目录信息进行监控，当监控到目录相应内容变化时，利用rsync完成对数据的同步。记录利用inotify+rsync实现实时备份的过程。</p>
<h2 id="基础知识梳理"><a href="#基础知识梳理" class="headerlink" title="基础知识梳理"></a>基础知识梳理</h2><h3 id="inotify基础知识"><a href="#inotify基础知识" class="headerlink" title="inotify基础知识"></a>inotify基础知识</h3><p>linux内核高于2.6.13的版本，默认支持inotify，可使用ll /proc/sys/fs/inotify查看该目录下的文件，如果有以下文件说明服务器内核支持inotify。</p>
<pre><code>-rw-r--r-- 1 root root 0 Dec 7 10:10 max_queued_events #inotify时间队列的最大长度，如果此值太小会出现Event Queue Overflow错误，默认值为16384
-rw-r--r-- 1 root root 0 Dec 7 10:10 max_user_instances #可以监视的文件数量（单进程），默认值为8192
-rw-r--r-- 1 root root 0 Dec 6 05:54 max_user_watches #每个用户创建inotify实例最大值，默认值为128
详细的参数说明可已通过man 7 inotify查看</code></pre><p>inotify参考文档</p>
<pre><code>https://github.com/rvoicilas/inotify-tools/wiki</code></pre><p><strong>inotify-tools包主要的文件</strong></p>
<ul>
<li>inotifywait：在被监控的文件或目录上等待特定文件系统时间(open close delete等)发生，常用于实时同步的目录监控</li>
<li>inotifywatch：收集被监控的文件系统使用的统计数据，指文件系统时间发生的次数统计。</li>
</ul>
<p><strong>inotifywait命令的常用选项</strong></p>
<pre><code>-m，--monitor    始终保持事件监听
-d，--daemon        以守护进程的方式执行，和-m相似，配合-o使用
-r，--recursive    递归监控目录数据信息变化
-q，--quiet        输出少量信息事件
--timefmt &lt;fmt&gt;    指定时间输出格式
--format &lt;fmt&gt;    指定输出的格式；即市级监控输出的内容
-e                 指定监听的时间，如果省略，表示监听所有时间
--exclude &lt;pattern&gt;    指定排除文件或目录，使用扩展的正则表达式匹配的模式实现
--excludei &lt;pattern&gt;    和exclude相似，不区分大小写
-o，--outfile &lt;file&gt;        打印时间到文件中，相当于标准正确输出
-s，--syslogoutput        发送错误到syslog，相当于标准错误输出</code></pre><p><strong>其中–timefmt &lt; fmt&gt; 的格式，可以参考man 3 strftime，主要选项如下</strong></p>
<pre><code>%Y 年份信息，包含世纪信息
%y 年份信息，不包括世纪信息
%m 显示月份，范围 01-12
%d 每月的第几天，范围是 01-31
%H 小时信息，使用 24小时制，范围 00-23
%M 分钟，范围 00-59</code></pre><p>例如：–timefmt “%Y-%m-%d %H:%M” 表示按时间年-月-日 时-分的格式输出时间</p>
<p><strong>–format &lt; fmt&gt; 的格式定义的相关选项如下</strong></p>
<pre><code>%T 输出时间格式中定义的时间格式信息，通过 --timefmt option 语法格式指定时间信息
%w 事件出现时，监控文件或目录的名称信息
%f 事件出现时，将显示监控目录下触发事件的文件或目录信息，否则为空
%e 显示发生的事件信息，不同的事件默认用逗号分隔
%Xe 显示发生的事件信息，不同的事件指定用X进行分隔</code></pre><p>例如：</p>
<ul>
<li>–format “%T %w%f event: %;e”</li>
<li>–format ‘%T %w %f’</li>
</ul>
<p><strong>-e选项指定的时间类型如下</strong></p>
<pre><code>create 文件或目录创建
delete 文件或目录被删除
modify 文件或目录内容被写入
attrib 文件或目录属性改变
close_write 文件或目录关闭，在写入模式打开之后关闭的
close_nowrite 文件或目录关闭，在只读模式打开之后关闭的
close 文件或目录关闭，不管读或是写模式
open 文件或目录被打开
moved_to 文件或目录被移动到监控的目录中
moved_from 文件或目录从监控的目录中被移动
move 文件或目录不管移动到或是移出监控目录都触发事件
access 文件或目录内容被读取
delete_self 文件或目录被删除，目录本身被删除
unmount 取消挂载</code></pre><p>例如：-e create,delete,moved_to,close_write 表示当目录内有创建，删除，移动，修改时记录</p>
<p><strong>使用inotidy监控时间示例</strong></p>
<ul>
<li><p>监控一次性事件</p>
<blockquote>
<p>inotifywait /data</p>
</blockquote>
</li>
<li><p>持续监控</p>
<blockquote>
<p>inotifywait -mrq /data</p>
</blockquote>
</li>
<li><p>持续后台监控，并记录日志</p>
<blockquote>
<p>inotifywait -o /root/inotify.log -drq /data –timefmt “%Y-%m-%d %H:%M” –format “%T %w%f event: %e” </p>
</blockquote>
</li>
<li><p>持续后台监控特定事件</p>
<blockquote>
<p>inotifywait -mrq /data –timefmt “%F %H:%M” –format “%T %w%f event: %;e” -e create,delete,moved_to,close_write</p>
</blockquote>
</li>
</ul>
<h2 id="配置B服务器"><a href="#配置B服务器" class="headerlink" title="配置B服务器"></a>配置B服务器</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#cd /etc/</span></span><br><span class="line">[root@ansible etc]<span class="comment">#cp rsyncd.conf&#123;,.bak&#125; </span></span><br><span class="line">[root@ansible etc]<span class="comment">#vi rsyncd.conf</span></span><br><span class="line">uid = root <span class="comment">#以root身份执行进程</span></span><br><span class="line">gid = root <span class="comment">#进程所属组</span></span><br><span class="line">use chroot = no <span class="comment">#</span></span><br><span class="line">max connections = 0 <span class="comment">#最大连接数不限制</span></span><br><span class="line">ignore errors <span class="comment">#忽略错误</span></span><br><span class="line">exclude = lost+found/ <span class="comment">#排除该文件夹</span></span><br><span class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log <span class="comment">#日志文件存放位置</span></span><br><span class="line">pid file = /var/run/rsyncd.pid <span class="comment">#进程pid存放位置</span></span><br><span class="line">lock file = /var/run/rsyncd.lock <span class="comment">#进程锁文件存放位置</span></span><br><span class="line">reverse lookup = no <span class="comment">#不启用反向名字解析服务</span></span><br><span class="line">hosts allow = 192.168.8.0/24 <span class="comment">#允许哪个网段访问</span></span><br><span class="line">[backup] <span class="comment">#备份的模块，可以有多个</span></span><br><span class="line">path = /backup/ <span class="comment">#接收的备份存放目录</span></span><br><span class="line">comment = backup <span class="comment">#注释信息</span></span><br><span class="line"><span class="built_in">read</span> only = no <span class="comment">#可写</span></span><br><span class="line">auth users = rsyncuser <span class="comment">#同步时使用的虚拟用户账号</span></span><br><span class="line">secrets file = /etc/rsync.pass <span class="comment">#口令存放文件</span></span><br></pre></td></tr></table></figure>

<h3 id="生成服务器端口令验证文件"><a href="#生成服务器端口令验证文件" class="headerlink" title="生成服务器端口令验证文件"></a>生成服务器端口令验证文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible etc]<span class="comment">#echo "rsyncuser:centos" &gt; /etc/rsync.pass</span></span><br><span class="line">[root@ansible etc]<span class="comment">#chmod 600 /etc/rsync.pass</span></span><br></pre></td></tr></table></figure>

<h3 id="准备服务器端存放备份的目录"><a href="#准备服务器端存放备份的目录" class="headerlink" title="准备服务器端存放备份的目录"></a>准备服务器端存放备份的目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir /backup</span><br></pre></td></tr></table></figure>

<h3 id="服务器端启动rsync服务"><a href="#服务器端启动rsync服务" class="headerlink" title="服务器端启动rsync服务"></a>服务器端启动rsync服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rsync --daemon   <span class="comment">#监听873端口</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"rsync --daemon"</span> &gt; /etc/rc.d/rc.local <span class="comment">#加入开机自启</span></span><br></pre></td></tr></table></figure>

<h2 id="配置客户端A"><a href="#配置客户端A" class="headerlink" title="配置客户端A"></a>配置客户端A</h2><h3 id="客户端配置密码文件"><a href="#客户端配置密码文件" class="headerlink" title="客户端配置密码文件"></a>客户端配置密码文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"centos"</span> &gt; /etx/rsync.pass</span><br><span class="line">$ chmod 600 /etc/rsync.pass</span><br></pre></td></tr></table></figure>

<h3 id="在客户端测试同步数据"><a href="#在客户端测试同步数据" class="headerlink" title="在客户端测试同步数据"></a>在客户端测试同步数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rsync -avz --password-file=/etc/rsync.pass /data/ rsyncuser@192.168.34.103::backup</span><br></pre></td></tr></table></figure>

<h3 id="创建客户端inotify-rsync-sh脚本，实现后台监控实时备份"><a href="#创建客户端inotify-rsync-sh脚本，实现后台监控实时备份" class="headerlink" title="创建客户端inotify_rsync.sh脚本，实现后台监控实时备份"></a>创建客户端inotify_rsync.sh脚本，实现后台监控实时备份</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@apache bin]<span class="comment">#vi backup.sh </span></span><br><span class="line">SRC=<span class="string">'/data/'</span></span><br><span class="line">DEST=<span class="string">'rsyncuser@192.168.34.103::backup'</span></span><br><span class="line">inotifywait -mrq --timefmt <span class="string">'%Y-%m-%d %H-%M'</span> --format <span class="string">'%T %w %f'</span> -e \</span><br><span class="line">attrib,create,delete,moved_to,close_write <span class="variable">$&#123;SRC&#125;</span> |<span class="keyword">while</span> <span class="built_in">read</span> DATE TIME DIR \</span><br><span class="line">FILE;<span class="keyword">do</span></span><br><span class="line">        FILEPATH=<span class="variable">$&#123;DIR&#125;</span><span class="variable">$&#123;FILE&#125;</span></span><br><span class="line">        rsync -az --delete --password-file=/etc/rsync.pass <span class="variable">$&#123;SRC&#125;</span> $&#123; \</span><br><span class="line">       	DEST&#125; &amp;&amp; <span class="built_in">echo</span> <span class="string">"At <span class="variable">$&#123;TIME&#125;</span> on <span class="variable">$&#123;DATE&#125;</span>,file <span class="variable">$&#123;FILEPATH&#125;</span> was \</span></span><br><span class="line"><span class="string">       	backuped up via rsync"</span> &gt;&gt; /var/<span class="built_in">log</span>/changelist.log                    </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">[root@apache bin]<span class="comment">#bash /data/bin/backup.sh &amp;</span></span><br><span class="line">[root@apache bin]<span class="comment">#echo "bash /data/bin/backup.sh" &gt;&gt; /etc/rc.d/rc.local</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>实时备份</tag>
        <tag>rsync</tag>
        <tag>inotify</tag>
      </tags>
  </entry>
  <entry>
    <title>Raid</title>
    <url>/2016/10/12/raid/</url>
    <content><![CDATA[<h2 id="Raid简介："><a href="#Raid简介：" class="headerlink" title="Raid简介："></a>Raid简介：</h2><p>&ensp;&ensp;&ensp;&ensp;Raid技术是将多个磁盘合成一个“阵列”来提供更好的性能、冗余、或者两者都提供。  </p>
<h2 id="Raid优点："><a href="#Raid优点：" class="headerlink" title="Raid优点："></a>Raid优点：</h2><p>1、<strong><em>提高IO性能</em></strong>：磁盘并行读写。<br>2、<strong><em>提高耐用性</em></strong>：磁盘冗余来实现</p>
<h2 id="Raid实现的方式："><a href="#Raid实现的方式：" class="headerlink" title="Raid实现的方式："></a>Raid实现的方式：</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>外接式磁盘阵列</strong>：通过扩展卡提供适配能力。<br>&ensp;&ensp;&ensp;&ensp;<strong>内接式Raid</strong>：主板集成Raid控制器，安装OS前在BIOS里面配置。<br>&ensp;&ensp;&ensp;&ensp;<strong>软件Raid</strong>：通过OS来实现。  </p>
<h2 id="Raid常用组合方式简介"><a href="#Raid常用组合方式简介" class="headerlink" title="Raid常用组合方式简介"></a>Raid常用组合方式简介</h2><p>&ensp;&ensp;&ensp;&ensp;1、<strong><em>RAID0</em></strong>：&ensp;&ensp;读写性能提升，可用空间为单块硬盘的N倍（N为磁盘数量），无容错能力，最少磁盘数为2.<br>&ensp;&ensp;&ensp;&ensp;2、<strong><em>RAID1</em></strong>： 读性能提升、写性能略有下降，可用空间为所有硬盘容量的一半，最少磁盘数为2.<br>&ensp;&ensp;&ensp;&ensp;3、<strong><em>RAID5</em></strong>： 读写性能提升，可用空间为所有硬盘中损失一块硬盘呢的容量，有容错能力且允许最多损坏一块硬盘，最少磁盘数为3.<br>&ensp;&ensp;&ensp;&ensp;4、<strong><em>RAID10</em></strong>：多块磁盘先实现RAID1再实现RAID0， 读写性能提升，可用空间为所有磁盘容量的一半，有容错能力且每组镜像最多允许损坏一个磁盘。做少磁盘数4.容错能力强于<strong>RAID01</strong>。<br>&ensp;&ensp;&ensp;&ensp;5、<strong><em>RAID01</em></strong>： 多块磁盘先实现RAID0再实现RAID1,。<br>&ensp;&ensp;&ensp;&ensp;6、<strong><em>JBOD</em></strong>： 将多块磁盘的空间合并成一个大的连续空间使用。可用空间为所有磁盘数量之和。</p>
<h2 id="软件RAID实现之实现工具介绍"><a href="#软件RAID实现之实现工具介绍" class="headerlink" title="软件RAID实现之实现工具介绍:"></a>软件RAID实现之实现工具介绍:</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>mdadm</strong>：模式化工具<br>&ensp;&ensp;&ensp;&ensp;<strong><em>命令的语法格式：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mdadm [mode] &lt;raiddevice&gt; [options] &lt;component-devices&gt;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;<strong>支持的raid级别</strong>：LINEAR, RAID0, RAID1, RAID4, RAID5, RAID6, RAID10<br><strong>mode</strong>:<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;创建：-C<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;装配：-A<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;监控：-F<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;管理：-f，-r，-a<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&lt; raid device&gt;：/dev/md#<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&lt; component-device&gt;：任意块设备<br>&ensp;&ensp;&ensp;&ensp;-C：创建模式<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-n#：使用#个块设备来创建此RAID<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-l#：指明要创建的RAID级别<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-a{yes|no}：自动创建目标RAID设备的设备文件<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-c CHUNK_SIZE：指明块大小，单位K<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-x#：指明空闲盘（备用）的个数<br>&ensp;&ensp;&ensp;&ensp;-D：显示raid的详细信息<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;mdadm -D /dev/md#<br>&ensp;&ensp;&ensp;&ensp;管理模式：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-f：标记指定磁盘为损坏<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-a：添加磁盘<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;-r：移除磁盘<br>&ensp;&ensp;&ensp;&ensp;观察md的状态：cat /proc/mdstat  </p>
<h2 id="实验案例：软RAID0配置示例："><a href="#实验案例：软RAID0配置示例：" class="headerlink" title="实验案例：软RAID0配置示例："></a>实验案例：软RAID0配置示例：</h2><p>&ensp;&ensp;&ensp;&ensp;1、在虚拟机新增四块容量为10G的虚拟磁盘用于实验。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdb,&#x2F;dev&#x2F;sdc,&#x2F;dev&#x2F;sdd,&#x2F;dev&#x2F;sde</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;2、在磁盘sdb和sdc分别创建一个1G大小的分区。  </span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">[root@node01 ~]#fdisk -l &#x2F;dev&#x2F;sdb</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x757003e5</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sdb1            2048     2099199     1048576   fd  Linux raid autodetect  </span><br><span class="line">[root@node01 ~]#fdisk -l &#x2F;dev&#x2F;sdc</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sdc: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x757003e5</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sdc1            2048     2099199     1048576   fd  Linux raid autodetect</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;3、使用mdadm命令创建raid0磁盘阵列。</span><br></pre></td></tr></table></figure>
<pre><code>mdadm -C /dev/md0 -n 2 -l 0 /dev/sd{b,c}1</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;4、格式化刚才创建的raid0磁盘阵列。</span><br></pre></td></tr></table></figure>
<pre><code>mkfs.xfs /dev/md0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;5、将刚才创建的磁盘阵列挂载到&#x2F;mnt&#x2F;raid目录下。（此挂载目录可以自行指定）</span><br></pre></td></tr></table></figure>
<pre><code>mount /dev/md0 /mnt/raid</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">至此，创建的raid0磁盘阵列已经可以正常使用。  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;**扩展命令**  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;a、生成配置文件：</span><br></pre></td></tr></table></figure>
<pre><code>mdadm -Ds &gt;&gt; /etc/mdadm.conf</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b、停止raid设备：</span><br></pre></td></tr></table></figure>
<pre><code>mdadm -S /dev/md0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c、激活设备：</span><br></pre></td></tr></table></figure>
<pre><code>mdadm -As /dev/md0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d、强制启动：</span><br></pre></td></tr></table></figure>
<pre><code>mdadm -R /dev/md0</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f、删除raid信息：</span><br></pre></td></tr></table></figure>
<pre><code>mdadm --zero-superblock /dev/sdb1</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 实验案例：raid5配置示例  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;1、按上述实现步骤2在4块新增磁盘分别在创建一个容量为1G的分区用于实验。（详细过程不在赘述，参考上一实验相关步骤）  </span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;2、使用mdadm命令创建raid5磁盘阵列。</span><br></pre></td></tr></table></figure>
<pre><code>mdadm -C -n3 -x1 -l5 /dev/md1 /dev/sd{b2,c2,d1,e1}</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、格式化刚才创建的raid5磁盘阵列。</span><br></pre></td></tr></table></figure>
<pre><code>mkfs.xfs /dev/md1</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4、将创建</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;a、将raid0磁盘阵列故障模拟</span><br></pre></td></tr></table></figure>
<pre><code>mdadm /dev/md0 -f /dev/sdb1</code></pre><pre><code>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;b、移除有故障

</code></pre>]]></content>
  </entry>
  <entry>
    <title>RAID和LVM</title>
    <url>/2016/09/15/raid%E5%92%8Clvm/</url>
    <content><![CDATA[<p>RAID<br>raid简介：<br>    raid全称为廉价的磁盘冗余阵列，利用多个磁盘合成一个“阵列”来提供更好的性能、冗余，或者两者都提供。<br>raid优点：<br>    提高IO能力：磁盘并行读写。<br>    提高耐用性：磁盘冗余来实现<br>raid的级别：<br>    将多块磁盘组织在一起的工作方式有所不同<br>raid的实现方式：<br>    外接式磁盘阵列：通过扩展卡提供适配能力。<br>    内接式raid：主板集成raid控制器，安装os前现在BIOS里面配置。<br>    软raid：通过OS来实现。</p>
<p>raid的实现：<br>1、 RAID0的实现：<br>    首先为虚拟机增添两个新分区:/dev/sdb1 /dev/sdc1<br>    将两个新分区做成raid0<br>        mdadm -C -l 0 -n 2 /dev/md0 /dev/sd{b,c}1<br>    为/dev/md0创建文件系统<br>        mkfs.xfs /dev/md0<br>    将/dev/md0挂载后就可以正常使用<br>        mount /dev/md0 /mnt<br>2、 RAID5的实现：<br>    为虚拟机新增四个分区用于实验：/dev/sdb2 /dev/sdc2 /dev/sdd1 /dev/sde1</p>
<pre><code>将这四个分区合并成raid5：
    mdadm -C -l 5 -n 3 -x 1 /dev/md1 /dev/sd{b2,c2,d1,e1}
为创建的raid格式化文件系统：
    mkfs.xfs /dev/md1
将raid挂载并使用：
    mount /dev/md1 /mnt
模拟组成raid5的一块磁盘损坏，测试备用盘能否自动切换。
    mdadm /dev/md1 -f /de/sdb2</code></pre><p>3、 RAID的相关管理命令：<br>    查看raid状态<br>        mdadm -D /dev/md#<br>    生成配置文件(生成配置文件后，可以将禁用的raid重新启用)<br>        mdadm -D -s &gt;&gt;/etc/mdadm.conf<br>    将磁盘从raid中移除<br>        mdadm /dev/md1 -r /dev/sdb2<br>    将磁盘加入到raid中<br>        mdadm /dev/md1 -a /dev/sdb3<br>    禁用raid<br>        mdadm -S /dev/md1<br>    启用raid<br>        mdadm -A -s /dev/md1<br>    强制启用raid<br>        mdadm -R /dev/md1</p>
<pre><code>删除raid
    1、将raid取消挂载： umount /mnt/
    2、禁用raid：mdadm -S /dev/md1
    3、清除组成raid的相关磁盘的元数据：mdadm --zero-superblock /dev/sdb2
    4、删除分区。</code></pre><p>RAID相关知识点总结：<br>    软raid的实现通过工具mdadm进行操作。<br>    mdadm的命令语法格式为：mdadm [mode] <raiddevice> [options] <component-devices><br>        mode:<br>            创建：-C<br>            装配：-A<br>            监控：-F<br>            管理：-f,-r,-a<br>        <raiddevice>:/dev/md#<br>        <component-devices>:任意的块设备<br>            -C：创建模式<br>                -n#：使用#个块设备来创建此RAID<br>                -l#：指明要创建的raid级别<br>                -a{yes|no}：自动创建目标raid设备的设备文件<br>                -c chunk_size：指明块大小。单位为K<br>                -x#：指明空闲盘的数目<br>            -D：显示raid的详细信息<br>                mdadm -D /dev/md#<br>            管理模式：<br>                -f：标记指定的磁盘为损坏状态<br>                -r：从raid中移除指定磁盘<br>                -a：从raid中添加指定磁盘<br>            观察md的状态：cat /proc/mdstat</p>
<p>LVM<br>lvm简介：<br>    Logical Volune Manager<br>    dm:device mapper:将一个或者多个底层设备组织成一个逻辑设备的模块<br>    设备名：/dev/dm-#<br>    软连接：<br>        /dev/mapper/VG_NAME-LV_NAME<br>            /dev/mapper/vol0-root<br>        /dev/VG_NAME/LV_NAME<br>            /dev/vol0/root</p>
<p>创建逻辑卷：需要先将磁盘创建为pv，再讲pv组建成vg，然后在vg上创建lv。</p>
<p>创建逻辑卷过程：<br>    1、创建pv,创建pv之前需要先对磁盘进行分区或增加新硬盘。<br>        pvcreate /dev/sdb /dev/sdc<br>    2、将pv组合成vg<br>        vgcreate -s pe_size vg_name /dev/sdb /dev/sdc<br>    3、在vg中创建一个lv<br>        lvcreate -n lv_name -L lv_size  vg_name<br>    4、为lv创建文件系统<br>        mkfs.ext4 lv_path<br>    5、将lv挂载后即可使用。<br>        mount lv_path mountpoint</p>
<p>逻辑卷扩容：<br>    1、首先要对lv扩容，如果vg中没有剩余空间，需要先对vg进行扩容。<br>        lvextend -L +size(或者-l +100%FREE) lv_path<br>    2、同步文件系统<br>        resize2fs lv_path (只是用与ext系列文件系统，xfs文件系统需要使用xfs_gowfs /mountpoint)<br>题外话：如果vg和pv空间不足了怎么办？<br>    创建pv：pvcreate device<br>    将新建的pv加入到vg： vgextend vg_path pvPath<br>    然后在对lv进行扩容。</p>
<p>基于与xfs文件系统的扩容<br>    首先确认vg中有足够空间<br>    扩展lv<br>        lvextend -L +size lv_name<br>    同步文件系统<br>        xfs_growfs lv_path<br>    此时扩展成功，此外，基于xfs的文件系统只能扩充lv容量但是不能缩减lv容量。</p>
<pre><code>** warning：由于ext4和xfs文件系统的扩展容量命令不同，记起来比较麻烦。所以可以统一使用一个命令进行扩展。
    lvextend -r -L +size lv_path(只需这一步操作，即可扩展lv容量并自动同步文件系统（ext4和xfs通用）)</code></pre><p>逻辑卷缩小容量<br>    1、取消lv挂载<br>        umount lv_path mountpoint<br>    2、缩减文件系统<br>        首先进行文件系统检查<br>            e2fsck -f lv_path<br>        然后在缩减文件系统<br>            resize2fs lv_path size(将lv的容量缩减至size大小)<br>    3、缩减lv容量<br>        lvreduce -L size lv_path(将lv的容量缩小至size大小)<br>    4、将lv进行挂载之后就可使用<br>        mount lv_path mountpoint</p>
<p>逻辑卷的迁移：<br>    将pe使用量少的或者pv所在硬盘无法迁移的pv上的pe迁移到别的可以迁移pv上。<br>        pvmove pv_path<br>    从vg中移除无需迁移的pv<br>        vgreeduce pv_path<br>    将lv缩减至合适容量。（方法同上述缩减lv逻辑卷你容量）<br>    检查该逻辑卷或卷组的名称与将要迁移到的主机上的逻辑卷或者卷组的名称师傅冲突，如果冲突，需要修改名字。<br>        vgrename vg_name vg_newname<br>        lvrename lv_name lv_newname<br>    禁用该vg<br>        vgchange -an vg_name<br>    将vg状态设为导出状态<br>        vaexport vg_name<br>    将对应硬盘拔出并插到新的主机上面<br>    将vg设为导入状态<br>        vgimport vg_newname<br>    激活lv<br>        vgchange -ay vg_newname<br>    将该lv挂载后即可正常使用</p>
<p>lvm管理快照：</p>
<p>lvm快照简介：<br>        逻辑卷快照是特殊的逻辑卷，它是在生成快照时存在的逻辑卷的准确拷贝<br>        对于需要备份或者复制的现有数据临时拷贝以及其他操作来说，快照是最合适的选择。<br>        快照只有在他们和原来的逻辑卷不同时才会消耗空间<br>            再生成快照时会分配给它一定的空间，但是只有在原来的逻辑卷或者快照有所改变时才会使用这些空间<br>            当原来的逻辑卷中内容有所改变时，会将旧的数据复制到快照中<br>            快照中只含有原来的逻辑卷中更改的数据或者自生成快照后的快照中更改的数据<br>            建立快照的卷的大小只需原始逻辑卷的15%~20%就够了，也可以使用lvextend放大快照</p>
<p>使用lvm快照：<br>    为现有逻辑卷创建快照<br>        lvcreate -n lv_snap_name -L size -p r lv_path<br>    挂载快照：<br>        mount -o ro lv_snap_path mountpoint<br>    恢复快照：<br>        先取消挂载<br>            umount lv_snap_mountpoint<br>            umount lv_mountpoint<br>        将快照合并到对应逻辑卷中<br>            lvconvert –merge lv_snap_path(执行此操作后快照会自动删除)<br>    手动删除快照<br>        取消快照挂载<br>            umount lv_snap_mountpoint<br>        删除快照<br>            lvremove lv_snap_path</p>
<p>warning: centos7创建快照后，挂载时需要加–nouuid选项，因为快照和源逻辑卷的uuid是同一个，而xfs文件系统默认不能同时挂载相同uuid的分区。</p>
<p>磁盘存储和文件系统：</p>
<p>磁盘分区：<br>    分区方式：<br>        MBR,GPT<br>    MBR分区方式要求分区不能超过两个G，硬盘也不能超过两个G，最多4个主分区，3个主分区和一个扩展分区，扩展分区内可以创建多个逻辑分区。<br>MBR分区结构：<br>    硬盘主引导记录MBR由4个部分组成<br>    主引导程序（偏移地址0000H–0088H），它负责从活动分区中装载，并运行系统引导程序<br>    出错信息数据区，偏移地址0089H–00E1H为出错信息，00E2H–01BDH全为0字节<br>    分区表（DPT,Disk Partation Table）含4个分区项，偏移地址01BEH–01FDH，每个分区表项长16个字节，共64个字节为分区项1、2、3、4。<br>    结束标志字，偏移地址01FE–01FF的连那个歌字节值为结束标志55AA<br>GPT分区结构：<br>    支持128个分区，使用64位，支持8Z（512Byte/block） 64Z(4096Byte/block)<br>    使用128位UUID表示磁盘和分区GPT分区表自动备份在头和尾两份，并有CRC校验位<br>    UEFI（统一扩展固件接口）硬件支持GPT，使操作系用启动</p>
<p>分区管理<br>    列出块设备：<br>        lsblk<br>    创建分区：<br>        fdisk DEVICE 创建MBR分区<br>        gdisk DEVICE 创建GPT分区<br>        parted 高级分区操作<br>    重新设置内存中的内核分区表版本<br>        partprobe（将硬盘分区工具同步到内核）<br>parted命令：<br>    parted命令的操作都是实时生效的，小心使用。<br>    用法：parted [选项]… [设备[命令[参数]…]…]<br>        parted /dev/sdb mklabel gpt|msdos<br>        parted /dev/sdb print<br>        parted /dev/sdb mkpart primary 1 200 (默认M)<br>        parted /dev/sdb rm 1<br>        parted -l 列出分区信息<br>分区工具fdisk和gdisk<br>    gdisk /dev/sdb 类fdisk的GPT分区工具<br>    fdisk -l [-u] [device…] 查看分区<br>    fdisk /dev/sdb 管理分区<br>    子命令<br>        p 分区列表<br>        t 更改分区类型<br>        n 创建新分区<br>        d 删除已经创建的分区<br>        v 校验分区<br>        u 转换单位<br>        w 保存并退出<br>        q 不保存退出<br>同步分区表<br>    查看内核是否已经识别新的分区<br>        cat /proc/partations<br>    centos6 通知内核重新读取硬盘分区表<br>        新增分区用<br>            partx -a /dev/DEVICE<br>            kpartx -a /dev/DEVICE -f:force<br>        删除分区用<br>            partx -d –nr M-N /dev/DEVICE<br>    centos5, 7 用partprobe<br>        partprobe [/dev/DEVICE]</p>
<p>文件系统：<br>    文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。<br>    操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统。<br>    从操作系统来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入文件进行保护和检索的系统。<br>    具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，安全控制，日志，压缩加密等<br>    查看系统支持的文件系统，<br>    /lib/modules/<code>uname -r</code>/kernel/fs </p>
<pre><code>创建文件系统：
    mkfs.FS_TYPE /dev/DEVICE -L &apos;LABEL&apos; (创建文件系统并设定卷标为LABEL)
    创建ext系列文件系统专用工具：
        mke2fs:
            -t {ext2|ext3|ext4} 指定文件系统类型
            -b {1024|2048|4096} 指定块大小
            -L &apos;LABEL&apos; 设置卷标
            -j 相当于-t 恶ext3
                mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3
            -i  num 为数据空间中没多少字节创建一个inode；不应该小于block大小
            -N num 指定分区中创建多少个inode
            -l 一个inode记录占用的磁盘空间大小，128--4096
            -m num 默认5%，为管理人员预留的空间占总空间的百分比
            -O FEATURE[,...] 启用指定特性
            -O ^FEATURE 关闭指定特性
文件系统标签：
    指向设备的另一种方法
    与设备无关
    blkid:块设备属性信息查看
    blkid [option] [DEVICE]
        -U UUID 根据指定的UUID来查找对应的设备
        -L LABEL 根据指定的LABEL来查找对应的设备
    e2label：管理ext系列文件系统的LABEL
        e2label DEVICE [LABEL]
    findfs:查找分区
        findfs [options] LABEL=&lt;label&gt;
        findfs [options] UUID=&lt;uuid&gt;
    turn2fs:重新设定ext系列文件系统可调整参数的值
        -l 查看指定文件系统的超级快信息；super block
        -L &apos;label&apos; 修改卷标
        -m num 修改预留给管理员的空间百分比
        -j 将ext2文件系统升级为ext3
        -O 文件系统属性启用或禁用，-O ^has_journal
        -o 调整文件系统的默认挂载选项 -o ^acl
        -U UUID 修改UUID号
    dump2fs:快分组管理，32768块
    -h：查看超级块信息，不显示分组信息
文件系统的检测和修复：
    常发生于司机或者非正常关机之后
    挂载为文件系统标记为&quot;no clean&quot;
    注意：
        一定不要在挂载状态下修复
    fsck:File System Check
        fsck.FS_TYPE
        fsck -t FS_TYPE
        -p 自动修复错误
        -r：交互式修复错误
        FS_TYPE：一定要与分区上已经存在文件类型相同
    e2fsck:ext系列文件系统专用的检测修复工具
        -y 自动回答yes
        -f 强制修复
挂载mount：
    挂载：将额外文件系统与跟文件系统某现存目录建立起关联联系，进而使得此目录作为其他文件访问该文件系统的入口的行为。
        挂载意味着使外来的文件系统看起来如同是主目录树的一部分
        访问前，介质必须被挂载
        摘除时，介质必须被卸载
        按照默认设置，非根用户只能挂载某些设备（光盘，DVD，软盘，USB等等）
        挂载点通常在/media或/mnt下
    卸载:解除此关联关系的过程
    把设备关联挂载点：mount Point
        mount
    卸载时：可使用设备，也可以使用挂载点
        umount 
    挂载点下原有文件在挂载完成后会被临时隐藏
    挂载点目录一般为空
    挂载方法：
        mount DEVICE MOUNT_POINT
    mount命令：
        通过查看/etc/fstab文件显示当前已经挂载的所有设备
        查看内核追踪到的已挂载的所有设备
            cat /proc/mounts 
    mount [-fnrsvw] [-t vfstype] [-o options] device dir
        device:指明要挂载的设备
            1、设备文件：例如/dev/sda1
            2、卷标：-L &apos;LABEL&apos;，例如：-L &apos;MYDATA&apos;
            3、UUID，-U &apos;UUID&apos;：例如：-U &apos;UUID&apos;
            4、伪文件系统名称：proc sysfs devtmpfs configfs
        dir：挂载点
            事先存在，建议使用空目录
            进程正在使用中的设备无法被卸载
        mount常用命令选项：
            -t vfstype：指定要挂载的设备上文件系统类型
            -r：readonly，只读挂载
            -w：read and write，读写挂载
            -n：不更新/etc/mtab，mount不可见
            -a：自动挂载所有支持自动挂载的设备（定义在了/etc/fstab文件中，且挂载选项中由auto功能）
            -L &apos;LABEL&apos;：以卷标指定挂载设备
            -U &apos;UUID&apos;：以UUID指定要挂载的设备
            -B，--bind：绑定目录到另一个目录上
            -o options：（挂载文件系统的选项），多个选项使用逗号分隔
                async 异步模式    sync 同步模式，内存更改时，同时写磁盘
                atime/noatime    包含目录和文件
                diratime/nodiratime    目录的访问时间戳
                auto/noauto    是否支持自动挂载，是否支持-a选项
                exec/noexec    是否支持在此文件系统上运行程序
                dev/nodev    是否支持在此文件系统上使用设备文件
                suid/nosuid    是否支持suid和sgid权限
                remount    重新挂在
                ro 只读 rw 读写
                user/nouser 是否允许普通用户挂载此设备，/etc/fstab使用
                acl    启用此文件系统上的acl功能
                loop    使用loop设备
            default：相当于rw suid dev exec auto nouser async
    卸载命令：
        查看挂载情况：
            findmnt MOUNT_POINT|device
        查看正在访问指定文件系统的进程：
            lsof MOUNT_POINT
            fuser -v MOUNT_POINT
        终止所有正在访问指定的文件系统的进程
            fuser -km MOUNT_POINT
        卸载： 
            umount DEVICE
            umount MOUNT_POINT
挂载点和/etc/fstab 
    配置文件系统体系
    被mount、fsck和其他程序使用
    系统重启时保留文件系统体系
    可以在设备栏使用文件系统卷标
    使用mount -a 命令挂载/etc/fstab中的所有文件系统
    /etc/fstab每行定义一个要挂载的文件系统：
        1、要挂载的设备或伪文件系统
            LABEL：LABEL=&quot;&quot;
            UUID：UUID=&quot;&quot;
            伪文件系统名称：proc sysfs
        2、挂载点
        3、文件系统类型：
            ext4,xfs,nfs,none
        4、挂载选项：
            defaults acl bind
        5、转储频率：
            0：不做备份
            1：每天转储
            2：每隔一天转储
        6、fsck检查的文件系统的顺序：允许的数字是0，1，2
            0：不自检
            1：首先自检；一般只有rootfs才用
            2：非rootfs使用
处理交换文件和分区：
    交换分区是系统RAM的补充
    基本设置包括：
        创建交换分区或者文件
        使用mkswap写入特殊签名
        在/etc/fstab文件中添加适当的条目
        使用swapon -a 激活交换空间
    挂载交换分区：
        启用：swapon
            swapon [OPTION]... [DEVICE]
                -a:激活所有的交换分区
                -p PRIORITY:指定优先级
                /etc/fstab:pri=value
        禁用：swapoff
            swapoff [OPTION]... [DEVICE]
    swap的优先级：
        可以指定swap分区0到32767的优先级，值越大优先级越高。
        如果用户没有指定，那么核心会自动给swap指定一个优先级，这个优先级从-1开始，每加入一个新的没有用户指定优先级的额swap，会给这个优先级减1.
        先添加的swap的缺省优先级比较高，除非用户自己指定一个优先级，而用户指定的优先级（是正数）永远高于核心缺省指定的优先级（是负数）
        性能优化：分布存放，高性能磁盘存放
使用光盘：
    在图形环境下自动挂载：
        /run/media/&lt;user&gt;/&lt;label&gt;
    否则就必须被手工挂载
        mount /dev/cdrom /mnt 
    eject命令卸载或弹出磁盘
    创建ISO文件：
        cp /dev/cdrom /root/centos7.iso 
        mkisofs -r -o /root/etc.iso /etc 
    刻录光盘：
        wodim -v -eject centos.iso 
挂载USB介质：
    查看USB介质
        lsusb
    被内核探测为SCSI设备：
        /dev/sdaX,/dev/sdbX,或类似的设备文件
    在图形环境中自动挂载
        图标在[计算机]窗口中创建
        挂载在/run/media/&lt;user&gt;/&lt;label&gt;
    手动挂载：
        mount /dev/sdb1 /mnt 
常见工具：
    df [OPTION]... [FILE]...    文件系统空间占用等信息的查看工具
        -H 以1000位单位
        -T 文件系统类型
        -h human-readable人类可读
        -i inode instead of blocks显示inode节点使用情况
        -P 以Posix兼容的格式输出
    du [OPTION]... DIR    查看某目录总体空间占用状态
        -h human-readable 人类可读
        -s summary --mex-depth 显示总空间占用情况
    dd命令：convert and copy a file 
        用法： 
            dd if=/PATH/FROM/SRC of=/PATH/TO/DEST bs=# count=#
                bs:bloack size,复制单元大小
                count:复制多少个bs
                of=file 写到所命名的文件而不是到标准输出
                if=file 从所命名的文件读取而不是从标准输入
                bs=size 指定块大小（既是ibs也是obs）
                ibs=size 一次读size个byte
                obs=size 一次写size个byte
                cbs=size 一次转化size个byte
                skip=blocks 从开头忽略blocks个ibs大小的块
                seek=blocks 从开头忽略blocks个obs大小的块
                count=n 只拷贝n个记录
                conv=conversion[,conversion...] 用指定的参数转换文件
                    转换参数：
                        ascii 转换 EBCDIC 为 ASCII
                        ebcdic 转换 ASCII 为 EBCDIC
                        lcase 把大写字符转换为小写字符
                        ucase 把小写字符转换为大写字符
                        nocreat 不创建输出文件
                        noerror 出错时不停止
                        notrunc 不截短输出文件
                        sync 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐
                        Fdatasync 写完成前，物理写入输出文件
            备份MBR：
                dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1
            破坏MBR中的bootloader
                dd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446
            备份磁盘：
                dd if=/dev/sdX of=/dev/sdy 将本地的/dev/sdX整盘备份到/dev/sdy
                dd if=/dev/sdx of=/path/to/image 将/dev/sdx全盘数据备份到指定路径的image文件
                dd if=/dev/sdx|gzip &gt; /path/to/image.gz 备份/dev/sdx全盘数据，并利用gzip压缩，保存到指定路径
            恢复： 
                dd if=/path/to/image of=/dev/sdx 将备份文件恢复到指定盘
                gzip -dc /path/to/image.gz | dd of=/dev/sdx 将压缩的备份文件恢复到指定盘
            拷贝内存资料到硬盘：
                dd if=/dev/mem of=/root/mem.bin bs=1024 将内存中数据拷贝到root目录下的mem.bin文件
            从光盘拷贝iso镜像
                dd if=/dev/cdrom of=/root/cd.iso
                拷贝光盘数据到root文件夹下，并保存为cd.iso文件
            销毁磁盘数据
                dd if=/dev/urandom of=/dev/sda1
                利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，
                /dev/sda1将无法挂载，创建和拷贝操作无法执行    
            得到最恰当的block size：
                dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000
                dd if=/dev/zero of=/root/1Gb.file bs=2048 count=500000
                dd if=/dev/zero of=/root/1Gb.file bs=4096 count=250000
                通过比较dd指令输出中命令的执行时间，即可确定系统最佳的block size大小
            测试硬盘写速度
                dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000
            测试硬盘读速度
                dd if=/root/1Gb.file bs=64k | dd of=/dev/null    
            修复硬盘
                dd if=/dev/sda of=/dev/sda
                当硬盘较长时间（比如1,2年）放置不使用后，磁盘上会产生消磁点。当磁头读
                到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一
                个扇区时，可能导致硬盘报废。上边的命令有可能使这些数据起死回生,且这个
                过程是安全高效的</code></pre>]]></content>
  </entry>
  <entry>
    <title>Sed入门</title>
    <url>/2016/08/21/sed/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;sed英文名为Stream Editor，行编辑器<br>&ensp;&ensp;&ensp;&ensp;sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有诸如“D”这样的特殊命令，那会在两个循环之间清空模式空间，但不会清空保留空间。这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。<br>&ensp;&ensp;&ensp;&ensp;功能：主要用来自动编辑一个或者多个文件，简化对文件的反复操作，编写转换程序等。  </p>
<h2 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h2><p>用法：<br>&ensp;&ensp;&ensp;&ensp;sed [option]… ‘script’ inputfile…<br>常用选项：<br>&ensp;&ensp;&ensp;&ensp;-n  不输出模式空间内容到屏幕，即不自动打印。<br>&ensp;&ensp;&ensp;&ensp;-e  多点编辑，即依次执行多个命令<br>&ensp;&ensp;&ensp;&ensp;-f /path/script_file    从指定文件中读取编辑脚本<br>&ensp;&ensp;&ensp;&ensp;-r  支持使用扩展的正则表达式<br>&ensp;&ensp;&ensp;&ensp;-<br>i.bak 备份文件后直接修改源文件<br>scropt：<br>&ensp;&ensp;&ensp;&ensp;‘地址命令’</p>
]]></content>
  </entry>
  <entry>
    <title>解决xshell连接Linux服务器慢的问题</title>
    <url>/2016/08/17/%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E9%99%86%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在日常使用xshell6连接centos时会发现链接速度很慢，有些时候就比较急人。这种情况主要是因为xshell在连接centos时使用了DNS解析，我们只需关掉DNS解析就可以了。</p>
<ul>
<li>打开ssh配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment">#vi /etc/ssh/sshd_config</span></span><br></pre></td></tr></table></figure></li>
<li>在文件内搜索UseDNS这一行，讲yes改为no。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">115 UseDNS no</span><br><span class="line">116 <span class="comment">#PidFile /var/run/sshd.pid</span></span><br><span class="line">/UseDNS</span><br><span class="line">```         </span><br><span class="line">* 重启sshd服务  </span><br><span class="line">```bash</span><br><span class="line">[root@centos7 ~]<span class="comment">#systemctl restart sshd.service</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>xhell连接</tag>
      </tags>
  </entry>
  <entry>
    <title>自动安装centos系统实现</title>
    <url>/2016/07/01/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E5%85%89%E7%9B%98%E5%92%8CU%E7%9B%98/</url>
    <content><![CDATA[<h3 id="制作kickstart文件"><a href="#制作kickstart文件" class="headerlink" title="制作kickstart文件"></a>制作kickstart文件</h3><p><strong>安装system-config-kivkstart包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install system-config-kickstart</span><br></pre></td></tr></table></figure>
<p>然后执行system-config-kickstart命令根据提示选择自己想要的设置即可制作kickstart文件。<br>注意：如果centos7系统制作-ks文件，需要将yum源的名字改为development，否则无法选择安装包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ head -1 /etc/yum.repos.d/base.repo </span><br><span class="line">[developmentment]</span><br></pre></td></tr></table></figure>

<p><strong>基于生成的kickstart文件安装系统</strong></p>
<p>指明kickstart文件位置: ks=</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DVD drive: ks&#x3D;cdrom:&#x2F;PATH&#x2F;TO&#x2F;KICKSTART_FILE</span><br><span class="line">Hard drive: ks&#x3D;hd:device:&#x2F;directory&#x2F;KICKSTART_FILE</span><br><span class="line">HTTP server: ks&#x3D;http:&#x2F;&#x2F;host:port&#x2F;path&#x2F;to&#x2F;KICKSTART_FILE</span><br><span class="line">FTP server: ks&#x3D;ftp:&#x2F;&#x2F;host:port&#x2F;path&#x2F;to&#x2F;KICKSTART_FILE</span><br><span class="line">HTTPS server: ks&#x3D;https:&#x2F;&#x2F;host:port&#x2F;path&#x2F;to&#x2F;KICKSTART_FILE</span><br><span class="line">NFS server:ks&#x3D;nfs:host:&#x2F;path&#x2F;to&#x2F;KICKSTART_FILE</span><br></pre></td></tr></table></figure>
<p>生成的应答文件，可以放到web共享目录，实现网络远程安装</p>
<h3 id="制作光盘启动盘"><a href="#制作光盘启动盘" class="headerlink" title="制作光盘启动盘"></a>制作光盘启动盘</h3><p><strong>在磁盘创建一个分区，并将光盘中的isolinux目录拷贝到此目录，然后将此前生成的ks文件也复制过来</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir /data/iso</span><br><span class="line">$ cp -r /misc/<span class="built_in">cd</span>/isolinux/ /data/iso </span><br><span class="line">$ mkdir /data/iso/ksdir</span><br><span class="line">$ cp /root/ks.cfg /data/iso/ksdir</span><br></pre></td></tr></table></figure>
<p>此时目录结构是这样的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree /data/iso/</span><br><span class="line">/data/iso/</span><br><span class="line">├── isolinux</span><br><span class="line">│   ├── boot.cat</span><br><span class="line">│   ├── boot.msg</span><br><span class="line">│   ├── grub.conf</span><br><span class="line">│   ├── initrd.img</span><br><span class="line">│   ├── isolinux.bin</span><br><span class="line">│   ├── isolinux.cfg</span><br><span class="line">│   ├── memtest</span><br><span class="line">│   ├── splash.png</span><br><span class="line">│   ├── TRANS.TBL</span><br><span class="line">│   ├── vesamenu.c32</span><br><span class="line">│   └── vmlinuz</span><br><span class="line">└── ksdir</span><br><span class="line">    └── ks.cfg</span><br></pre></td></tr></table></figure>

<p><strong>修改其中的isolinux.cfg文件，指定ks文件位置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat isolinux/isolinux.cfg</span><br><span class="line">label linux</span><br><span class="line">   menu label ^Auto install an system</span><br><span class="line">   menu default</span><br><span class="line">   kernel vmlinuz</span><br><span class="line">   append initrd=initrd.img ks=cdrom:/ksdir/ks.cfg</span><br></pre></td></tr></table></figure>

<p><strong>将/data/iso目录制作成ISO文件,烧录到光盘中，即可使用此光盘引导安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V <span class="string">"CentOS 7.5 x86_64 boot"</span> -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso /data/iso</span><br></pre></td></tr></table></figure>
<p>注意：由此制做的光盘只能作为启动盘引导，其指定的系统镜像为网络镜像。</p>
<h3 id="制作U盘启动"><a href="#制作U盘启动" class="headerlink" title="制作U盘启动"></a>制作U盘启动</h3><p><strong>将上述生成的boot.iso文件转换成硬盘格式的文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ isohybrid boot.iso</span><br></pre></td></tr></table></figure>

<p><strong>将上述生成的/root/boot.iso文件烧到U盘中</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/root/boot.iso of=/dev/sdc</span><br></pre></td></tr></table></figure>

<h3 id="使用U盘制作完整的启动盘"><a href="#使用U盘制作完整的启动盘" class="headerlink" title="使用U盘制作完整的启动盘"></a>使用U盘制作完整的启动盘</h3><p><strong>创建目录将光盘整个拷贝到此目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp -r /misc/<span class="built_in">cd</span>/. /data/fulliso</span><br></pre></td></tr></table></figure>
<p><strong>删除其中的TRANS.TBL文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /data/fulliso/ -name TRANS.TBL -<span class="built_in">exec</span> rn &#123;&#125;\;</span><br></pre></td></tr></table></figure>

<p><strong>修改仓库信息</strong><br>将repodata目录县的文件清空</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm -rf /data/fulliso/repodata/*</span><br></pre></td></tr></table></figure>
<p>重新生成元数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ createrepo -g /misc/<span class="built_in">cd</span>/repodata/5a045ecddfcca9dcbf1c28b6543e740de844ff4ef221e70308e7ad6decaea417-c6-x86_64-comps.xml /data/fulliso/</span><br></pre></td></tr></table></figure>

<p><strong>将ks文件放入/data/fulliso文件夹下</strong></p>
<p><strong>将/data/fulliso目录制作成ISO文件,烧录到光盘中，即可使用此光盘引导安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V <span class="string">"CentOS 7.5 x86_64 boot"</span> -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/centos6.iso /data/fulliso</span><br></pre></td></tr></table></figure>

<p>也可以将生成的文件装换成U盘格式。</p>
]]></content>
      <tags>
        <tag>自动安装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>编译安装git</title>
    <url>/2016/06/16/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85git/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;此文介绍在centos7上采用源码方式编译安装 <strong><em>git 2.9.5</em></strong>  </p>
<ol>
<li>安装git依赖的库 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 /service/application]<span class="comment">#yum -y install gcc gcc-c++ perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span></span><br></pre></td></tr></table></figure></li>
<li>从官网下载git源码包  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~/tools]<span class="comment"># wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.xz</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>解压源码包：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~/tools]<span class="comment">#tar -xvf git-2.9.5.tar.xz</span></span><br></pre></td></tr></table></figure></li>
<li>进入解压后的目录执行编译配置，编译，编译安装。此处选择的是安装在/service/application目录下。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~/tools]<span class="comment">#cd git-2.9.5/</span></span><br><span class="line">[root@centos7 ~/tools]<span class="comment">#./config --prefix=/service/application</span></span><br><span class="line">[root@centos7 ~/tools]<span class="comment">#make</span></span><br><span class="line">[root@centos7 ~/tools]<span class="comment">#make install</span></span><br></pre></td></tr></table></figure></li>
<li>加入环境变量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># echo "export PATH=/service/application/bin" &gt;&gt; /etc/profile</span></span><br><span class="line">[root@centos7 ~]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="相关错误总结："><a href="#相关错误总结：" class="headerlink" title="相关错误总结："></a>相关错误总结：</h2><ol>
<li>如果在make过程中报如下错误：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   Can<span class="string">'t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: inc /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at inc/Module/Install/Makefile.pm line 4.</span></span><br><span class="line"><span class="string">BEGIN failed--compilation aborted at inc/Module/Install/Makefile.pm line 4.</span></span><br><span class="line"><span class="string">Compilation failed in require at inc/Module/Install.pm line 307.</span></span><br></pre></td></tr></table></figure>
说明没有安装 <strong><em>perl-ExtUtils-CBuilder</em></strong> &ensp;&ensp;<strong><em>perl-ExtUtils-MakeMaker</em></strong> 这两个组件，采取yum安装一下即可。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL备份还原和主从复制</title>
    <url>/0208/08/06/MySQL%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E5%92%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h2><p>为什么要备份？<br><strong>实现容灾恢复</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">硬件故障</span><br><span class="line">软件故障</span><br><span class="line">自然灾害</span><br><span class="line">黑客攻击</span><br><span class="line">误操作删除等数据丢失场景</span><br></pre></td></tr></table></figure>

<p><strong>备份注意要点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">能容忍最多丢失多少数据</span><br><span class="line">恢复数据需要在多长时间内完成</span><br><span class="line">需要恢复哪些数据</span><br></pre></td></tr></table></figure>

<p><strong>还原要点</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">做还原测试，用于测试备份的可用性</span><br><span class="line">还原演练</span><br></pre></td></tr></table></figure>

<h4 id="备份类型"><a href="#备份类型" class="headerlink" title="备份类型"></a>备份类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完全备份：整个数据集</span><br><span class="line">部分备份：只备份数据子集，如部分库或表</span><br><span class="line">增量备份：仅备份最近一次完全备份或增量备份（如果存在增量）以来变化的数据，备份较快，还原复杂</span><br><span class="line">差异备份：仅备份最近一次完全备份以来变化的数据，备份较慢，还原简单</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：二进制文件不应该与数据文件放在同一磁盘</p>
<p><strong>冷、温、热备份</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">冷备：读写操作均不可进行</span><br><span class="line">温备：读操作可执行，但写操作不可执行</span><br><span class="line">热备：读写操作均可执行</span><br><span class="line">	MyISAM：温备，不支持热备</span><br><span class="line">	InnoDB：都支持，建议使用热备</span><br></pre></td></tr></table></figure>

<p><strong>物理和逻辑备份</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理备份：直接复制数据文件进行备份，与存储引擎有关，占用较多的空间，速度快。</span><br><span class="line">逻辑备份：从数据库中“导出”数据另存而进行的备份，与存储引擎无关，占用空间少，速度慢，可能丢失精度</span><br></pre></td></tr></table></figure>

<h4 id="备份时需要考虑的因素"><a href="#备份时需要考虑的因素" class="headerlink" title="备份时需要考虑的因素"></a>备份时需要考虑的因素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">温备的持锁多久</span><br><span class="line">备份产生的负载</span><br><span class="line">备份过程的时长</span><br><span class="line">恢复过程的时长</span><br></pre></td></tr></table></figure>

<h4 id="备份什么"><a href="#备份什么" class="headerlink" title="备份什么"></a>备份什么</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据</span><br><span class="line">二进制日志、InnoDB的事务日志</span><br><span class="line">程序代码（存储过程、函数、触发器、时间调度器）</span><br><span class="line">服务器的配置文件</span><br></pre></td></tr></table></figure>

<h3 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp,tar等复制归档工具：物理备份工具，适用所有存储引擎；只支持冷备；完全和部分备份</span><br><span class="line">LVM的快照：先加锁，做快照后解锁，几乎热备；借助文件系统工具进行备份</span><br><span class="line">mysqldump：逻辑备份工具，适用所有存储引擎，温备；支持完全或部分备份；对InnoDB存储引擎支持热备，结合binlog的增量备份</span><br><span class="line">xtrabackup：由Percona提供支持对InnoDB做热备(物理备份)的工具，支持完全备份、增量备份</span><br><span class="line">MariaDB Backup： 从MariaDB 10.1.26开始集成，基于Percona XtraBackup 2.3.8实现</span><br><span class="line">mysqlbackup：热备份， MySQL Enterprise Edition组件</span><br><span class="line">mysqlhotcopy：PERL 语言实现，几乎冷备，仅适用于MyISAM存储引擎，</span><br><span class="line">使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库</span><br></pre></td></tr></table></figure>

<h4 id="mysqldump工具介绍"><a href="#mysqldump工具介绍" class="headerlink" title="mysqldump工具介绍"></a>mysqldump工具介绍</h4><p>mysqldump：客户端命令，通过mysql协议连接至mysql服务器进行备份<br>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump [OPTIONS] database [tables]  (不推荐使用)</span><br><span class="line">mysqldump [OPTIONS] –B DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [OPTIONS] –A [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>mysqldump常见选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A， --all-databases 备份所有数据库，含create database</span><br><span class="line">-B , --databases db_name… 指定备份的数据库，包括create database语句</span><br><span class="line">-E, --events：备份相关的所有event scheduler,即备份计划任务</span><br><span class="line">-R, --routines：备份所有存储过程和自定义函数</span><br><span class="line">--triggers：备份表相关触发器，默认启用,用--skip-triggers，不备份触发器</span><br><span class="line">--default-character-set&#x3D;utf8 指定字符集</span><br><span class="line">--master-data[&#x3D;#]： 此选项须启用二进制日志</span><br><span class="line">	1：所备份的数据之前加一条记录为CHANGE MASTER TO语句，非注释，不指定#，默认为1</span><br><span class="line">	2：记录为注释的CHANGE MASTER TO语句此选项会自动关闭--lock-tables功能，自动打开-x | --lock-all-tables功能（除非开启--single-transaction）</span><br><span class="line">-F, --flush-logs ：备份前滚动日志，锁定表完成后，执行flush logs命令,生成新的二进制日志文件，配合-A 或 -B 选项时，会导致刷新多次数据库。建议在同一时刻执行转储和日志刷新，可通过和--single-transaction或-x，--master-data 一起使用实现，此时只刷新一次日志</span><br><span class="line">--compact 去掉注释，适合调试，生产不使用</span><br><span class="line">-d, --no-data 只备份表结构</span><br><span class="line">-t, --no-create-info 只备份数据,不备份create table</span><br><span class="line">-n,--no-create-db 不备份create database，可被-A或-B覆盖</span><br><span class="line">--flush-privileges 备份mysql或相关库时需要使用</span><br><span class="line">-f, --force 忽略SQL错误，继续执行</span><br><span class="line">--hex-blob 使用十六进制符号转储二进制列，当有包括BINARY，VARBINARY，BLOB，BIT的数据类型的列时使用，避免乱码</span><br><span class="line">-q, --quick 不缓存查询，直接输出，加快备份速度</span><br></pre></td></tr></table></figure>

<h4 id="实现数据库分库备份"><a href="#实现数据库分库备份" class="headerlink" title="实现数据库分库备份"></a>实现数据库分库备份</h4><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#mysql -e 'show databases'|grep -Eiv 'database|information_schema|performance_schema'|sed -r 's#.*#mysqldump -B -F --master-data=2 &amp; |gzip &gt; &amp;_`data +%F`.sql.gzip#'|bash</span></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#for i in `mysql -e 'show databases'|grep -Eiv "database|information_schema|performance_schema"`;do mysqldump -B $i -F --master-data=2 |gzip &gt; $&#123;i&#125;_`date +%F`.sql.gzip;done</span></span><br></pre></td></tr></table></figure>

<p><strong>MyISAM备份选项</strong>：<br> 支持温备；不支持热备，所以必须先锁定要备份的库，而后启动备份操作锁定方法如下：<br>    -x,–lock-all-tables：加全局读锁，锁定所有库的所有表，同时加–singletransaction或–lock-tables选项会关闭此选项功能<br> 注意：数据量大时，可能会导致长时间无法并发访问数据库<br>     -l,–lock-tables：对于需要备份的每个数据库，在启动备份之前分别锁定其所有表，默认为on,–skip-lock-tables选项可禁用,对备份MyISAM的多个库,可能会造成数据不一致<br> 注：以上选项对InnoDB表一样生效，实现温备，但不推荐使用</p>
<p> <strong>InnoDB备份选项</strong>： 支持热备，可用温备但不建议用<br> –single-transaction：此选项Innodb中推荐使用，不适用MyISAM，此选项会开始备份前，先执行START TRANSACTION指令开启事务，即以事务的方式开启备份<br>此选项通过在单个事务中转储所有表来创建一致的快照。 仅适用于存储在支持多版本控制的存储引擎中的表（目前只有InnoDB可以）; 转储不保证与其他存储引擎保持一致。 在进行单事务转储时，要确保有效的转储文件（正确的表内容和二进制日志位置），没有其他连接应该使用以下语句：ALTER TABLE，DROP TABLE，RENAME TABLE，TRUNCATE TABLE<br>此选项和–lock-tables（此选项隐含提交挂起的事务）选项是相互排斥<br>备份大型表时，建议将–single-transaction选项和–quick结合一起使用</p>
<h3 id="生产环境备份策略"><a href="#生产环境备份策略" class="headerlink" title="生产环境备份策略"></a>生产环境备份策略</h3><p><strong>InnoDB建议备份策略</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#mysqldump –uroot –A –F –E –R --single-transaction --master-data=1 --flush-privileges --triggers --default-character-set=utf8 --hex-blob &gt; $BACKUP/fullbak_$BACKUP_TIME.sql</span></span><br></pre></td></tr></table></figure>

<p><strong>MyISAM建议备份策略</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#mysqldump –uroot –A –F –E –R –x --master-data=1 --flush-privileges --triggers --default-character-set=utf8 --hex-blob &gt; $BACKUP/fullbak_$BACKUP_TIME.sql</span></span><br></pre></td></tr></table></figure>

<h3 id="场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库被误删除，设法将数据库恢复到十点的状态"><a href="#场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库被误删除，设法将数据库恢复到十点的状态" class="headerlink" title="场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库被误删除，设法将数据库恢复到十点的状态"></a>场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库被误删除，设法将数据库恢复到十点的状态</h3><ol>
<li><p>如果是yum安装的数据库，直接启动数据库；如果是多实例，初始化数据库后，然后启动数据库。（本实验以多实例安装为例），前提条件为二进制日志和数据库必须分离存放，即二进制日志必须保存完整，此外还要确认字符集和存储引擎。备份策略为innodb建议的备份策略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible <span class="built_in">test</span>]<span class="comment">#sed -n '/^[^#]/p' /mysql/3306/etc/my.cnf </span></span><br><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">datadir=/mysql/3306/data/</span><br><span class="line"><span class="built_in">log</span>-bin=/mysql/3306/logbin/mysql-bin</span><br><span class="line">socket=/mysql/3306/socket/mysql.sock</span><br><span class="line">innodb_file_per_table</span><br><span class="line">symbolic-links=0</span><br><span class="line">[mysqld_safe]</span><br><span class="line"><span class="built_in">log</span>-error=/mysql/3306/<span class="built_in">log</span>/mariadb.log</span><br><span class="line">pid-file=/mysql/3306/pid/mariadb.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入备份。<br>首先关闭二进制日志：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; set sql_log_bin=0;</span><br><span class="line">MariaDB [(none)]&gt;source test/all_bak.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>将二进制日志导入数据库。<br>新开终端查看当前被分的二进制节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#sed -n '/^-- CHANGE MASTER TO/p' test/all_bak.sql </span></span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">'mysql-bin.000003'</span>, MASTER_LOG_POS=385;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>将此节点之后的二进制日志导出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#ls /mysql/3306/logbin/</span></span><br><span class="line">mysql-bin.000001  mysql-bin.000003  mysql-bin.000005  mysql-bin.000007  mysql-bin.000009  mysql-bin.state</span><br><span class="line">mysql-bin.000002  mysql-bin.000004  mysql-bin.000006  mysql-bin.000008  mysql-bin.index</span><br><span class="line">[root@ansible ~]<span class="comment">#mysqlbinlog /mysql/3306/logbin/mysql-bin.00000&#123;3,4,5,6,7,8,9&#125; &gt; /root/test/binlog_bak.sql</span></span><br></pre></td></tr></table></figure>

<p>导入（在旧终端）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt;<span class="built_in">source</span> /root/<span class="built_in">test</span>/binlog_bak.sql</span><br></pre></td></tr></table></figure>

<p>开启二进制日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; <span class="built_in">set</span> sql_log_bin=1;</span><br></pre></td></tr></table></figure>

<p>此时，已经将数据库恢复到十点的状态，恢复期间，应通过设置防火墙策略等手段禁止用户访问该实例，数据库恢复完成后，恢复用户的访问。</p>
<h3 id="场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库中的某个表被误删除，之后对数据库的其他表做了一些写操作，直到十点十分发现问题，设法将数据库恢复到十点十分的状态，即恢复被删除的表，并将其余操作一并恢复。"><a href="#场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库中的某个表被误删除，之后对数据库的其他表做了一些写操作，直到十点十分发现问题，设法将数据库恢复到十点十分的状态，即恢复被删除的表，并将其余操作一并恢复。" class="headerlink" title="场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库中的某个表被误删除，之后对数据库的其他表做了一些写操作，直到十点十分发现问题，设法将数据库恢复到十点十分的状态，即恢复被删除的表，并将其余操作一并恢复。"></a>场景：每天凌晨两点计划任务自动备份数据库，第二天早上十点数据库中的某个表被误删除，之后对数据库的其他表做了一些写操作，直到十点十分发现问题，设法将数据库恢复到十点十分的状态，即恢复被删除的表，并将其余操作一并恢复。</h3><ol>
<li>准备工作：依然是用hellodb数据库做演示，删除teachers表，并在students表中插入记录，而后恢复。<br>hellodb库的表结构如下：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; show tables;</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| Tables_in_hellodb |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| classes           |</span><br><span class="line">| coc               |</span><br><span class="line">| courses           |</span><br><span class="line">| scores            |</span><br><span class="line">| students          |</span><br><span class="line">| teachers          |</span><br><span class="line">| toc               |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>备份数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#mysqldump -A -F --single-transaction --master-data=2 &gt; all_bak.sql</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>禁止用户访问此数据库实例。（利用防火墙策略等手段）</p>
</li>
<li><p>关闭二进制日志</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; set sql_log_bin=0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入备份的数据库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; source /root/all_bak.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>将备份节点之后的二进制日志导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#mysqlbinlog /var/lib/mysql/mariadb-bin.000002 &gt; binlog.sql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将导出的二进制日志中的删除teachers表的语句删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ~]<span class="comment">#sed -i '/^DROP/s/.*/#&amp;/' binlog.sql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将二进制日志导入数据库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; source /root/binlog.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开二进制日志</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [hellodb]&gt; set sql_log_bin=1;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，误删除的表已经恢复，注意：所有的导入过程必须关闭二进制日志，直到恢复完成后再打开。</p>
<h2 id="percona-xtrabackup实战入门"><a href="#percona-xtrabackup实战入门" class="headerlink" title="percona-xtrabackup实战入门"></a>percona-xtrabackup实战入门</h2><p>Percona</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网：www.percona.com</span><br><span class="line">percona-server</span><br><span class="line">InnoDB --&gt; XtraDB</span><br></pre></td></tr></table></figure>

<p><strong>Xtrabackup</strong><br>percona提供的mysql数据库备份工具，惟一开源的能够对innodb和xtradb数据库进行热备的工具<br>手册：<a href="https://www.percona.com/doc/percona-xtrabackup/LATEST/index.html" target="_blank" rel="noopener">https://www.percona.com/doc/percona-xtrabackup/LATEST/index.html</a><br>特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">备份还原过程快速、可靠</span><br><span class="line">备份过程不会打断正在执行的事务</span><br><span class="line">能够基于压缩等功能节约磁盘空间和流量</span><br><span class="line">自动实现备份检验</span><br><span class="line">开源，免费</span><br></pre></td></tr></table></figure>

<p><strong>xtrabaclip工作原理</strong>：<br><a href="https://www.percona.com/doc/percona-xtrabackup/LATEST/how_xtrabackup_works.html" target="_blank" rel="noopener">https://www.percona.com/doc/percona-xtrabackup/LATEST/how_xtrabackup_works.html</a></p>
<p>下载xtrabackup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb tools]<span class="comment">#wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span></span><br></pre></td></tr></table></figure>

<p>安装xtrabackup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb tools]<span class="comment">#yum install percona*.rpm</span></span><br></pre></td></tr></table></figure>

<h4 id="xtrabackup用法简介"><a href="#xtrabackup用法简介" class="headerlink" title="xtrabackup用法简介"></a>xtrabackup用法简介</h4><p><strong>备份</strong>：innobackupex [option] BACKUP-ROOT-DIR<br>选项说明：<a href="https://www.percona.com/doc/percona-xtrabackup/LATEST/genindex.html" target="_blank" rel="noopener">https://www.percona.com/doc/percona-xtrabackup/LATEST/genindex.html</a><br>选项说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--user：该选项表示备份账号</span><br><span class="line">--password：该选项表示备份的密码</span><br><span class="line">--host：该选项表示备份数据库的地址</span><br><span class="line">--databases：该选项接受的参数为数据库名，如果要指定多个数据库，彼此间需要以空格隔开；如：&quot;xtra_test dba_test&quot;，同时，在指定某数据库时，也可以只指定其中的某张表。如：&quot;mydatabase.mytable&quot;。该选项对innodb引擎表无效，还是会备份所有innodb表</span><br><span class="line">--defaults-file：该选项指定从哪个文件读取MySQL配置，必须放在命令行第一个选项位置</span><br><span class="line">--incremental：该选项表示创建一个增量备份，需要指定--incremental-basedir</span><br><span class="line">--incremental-basedir：该选项指定为前一次全备份或增量备份的目录，与--incremental同时使用</span><br><span class="line">--incremental-dir：该选项表示还原时增量备份的目录</span><br><span class="line">--include&#x3D;name：指定表名，格式：databasename.tablename</span><br></pre></td></tr></table></figure>

<p><strong>prepare</strong>：innobackupex –apply-log [option] BACKUP-DIR<br>选项说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--apply-log：最后一次恢复时使用该选项，一般情况下,在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但</span><br><span class="line">	尚未同步至数据文件中的事务。因此，此时数据文件仍处于不一致状态。此选项作用是通过回滚未提交的事务及同步已经提交的事</span><br><span class="line">	务至数据文件使数据文件处于一致性状态</span><br><span class="line">--use-memory：和--apply-log选项一起使用，当prepare 备份时，做crashrecovery分配的内存大小，单位字节，也可1MB,1M,1G,1GB等，推荐1G</span><br><span class="line">--export：表示开启可导出单独的表之后再导入其他Mysql中</span><br><span class="line">--redo-only：不是最后一次恢复时使用，此选项在prepare base full backup，往其中合并增量备份时候使用，但不包括对最后一个增量备份的合并</span><br></pre></td></tr></table></figure>

<p><strong>还原</strong>：innobackupex –copy-back [选项] BACKUP-DIR<br>          innobackupex –move-back [选项] [–defaults-group=GROUP-NAME] BACKUP-DIR<br>选项说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--defaults-file&#x3D;[MY.CNF]:此选项接受一个字符串参数，该参数指定要从中读取默</span><br><span class="line">	认MySQL选项的文件。必须作为命令行中的第一个选项。</span><br><span class="line">--copy-back：做数据恢复时将备份数据文件拷贝到MySQL服务器的datadir</span><br><span class="line">--move-back：这个选项与--copy-back相似，唯一的区别是它不拷贝文件，</span><br><span class="line">	而是移动文件到目的地。这个选项移除backup文件，用时候必须小心。使用场</span><br><span class="line">	景：没有足够的磁盘空间同事保留数据文件和Backup副本</span><br></pre></td></tr></table></figure>

<p>还原注意事项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.datadir 目录必须为空。除非指定innobackupex --force-non-emptydirectorires选项指定，否则--copy-backup选项不会复制目标目录已经存在的文件。</span><br><span class="line">2.在restore之前,必须shutdown MySQL实例，不能将一个运行中的实例restore到datadir目录中</span><br><span class="line">3.由于文件属性会被保留，大部分情况下需要在启动实例之前将文件的属主改为mysql，这些文件将属于创建备份的用户</span><br><span class="line">chown -R mysql:mysql &#x2F;data&#x2F;mysql</span><br></pre></td></tr></table></figure>
<p>以上需要在用户调用innobackupex之前完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--force-non-empty-directories：指定该参数时候，使得innobackupex --</span><br><span class="line">copy-back或--move-back选项转移文件到非空目录，已存在的文件不会被覆</span><br><span class="line">盖。如果--copy-back和--move-back文件需要从备份目录拷贝一个在</span><br><span class="line">datadir已经存在的文件，会报错失败</span><br></pre></td></tr></table></figure>

<p><strong>使用xtrabackup备份生成的相关文件</strong><br>使用innobakupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义的相关文件(.frm)、以及MyISAM、MERGE、CSV和ARCHIVE表的相关文件，同时还会备份触发器和数据库配置信息相关的文件。这些文件会被保存至一个以时间命名的目录中,在备份时，innobackupex还会在备份目录中创建如下文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xtrabackup_info：innobackupex工具执行时的相关信息，包括版本，备份选项，备</span><br><span class="line">	份时长，备份LSN(log sequence number日志序列号)，BINLOG的位置</span><br><span class="line">xtrabackup_checkpoints：备份类型（如完全或增量）、备份状态（如是否已经为</span><br><span class="line">	prepared状态）和LSN范围信息,每个InnoDB页(通常为16k大小)都会包含一个日</span><br><span class="line">	志序列号LSN。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明</span><br><span class="line">	此页面最近是如何发生改变的</span><br><span class="line">xtrabackup_binlog_info：MySQL服务器当前正在使用的二进制日志文件及至备份</span><br><span class="line">	这一刻为止二进制日志事件的位置，可利用实现基于binlog的恢复</span><br><span class="line">backup-my.cnf：备份命令用到的配置选项信息</span><br><span class="line">xtrabackup_logfile：备份生成的日志文件</span><br></pre></td></tr></table></figure>

<h3 id="实验：xtrabackup完全备份及还原"><a href="#实验：xtrabackup完全备份及还原" class="headerlink" title="实验：xtrabackup完全备份及还原"></a><strong>实验：xtrabackup完全备份及还原</strong></h3><ol>
<li><p>在原主机做完全备份到/data/backup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb tools]<span class="comment">#xtrabackup --backup --target-dir=/data/backup</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将备份后生成的目录拷贝到远程主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb tools]<span class="comment">#scp -r /data/backup/ 192.168.34.108:/data/backup/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在远程主机做预准备工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#xtrabackup --prepare --target-dir=/data/backup</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行还原操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#xtrabackup --copy-back --target-dir=/data/backup --datadir=/var/lib/mysql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更改还原的数据库的属主和属组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node01 ~]<span class="comment">#chown -R mysql.mysql /var/lib/mysql/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，实验结束。</p>
<h3 id="实验：xtrabackup完全、增量备份及还原"><a href="#实验：xtrabackup完全、增量备份及还原" class="headerlink" title="实验：xtrabackup完全、增量备份及还原"></a><strong>实验：xtrabackup完全、增量备份及还原</strong></h3><p>创建文件夹用于实验</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#mkdir /data/test/&#123;base,inc1,inc2&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行完全备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --backup --target-dir=/data/test/base</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>往数据库中插入数据后执行第一次增量备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --backup --target-dir=/data/test/inc1 --incremental-basedir=/data/test/base</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次往数据库插入数据后执行第二次增量备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --backup --target-dir=/data/test/inc2 --incremental-basedir=/data/test/inc1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库，准备还原</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#rm -rf /var/lib/mysql/*</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">5. 预准备完成备份，此选项--apply-log-only 阻止回滚未完成的事务</span><br><span class="line">```bash</span><br><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --prepare --target-dir=/data/test/base --apply-log-only</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并第1次增量备份到完全备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --prepare --apply-log-only --target-dir=/data/test/base --incremental-dir=/data/test/inc1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并第2次增量备份到完全备份：最后一次还原不需要加选项–apply-log-only</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --prepare  --target-dir=/data/test/base --incremental-dir=/data/test/inc2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制到数据库目录，注意数据库目录必须为空，MySQL服务不能启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#xtrabackup --copy-back --target-dir=/data/test/base --datadir=/var/lib/mysql/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还原属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#chown -R mysql:mysql /var/lib/mysql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb backup]<span class="comment">#systemctl start mariadb</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>xtrabackup单表导出和导入</p>
<ol>
<li>单表备份<br>innobackupex –include=’hellodb.students’ /backups</li>
<li>备份表结构<br>mysql -e ‘show create table hellodb.students’ &gt; student.sql</li>
<li>删除表<br>mysql -e ‘drop table hellodb.students‘<br>4 innobackupex –apply-log –export /backups/2018-02-23_15-03-23/</li>
<li>创建表<br>mysql&gt;CREATE TABLE <code>students</code> (<br><code>StuID</code> int(10) unsigned NOT NULL AUTO_INCREMENT,<br><code>Name</code> varchar(50) NOT NULL,<br><code>Age</code> tinyint(3) unsigned NOT NULL,<br><code>Gender</code> enum(‘F’,’M’) NOT NULL,<br><code>ClassID</code> tinyint(3) unsigned DEFAULT NULL,<br><code>TeacherID</code> int(10) unsigned DEFAULT NULL,<br>PRIMARY KEY (<code>StuID</code>)<br>) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8</li>
<li>删除表空间<br>alter table students discard tablespace;</li>
<li>cp /backups/2018-02-23_15-03-23/hellodb/students.{cfg,exp,ibd}<br>/var/lib/mysql/hellodb/</li>
<li>chown -R mysql.mysql /var/lib/mysql/hellodb/</li>
<li>mysql&gt;alter table students import tablespace;</li>
</ol>
<h2 id="mysql主从复制"><a href="#mysql主从复制" class="headerlink" title="mysql主从复制"></a>mysql主从复制</h2><p>mysql的扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读写分离</span><br><span class="line">复制：每个节点都有相同的数据集</span><br><span class="line">		向外扩展</span><br><span class="line">		二进制日志</span><br><span class="line">		单向</span><br></pre></td></tr></table></figure>

<p>主从复制的功用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据分布</span><br><span class="line">负载均衡读</span><br><span class="line">备份</span><br><span class="line">高可用和故障切换</span><br><span class="line">mysql升级测试</span><br></pre></td></tr></table></figure>

<p><strong>主从复制原理</strong></p>
<ol>
<li>master收到用户的写操作，更新数据，同时写入二进制日志。</li>
<li>master上的dump thread向slave上的I/O thread发送binary log events</li>
<li>slave thread将从master接收的binary log events保存在rely log中</li>
<li>slave上的SQL thread从rely log读取日志事件，并写入本地数据库中。至此，完成主从复制</li>
</ol>
<p><strong>复制类型</strong><br><strong>异步复制</strong>：master写入完成后立即反馈结果给用户，有数据丢失风险，例如master在向slave同步之前突然宕机，然而用户以为已经正确完成写入操作。<br><strong>同步复制</strong>：master写入完成后先将二进制日志同步到所有的slave，之后在反馈结果给用户，缺点是用户体验差，可能造成长时间等待。<br><strong>半同步复制</strong>：master写入完成后先将二进制日志同步到slave，但是只要有一个slave同步完成，即反馈结果给用户，比较合理。</p>
<p>主从配置过程：参看官网<br><a href="https://mariadb.com/kb/en/library/setting-up-replication/" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/setting-up-replication/</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/replication-configuration.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/replication-configuration.html</a></p>
<p><strong>主节点配置</strong></p>
<ol>
<li>启用二进制日志<br>[mysqld]<br>log_bin</li>
<li>为当前节点设置一个全局唯一的ID号<br>[mysqld]<br>server_id=#<br>log-basename=master 可选项，设置datadir中日志名称，确保不依赖主机名</li>
<li>创建有复制权限的账号<br>GRANT REPLICATION SLAVE ON <em>.</em> TO ‘repluser’@’HOST’ IDENTIFIED BY<br>‘replpass’;</li>
</ol>
<p><strong>从节点配置</strong></p>
<ol>
<li>启动中继日志<br>[mysqld]<br>server_id=# 为当前节点设置一个全局惟的ID号<br>read-only<br>relay_log=relay-log relay log的文件路径，默认值hostname-relay-bin<br>relay_log_index=relay-log.index 默认值hostname-relay-bin.index</li>
<li>使用有复制权限的用户账号连接至主服务器，并启动复制线程<br>mysql&gt; CHANGE MASTER TO MASTER_HOST=’host’,<br>MASTER_USER=’repluser’, MASTER_PASSWORD=’replpass’,<br>MASTER_LOG_FILE=’mysql-bin.xxxxx’, MASTER_LOG_POS=#;<br>mysql&gt; START SLAVE [IO_THREAD|SQL_THREAD];</li>
</ol>
<h4 id="实验：配置主从复制架构"><a href="#实验：配置主从复制架构" class="headerlink" title="实验：配置主从复制架构"></a>实验：配置主从复制架构</h4><ol>
<li><p>配置主服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span>-bin</span><br><span class="line">server-id=1</span><br><span class="line">binlog-format=row</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主服务器创建用于主从复制的用户</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; grant replication slave on *.* to 'repluser'@'192.168.34.%' identified by '137226';</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置从服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">server-id=2</span><br><span class="line"><span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从服务器指定主服务器位置，复制用户、密码，及开始复制点</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; CHANGE MASTER TO</span><br><span class="line">  MASTER_HOST='192.168.34.102',</span><br><span class="line">  MASTER_USER='repluser',</span><br><span class="line">  MASTER_PASSWORD='137226',</span><br><span class="line">  MASTER_PORT=3306,</span><br><span class="line">  MASTER_LOG_FILE='mariadb-bin.000005',</span><br><span class="line">  MASTER_LOG_POS=329;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启slave</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt;start slave;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>至此，简单的主从复制已经实现，从服务器可以配置多个，只需要server-id不同即可。</p>
<p><strong>复制架构中应该注意的问题</strong></p>
<ol>
<li><p>限制从服务器为只读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在从服务器上设置read_only&#x3D;ON</span><br><span class="line">	注意：此限制对拥有SUPER权限的用户均无效</span><br><span class="line">阻止所有用户, 包括主服务器复制的更新</span><br><span class="line">	mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RESET SLAVE 在从服务器清除master.info ，relay-log.info, relay log ，开始新的relaylog ,注意：需要先STOP SLAVE</p>
</li>
</ol>
<p>RESET SLAVE ALL 清除所有从服务器上设置的主服务器同步信息如：PORT, HOST, USER和 PASSWORD 等</p>
<ol start="3">
<li><p>sql_slave_skip_counter = N 从服务器忽略几个主服务器的复制事件，global变量</p>
</li>
<li><p>如何保证主从复制的事务安全<br>参看<a href="https://mariadb.com/kb/en/library/server-system-variables/" target="_blank" rel="noopener">https://mariadb.com/kb/en/library/server-system-variables/</a><br>在master节点启用参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync_binlog&#x3D;1 每次写后立即同步二进制日志到磁盘，性能差</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果用到的为InnoDB存储引擎：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit&#x3D;1 每次事务提交立即同步日志写磁盘</span><br><span class="line">innodb_support_xa&#x3D;ON 默认值，分布式事务MariaDB10.3.0废除</span><br><span class="line">sync_master_info&#x3D;# #次事件后master.info同步到磁盘</span><br></pre></td></tr></table></figure>

<p>在slave节点启用服务器选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_slave_start&#x3D;ON 不自动启动slave</span><br></pre></td></tr></table></figure>

<p>在slave节点启用参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync_relay_log&#x3D;# #次写后同步relay log到磁盘</span><br><span class="line">sync_relay_log_info&#x3D;# #次事务后同步relay-log.info到磁盘</span><br></pre></td></tr></table></figure>

<h3 id="主从级联复制"><a href="#主从级联复制" class="headerlink" title="主从级联复制"></a>主从级联复制</h3><p>以A(192,168,34,108)，B(192.168.34.103)，C(192,。168.34.108)分别为主，从，二级从演示。</p>
<ol>
<li><p>主服务器主服务器如上。</p>
</li>
<li><p>在从服务器开启二进制日志，并指定更新二进制日志,其余同上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin</span><br><span class="line">log-slave-updates</span><br></pre></td></tr></table></figure></li>
<li><p>将二级从服务器的主指向一级从服务器即可。</p>
</li>
</ol>
<h2 id="mysql主主复制"><a href="#mysql主主复制" class="headerlink" title="mysql主主复制"></a>mysql主主复制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主主复制：互为主从</span><br><span class="line">容易产生的问题：数据不一致；因此慎用</span><br><span class="line">考虑要点：自动增长id</span><br><span class="line">配置一个节点使用奇数id</span><br><span class="line">	auto_increment_offset&#x3D;1 开始点</span><br><span class="line">	auto_increment_increment&#x3D;2 增长幅度</span><br><span class="line">另一个节点使用偶数id	</span><br><span class="line">	auto_increment_offset&#x3D;2</span><br><span class="line">	auto_increment_increment&#x3D;2</span><br></pre></td></tr></table></figure>

<p><strong>主主复制的配置步骤：</strong></p>
<ol>
<li>各节点使用一个惟一server_id</li>
<li>都启动binary log和relay log</li>
<li>创建拥有复制权限的用户账号</li>
<li>定义自动增长id字段的数值范围各为奇偶</li>
<li>均把对方指定为主节点，并启动复制线程</li>
</ol>
<h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>默认情况下，MySQL的复制功能是异步的，异步复制可以提供最佳的性能，主库把binlog日志发送给从库即结束，并不验证从库是否接收完毕。这意味着当主服务器或从服务器端发生故障时，有可能从服务器没有接收到主服务器发送过来的binlog日志，这就会造成主服务器和从服务器的数据不一致，甚至在恢复时造成数据的丢失</p>
<h4 id="实验：实现半同步复制实验"><a href="#实验：实现半同步复制实验" class="headerlink" title="实验：实现半同步复制实验"></a>实验：实现半同步复制实验</h4><ol>
<li><p>先搭建主从复制架构，（最少一主两从三台服务器）</p>
</li>
<li><p>配置主服务器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';</span><br><span class="line">mysql&gt;SET GLOBAL rpl_semi_sync_master_enabled=1; #永久保存可写入配置文件</span><br><span class="line">mysql&gt;SET GLOBAL rpl_semi_sync_master_timeout = 1000;超时长为1s #永久保存可写入配置文件</span><br><span class="line">mysql&gt;SHOW GLOBAL VARIABLES LIKE '%semi%';</span><br><span class="line">mysql&gt;SHOW GLOBAL STATUS LIKE '%semi%‘;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置从服务器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';</span><br><span class="line">mysql&gt; SET GLOBAL rpl_semi_sync_slave_enabled=1; #永久保存可写入配置文件</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="mysql复制过滤器"><a href="#mysql复制过滤器" class="headerlink" title="mysql复制过滤器"></a>mysql复制过滤器</h3><p>让从节点仅复制指定的数据库，或指定数据库的指定表<br>两种实现方式：</p>
<ol>
<li><p>服务器选项：主服务器仅向二进制日志中记录与特定数据库相关的事件<br>注意：此项和binlog_format相关<br>参看：<a href="https://mariadb.com/kb/en/librarymysqld-options/#-binlogignore-db" target="_blank" rel="noopener">https://mariadb.com/kb/en/librarymysqld-options/#-binlogignore-db</a><br>在主服务器配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binlog_do_db &#x3D; 数据库白名单列表，多个数据库需多行实现 </span><br><span class="line">binlog_ignore_db &#x3D; 数据库黑名单列表</span><br></pre></td></tr></table></figure>
<p>问题：基于二进制还原将无法实现；不建议使用</p>
</li>
<li><p>从服务器SQL_THREAD在replay中继日志中的事件时，仅读取与特定数<br>据库(特定表)相关的事件并应用于本地<br>问题：会造成网络及磁盘IO浪费<br>在从服务器配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replicate_do_db&#x3D; 指定复制库的白名单</span><br><span class="line">replicate_ignore_db&#x3D; 指定复制库黑名单</span><br><span class="line">replicate_do_table&#x3D; 指定复制表的白名单</span><br><span class="line">replicate_ignore_table&#x3D; 指定复制表的黑名单</span><br><span class="line">replicate_wild_do_table&#x3D; foo%.bar% 支持通配符</span><br><span class="line">replicate_wild_ignore_table&#x3D;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="mysql主从复制加密"><a href="#mysql主从复制加密" class="headerlink" title="mysql主从复制加密"></a>mysql主从复制加密</h3><p><strong>基于SSL复制：</strong><br>在默认的主从复制过程或远程连接到MySQL/MariaDB所有的链接通信中的数据都是明文的，外网里访问数据或者复制，存在安全隐患。通过SSL/TLS加密的方式进行复制的方法，来进一步提高数据的安全性</p>
<p><strong>获取证书</strong></p>
<ol>
<li><p>生成私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#(umask 066;openssl genrsa 2048 &gt; cakey.pem)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成自签名证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#openssl req -new -x509 -key cakey.pem -out cacert.pem -days 3650</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成主服务器私钥及证书申请</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#openssl req -newkey rsa:2048 -days 365 -nodes -keyout master.key &gt; master.csr</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成从服务器私钥和证书申请</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#openssl req -newkey rsa:2048 -days 365 -nodes -keyout slave.key &gt; slave.csr</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分别给master.csr和slave.csr办法证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#openssl x509 -req -in master.csr -CA cacert.pem -CAkey cakey.pem -set_serial 01 &gt; master.crt</span></span><br><span class="line">[root@mariadb ssl]<span class="comment">#openssl x509 -req -in slave.csr -CA cacert.pem -CAkey cakey.pem -set_serial 02 &gt; slave.crt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证证书的有效性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#openssl verify -CAfile cacert.pem master.crt slave.crt</span></span><br><span class="line">master.crt: OK</span><br><span class="line">slave.crt: OK</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>此时的目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#ls</span></span><br><span class="line">cacert.pem  master.crt  master.key  slave.csr</span><br><span class="line">cakey.pem   master.csr  slave.crt   slave.key</span><br><span class="line">[root@mariadb ssl]<span class="comment">#pwd</span></span><br><span class="line">/etc/my.cnf.d/ssl</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>将相关证书分别拷贝到主服务器和各从服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mariadb ssl]<span class="comment">#scp cacert.pem slave.crt slave.key 192.168.34.108:/etc/my.cnf.d/ssl/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置主服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin</span><br><span class="line">server_id&#x3D;1</span><br><span class="line">ssl</span><br><span class="line">ssl-ca&#x3D;&#x2F;etc&#x2F;my.cnf.d&#x2F;ssl&#x2F;cacert.pem</span><br><span class="line">ssl-cert&#x3D;&#x2F;etc&#x2F;my.cnf.d&#x2F;ssl&#x2F;master.crt</span><br><span class="line">ssl-key&#x3D;&#x2F;etc&#x2F;my.cnf.d&#x2F;ssl&#x2F;master.key</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置从服务器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt;</span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST=<span class="string">'192.168.34.102'</span>,</span><br><span class="line">MASTER_USER=<span class="string">'rplssl'</span>,</span><br><span class="line">MASTER_PASSWORD=<span class="string">'centos'</span>,</span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mariadb-bin.000005'</span>,</span><br><span class="line">MASTER_LOG_POS=<span class="number">329</span>,</span><br><span class="line">MASTER_SSL=<span class="number">1</span>,</span><br><span class="line">MASTER_SSL_CA = <span class="string">'/etc/my.cnf.d/ssl/cacert.pem'</span>,</span><br><span class="line">MASTER_SSL_CERT = <span class="string">'/etc/my.cnf.d/ssl/slave.crt'</span>,</span><br><span class="line">MASTER_SSL_KEY = <span class="string">'/etc/my.cnf.d/ssl/slave.key'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="主从复制的监控和维护"><a href="#主从复制的监控和维护" class="headerlink" title="主从复制的监控和维护"></a>主从复制的监控和维护</h3><p><strong>清理日志</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PURGE &#123; BINARY | MASTER &#125; LOGS &#123; TO &#39;log_name&#39; | BEFORE</span><br><span class="line">datetime_expr &#125;</span><br><span class="line">RESET MASTER</span><br><span class="line">RESET SLAVE</span><br></pre></td></tr></table></figure>

<p><strong>复制监控</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS</span><br><span class="line">SHOW BINLOG EVENTS</span><br><span class="line">SHOW BINARY LOGS</span><br><span class="line">SHOW SLAVE STATUS</span><br><span class="line">SHOW PROCESSLIST</span><br></pre></td></tr></table></figure>

<p><strong>从服务器是否落后于主服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Seconds_Behind_Master: 0</span><br></pre></td></tr></table></figure>

<p><strong>如何确定主从节点数据是否一致</strong><br> percona-tools</p>
<p><strong>数据不一致如何修复</strong><br> 删除从数据库，重新复制</p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>主从复制</tag>
      </tags>
  </entry>
</search>
